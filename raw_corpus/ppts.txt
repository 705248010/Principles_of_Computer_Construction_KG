1.1计算机的分类

电子计算机从总体上来说分为两大类：

电子模拟计算机

特点是数值由连续量来表示，运算过程也是连续的。

电子数字计算机

主要特点是按位运算，并且不连续地跳动计算。

10

11

1958年完成的我国自行研制的模拟计算机红旗-551，慈云桂

12

1960年，我国自行设计的第一台电子数字计算机107机

中科院计算机夏培肃领导研制

她也是我国计算机事业的奠基者

现在计算机中的一些术语和专业名词都是她翻译的。

中国计算机之母

13

1.1.1计算机的分类

根据性能、经济性和适应性，可以划分为两类：

专用计算机：专用机是最有效、最经济和最快速的计算机，但是它的适应性很差。

通用计算机：通用计算机适应性很大，但是牺牲了效率、速度和经济性。

通用计算机分类

可以分为：

超级计算机

大型机

服务器

工作站

微型机

单片机



区别在于：体积、简易性、功耗、性能指标、数据存储容量、指令系统规模和机器价格等



14

1.2 计算机发展简史

计算机的五代变化

1946—1957年，电子管计算机：数据处理

1958—1964年，晶体管计算机：工业控制

1965—1971年，中小规模集成电路计算机：小型计算机

1972—1990年，大规模和超大规模集成电路计算机：微型计算机

1991年至今，甚大规模集成电路计算机：单片机

15

1.2.2 半导体存储器的发展

20世纪50～60年代，所有计算机存储器都是由微小的铁磁体环构成

1970年，仙童半导体公司生产出了第一个较大容量半导体存储器

从1970年起，半导体存储器经历了若干代：单个芯片1KB~1MB~1GB。

其中1K=103 1M=103K=106,1G=103M=109

1bit表示1个二进制位，1B=8bit

规范的二进制位计数：1Ki=210,1Mi=220,1Gi=230

16

1.2.3 微处理器的发展

1971年Intel公司开发出4004。 

1972年出现的8008，这是第一个8位微处理器

1974年出现了8080，这是第一个通用微处理器。

17



1.2.3 微处理器的发展

20世纪70年代末出现通用16位微处理器8086 

Intel于1985年推出了32位微处理器80386。 

到现在的64位处理器和多核处理器

18

我国计算机技术的发展

1953年起步，

1958年第一台103型通用计算机

50年来相继研究出了第二代，第三代计算机。

80年代研究出每秒１亿次的巨型机，银河I,II, 曙光等。

85年6月，第一台实现中文化系统、并量产的国产微机长城0520CH正式研发成功。

在高性能计算，并行计算上已紧跟国际先进水平，但计算机的核心部件CPU技术还远远落后。

19

1.2.3 微处理器的发展

微处理器一般称为CPU：Central Process Unit

目前CPU芯片主要设计/生产商

Intel：酷睿、奔腾、赛扬、至强！ 

AMD：速龙、闪龙、皓龙、APU-天津海光 

VIA ： C3、C7-上海兆芯 

IBM：-苏州国芯

龙芯：嵌入式、桌面、专用计算机

ARM：三星、高通、华为海思、华为鲲鹏

20

1.2.3 微处理器的发展

龙芯属于MIPS架构（LoongArch）

上海兆芯属于X86架构

华为麒麟/鲲鹏属于ARM架构

阿里平头哥属于RISC-V架构

中国有着全球数量最多的芯片设计公司

展讯、寒武纪等

小米，百度、VIVO、OPPO都在布局芯片

还未形成规模效益、人才缺口非常大

通用计算机分类

可以分为：

超级计算机

大型机

服务器

工作站

微型机

单片机



区别在于：体积、简易性、功耗、性能指标、数据存储容量、指令系统规模和机器价格等



22

超级计算机-Top500（2023.5）

1、Frontier (美) , 处理器核：8,730,112；峰值1102PFlop/s；AMD 处理器

2、Fugaku(日) , 处理器核：7,630,848；峰值442PFlop/s；ARM 处理器

2、LUMI(芬兰), 处理器核：1,110,144；峰值151.9PFlop/s； AMD 处理器+ NVIDIA Tesla V100

7、神威 太湖之光, 处理器核：10,649,600；峰值93.01PFlop/s；神威处理器

10、天河2A, 处理器核：4,981,760；峰值61.4PFlop/s；Intel+国产Matrix-2000加速卡

23

超级计算机-Top500（2024.5）

1、Frontier (美) , 处理器核：8,699,904；峰值1.206EFlop/s；AMD 处理器

2、Aurora(美) , 处理器核：9,264,128；峰值1.012EFlop/s；Intel 处理器

3、Eagle(美), 处理器核：2,073,600；峰值561.2PFlop/s； Intel 处理器+ NVIDIA H100

4、Fugaku(日) , 处理器核：7,630,848；峰值442PFlop/s；ARM 处理器

5、LUMI(芬兰), 处理器核：2,752,704；峰值379.7PFlop/s； AMD 处理器+ NVIDIA Tesla V100

Top500组织在最新发布的报告中指出，中国已决定不再参加Top500的HPL基准测试。

24

日本Fugaku-富岳

富士通和日本理化学研究所共同研制

拥有超过7,630,848个核心，内存4752TB

富士通A64FX处理器， ARM v8.2-A，配备32GB HBM 2内存，带宽1TB/s，浮点性能2.7TFLOPS，使用台积电7nm工艺生产，晶体管数量 878.6 亿

A64FX 包含 48 个计算核心和 2 ~ 4 个辅助核心，没有 GPU 加速器，封装 HBM2 内存。



25

2024/6/5

神威-太湖之光

2017年TOP500第一， 2020年第四

拥有40960个计算节点，内存1.31PB

使用了国产众核芯片申威26010

采用28nm制程工艺，主频1.45GHz

拥有260个核心，浮点峰值达到3.06TFlops

64位

26

1.2.4 计算机的性能指标

27

2024/6/5

1.2.4 计算机的性能指标

CPU执行时间：

表示一段程序执行过程中所占用的CPU时间。

CPU时间=执行某段程序所使用的CPU周期数×CPU时钟周期

CPI：Cycle Per Instruction

执行一条指令所需的平均周期数

执行某段程序所使用的CPU周期数÷程序总指令数

MIPS：Million Instructions Per Second

每秒百万指令数

MIPS=程序总指令数÷(程序执行时间×106)

2024/6/5

28

1.2.4 计算机的性能指标

2024/6/5

29

CPU性能公式

30

CPU性能公式

31

CPU性能公式

32

2024/6/5

33

[例2]用一台50MHz处理机执行标准测试程序，它包含的混合指令数和相应所需的平均时钟周期如下表所示：

解

34

1.3 计算机的硬件

1.3.1 硬件组成要素

控制器

运算器

存储器

输入设备

输出设备

冯·诺依曼型计算机

Von Neumann 

1.3 计算机的硬件

冯·诺依曼型计算机 

五大组成部分

二进制表示

存储程序

程序控制

35

冯诺依曼架构

36

1.3.2 运算器

37

ALU- Arithmetic Logic Unit （算术逻辑运算单元）

算术运算和逻辑运算

在计算机中参与运算的数是二进制

运算器的长度一般是8、16、32或64位

计算机的字长

38

1.3.3 存储器

存储数据和程序

运算开始前，必须先将程序和数据存入存储器（存储程序思想）

一个存储单元中存入一个二进制数据串。

存储器按存储单元组织，存储器中有大量的存储单元。

为了方便查找，每个存储单元都被分配一个地址。

通常，存储器都是按地址查找，线性编址。

39

1.3.3. 存储器

存储器的容量一般都按字节计算

存储器单位：

210 Byte＝1KiB

210 KiB＝1MiB

210 MiB＝1GiB

210 GiB＝1TiB

分类：内存、外存

1.3.3. 存储器

内存有两种操作：

写入：数据存入存储器

写入新数据后，会“覆盖”旧数据

读出：从存储器取出数据

读出并不破坏存取器中的数据

可以从同一存储单元中反复的读出同一数据



40

1.3.4 控制器

控制器是计算机中发号施令的部件

控制计算机的各部件有条不紊地工作

任务：从内存中取出指令加以分析,然后执行某种操作（指令控制）

一条指令（instruction）完成一种操作

算术运算或者逻辑运算、传输数据等

将复杂的问题简化为一系列简单操作

每个简单操作用一条指令完成，

一系列指令的有序集合叫做程序（program）

41

1.3.4 控制器

(2)指令的形式 

指令的内容由两部分组成，即操作的性质和操作数的地址。



每条指令应当明确告诉控制器，从存储器的哪个单元取数，并进行何种操作。

指令系统：计算机的全部指令集合。

42

范例-模型计算机



43



存储器



运算器和控制器

存储单元

44



模型计算机

存储器



运算器和控制器

范例

45

范例

46

47

存储器中的机器语言程序



10

11

12

13

9

8

7

6

5

4

3

2

1

指令集

构造机器指令

将汉语表达转为二进制表示

汇编源程序

同一个问题在不同实现的计算机上解决，步骤是不同的。

编译器



48



要考虑两个问题：

数据存储

数据处理

模型计算机

存储器



49

表1.4 计算 y=ax+b-c 的程序

表1.5 指令的操作码定义 

51



(2)指令的形式 

数码化的指令和数据都放入存储器，两种方式：

冯诺依曼结构（Von Neumann Architecture）：存储器的任何位置既可以存放数据也可以存放指令

哈佛结构（Harvard Architecture ）：指令和数据存储器物理上独立

52

冯诺依曼结构

哈佛结构

(2)指令的形式 

存储程序：将程序（指令序列）和数据存放到存储器中

程序控制：控制器依据存储的程序来全机协调地计算任务

53

控制器执行程序的过程

2024/6/5

54

取指令

101 1001

执行

（9）→A 

取指令

011 1100

执行

(12)→B ;

(A)*(B)→A 



取指令

001 1010

执行

(10)→B ;

(A)+(B)→A 

 

取指令

0101011 

执行

(11)→B ;

(A)-(B)→A 



取指令

1101101

执行

A → (13) 

 

取指令

1110000 

执行

Stop 



STO 13

LAD 9

MUL 12

ADD 10

SUB 11

SLT

1.3.4 (3)控制器的基本任务

按照特定的顺序一条接着一条取指令、执行指令。

55

取指令

101 1001

执行

（9）→A 

取指令

011 1100

执行

(12)→B ;

(A)*(B)→A 



取指令

001 1010

执行

(10)→B ;

(A)+(B)→A 

 

取指令

0101011 

执行

(11)→B ;

(A)-(B)→A 



取指令

1101101

执行

A → (13) 

 

取指令

1110000 

执行

Stop 



1.3.4 (3)控制器的基本任务

每取出一条指令，控制器中的指令计数器就加1，下一条指令做好准备

指令计数器(Program counter:PC)

保存指令的地址

指令要顺序存放

每条指令在存储器都有地址

56

存储器中的机器语言程序

7

6

5

4

3

2

1



指令地址

1.3.4 (3)控制器的基本任务

时间因素

取指周期：从存储器中取指令到控制器的时间

执行周期：在控制器中执行指令的时间

57

时间t

1.3.4 （4）指令流和数据流

如何区分内存输出的是指令流？还是数据流？

根据不同的时间

取指周期中从内存读出的信息流是指令流，它流向控制器

执行周期中从内存读出的信息流是数据流，它由内存流向运算器。

58

1.3.4 控制器

其他任务：

保证指令按规定序列自动连续地执行。

对各种异常情况及时响应和处理。

控制器向计算机各功能部件提供每一时刻协同运行所需要的控制信号



59

1.3.5 适配器与输入输出设备

输入设备：把人们所熟悉的信息形式变换为二进制信息形式

输出设备：把计算机处理结果变换为人或其他机器设备所能接收和识别的信息形式

总线：构成计算机系统的骨架，是多个系统部件之间进行数据传送的公共通路。

60

1.4 计算机的软件

1.4.1 软件的组成与分类

61

1.4.2 软件的发展演变

编程语言的发展

手编程序：机器语言程序，手工编译二进制码



汇编程序：符号语言程序，汇编程序汇编



62

可执行程序

目的程序

机器语言

可执行程序

目的程序

汇编语言

手工编写

汇编源程序

汇编程序

翻译

1.4.2 软件的发展演变

编程语言的发展

高级程序：算法语言/高级语言



编译系统：把源程序全部翻译成目的程序，然后机器执行目的程序

解释系统：逐一翻译源程序语句并立即执行该语句。

63

源程序

可执行程序

目标程序



编辑程序

汇编或编译程序



联接程序

高级语言

1.4.2 软件的发展演变

系统软件的发展

操作系统：用来管理计算机软硬件资源和自动用户作业调度，而使多个用户能有效地共用一套计算机系统。

数据库管理系统：数据库和数据库管理软件

分布式系统软件



64

1.5 计算机系统的层次结构

计算机是一个硬、软件结合而成的整体。它通常由五级组成。

不同的计算机使用者看到的计算机的形式是不同的

65

1.5 计算机系统的层次结构

高级语言级：方便用户编写应用程序，由各种高级语言编译程序支持和执行。

汇编语言级：提供一种符号形式语言，以便能够精确地操作控制硬件。

操作系统级：它由操作系统程序实现，管理所有的硬件资源



66

1.5 计算机系统的层次结构

一般机器级：由微程序解释机器指令系统。

微程序设计级：实际执行指令、处理数据的数字电路。



67

1.5.2 软件与硬件逻辑等价性

随着大规模集成电路技术的发展

任何操作可以由软件来实现，也可以由硬件来实现；

采用哪种方案？

应综合考虑各个因素：价格、速度、可靠性、存储容量、变更周期

固件：介于传统的软件和硬件间的实体。

功能------软件

形态------硬件

实现------软件写入ROM------固化

68

第一章小结

计算机的分类

冯·诺依曼型计算机特点

计算机硬件的基本组成部分

五大部件

运算器、控制器、存储器

计算机软件

计算机的性能指标

计算机层次结构



69

返回

作业

P15：4、5、6、7、8、14

70

一段C程序

		int main()

		{

		int a = 2, b = 3;

		int c, d;

		c = a + b;

		d = a * b;

		}

在线编程网站

https://gcc.godbolt.org/



X86架构的指令序列



X86架构的指令序列

8051单片机架构的指令序列

SPARC V8架构的指令序列

人工智能四层架构

76

2024/6/5

AI不同计算任务需要不同芯片

77

GPU与AI模型训练

78

FPGA：分布式+可定制

79

ASIC：实现性能和功耗均衡

80

国产服务器CPU

81

自动驾驶芯片指标AI算力TOPS

根据地平线数据，L2级自动驾驶的算力需求为2-2.5TOPS，

L3级自动驾驶算力需求为20-30TOPS,L4级自动驾驶算力需求为200TOPS以上，L5级自动驾驶算力需求为2000TOPS以上。



82

算力单位TOPS

TOPS (Tera Operations Per Second)，表示每秒执行1万亿次(10^12)运算，用于衡量自动驾驶芯片的AI算力。

TOPS描述芯片MAC(Multiply Accumulate，乘积累加运算)的运算能力，并没有指定数据类型，具体算力评估需要结合数据类型及精度。

MAC运算包括相乘和相加(a←a+b*c)。对于卷积、点积、矩阵等运算而言，MAC指令可以大幅提高运算效率。

TOPS计算公式：理论峰值 = MAC矩阵行 * MAC矩阵列 * 主频 * 2

83



84



现代GPU集群极度耗电。GPT 4在训练过程中使用了约50 GWh的能量。相当于30辆普通汽车环绕地球300次。谷歌表示一次搜索使用0.28瓦时，而与谷歌搜索相比，Google GPT 4使用的能量大约是谷歌搜索的四倍。



85



86



SM（Streaming Multiprocessors）

称为流式多处理器，是NVIDIA GPU的基本构建模块。每个SM包含CUDA核心（用于通用计算的处理单元）、张量核心（专门用于AI工作负载）以及其他用于图形和计算操作的组件。

SM具有高度并行性，使GPU能够同时执行许多操作。

主芯片上共有144个SM。但它们的参数产量约为90％，这意味着我们可以使用大约130个。在生产过程中发生故障的部分会被关闭。此外，如果看一下主芯片的尺寸，那是一个相当大的芯片，非常接近现代工厂机器的限制。。

87



HBM（高带宽内存）

HBM是一种具有高带宽接口的堆叠内存类型。与传统的GDDR内存相比，HBM提供了显著更多的带宽，可以实现GPU和内存之间的数据传输速率更快，这对于对带宽需求高的任务（如深度学习和大数据分析）特别有益。如果查看内存控制器，您会看到有6个，但NVIDIA只启用了其中的5个。



88



89


第二章 运算方法和运算器

2.1 数据与文字的表示方法

2.2 定点加法、减法运算

2.3 定点乘法运算

2.4 定点除法运算

2.5 定点运算器的组成

2.6 浮点运算方法与浮点运算器

1

返回

2

2.1 数据与文字的表示方法

2.1.1 数据格式

2.1.2 数的机器码表示

2.1.3 字符与字符串的表示方法

2.1.4 汉字的表示方法

2.1.5 校验码

3

2.1数据与文字的表示方法

两大类数据：

符号数据：非数字符号的表示（字符、汉字、图形等）

数值数据：数字数据的表示方式（定点、浮点）

编码：用少量、简单的基本符号，选择合适的规则表示尽量多的信息，同时利于信息处理（速度、方便）

ASCII、GB、Unicode

MP3、FLAC、JPG、H.264、H.265等

二进制与易经

系统的提出二进制观点的是德国的数学家和哲学家莱布尼茨

据说他根据易经发明了二进制

太极生两仪，两仪生四象，四象生八卦

两仪：阴和阳

2024/6/5

4

易经八卦

2024/6/5

5

2024/6/5

6

2.1.1 数据格式

计算机数据的表示方式，考虑几个因素：

数的类型（小数、整数、实数、复数）

数值范围

数值精度

存储、处理、传送的硬件代价

软件兼容性



7

2.1.1 数据格式

8

十进制转二进制

整数部分除2取余 小数部分乘2取整

5

2

1

0



0.625 * 2

1

0.25 * 2

0

0.5* 2

1

 0.0 

除尽为止 1011



低

高



求得位数满足要求为止

进制转换的简单运算方法

－17/128的二进制表示?

大数的转换方法，记住几个常用的2的幂

9

25＝3226＝6427＝12828＝25629＝512 

210＝1024(1Kilo)211＝2048212＝4096

213＝8182 214＝16364 215＝32728

216＝65536 220＝1Mega 

230＝ 1Giga(吉)240＝1Tera(太)

更大的单位是多少？

250＝1 Peta260＝1 Exa270＝1 Zetta 280＝1 Yotta

千、兆、吉、太、拍、艾、泽、尧

分、厘、毫、微、纳

进制转换的简单运算方法

10

15 = 24-1＝16-1=10000-1= 1111

31 = 25-1＝32-1 =100000-1= 11111

127 = 27-1＝128-1=10000000-1 =111_1111 

255 =28-1＝256-1=1111_1111 

1023 =210-1＝1024-1=11_1111_1111 

65535=216-1＝65536-1 = 1111_1111_1111_1111



几个简化运算的例子

130=?

=128+2=27+2=10000000+10=10000010

65539=?

=65536+3=216+3=1_0000_0000_0000_0011



2010=?

=2047-37=2048-1-32-4-1=211-1-25-22-1

=111_1111_1111-25-22-1=111_1101_1010

111111110111＝?

=212-1-8

17/128=10001/27=0.0010001



 -11- 

计算机中使用的计量单位

12

我国传统文化中的数量单位

13

2.1.1数据格式

计算机中数值数据表示格式：

定点表示：小数点位置固定

浮点表示：小数点位置不固定

定点格式容许的数值范围有限（字长一定），硬件简单。

浮点格式容许的数值范围很大，硬件复杂。

2024/6/5

14

1. 定点数的表示方法

约定数据的小数点位置固定

小数点不使用记号”.”表示

将数据表示成纯小数或纯整数

定点数表示：

带符号数

不带符号数

运算器利用寄存器存储数据

寄存器中每个位称bit (Binary Digit)

最高有效位 (MSB)、最低有效位 (LSB)

2024/6/5

15

2024/6/5

16

1. 定点数的表示方法



xn xn-1 xn-2… x1 x0



数的表示范围:



符号：

0代表正号

1代表负号

量值

小数点位于符号位之后，不需专门存放位置

带符号定点纯小数

2024/6/5

17

 定点纯整数



xn xn-1 xn-2… x1 x0



MSB为符号

量值

小数点固定于LSB之后

例：字长8位

 X=+1010110.



纯整数：X = 01010110



正数，符号位取0

Y= - 1101001.



纯整数：Y = 11101001 （原码）



负数，符号位取1

X=+0.11011

Y=-0.10101



符号位取0

纯小数：X = 01101100



符号位取1

纯小数：X = 11010100 （原码）

2024/6/5

19

1. 定点数的表示方法

纯整数的表示范围(n+1位)



1. 定点数的表示方法

受字长限制，表示数的范围有限;

定点小数表示的精度有限

目前计算机中采用定点数表示纯整数，因此将定点数表示的运算简称为整数运算。

2024/6/5

20

2.浮点数的表示方法

2024/6/5

21

2024/6/5

22

2.浮点数的表示方法

指数e

基数R

尾数M

2.浮点数的表示方法

一个浮点数由阶码和尾数及其符号位组成

尾数M：用定点小数表示，表明有效数字的位数，决定了浮点数的表示精度

阶码E：用定点整数表示，指明小数点的位置，决定了浮点数的表示范围

2024/6/5

23

IEEE754 标准

2024/6/5

24

IEEE 754 32位单精度浮点数标准

2024/6/5

25

浮点数的规格化

例：156.78	=15.678×101	

	= 1.5678×102

	= 0.15678×103=RE×M

对于二进制数

1011.1101	=0.10111101 ×2+4

	= 0.0010111101 ×2+6 

	= 1.0111101 ×2+3 

那么，计算机中究竟采用哪种数据形式？



多种数据形式



规格化表示法

2024/6/5

27

IEEE754 标准

规格化： 同一真值浮点数具有唯一的表示形式

规格化尾数应为如下形式：

		1.xxxxxxxxx

整数位的1属于隐藏位，在实际存储时，尾数域只存储小数点后面的数值。

规格化表示：当尾数不为 0，

尾数左移1位（小数点右移1位），同时阶码减1（左规）

尾数右移1位（小数点左移1位），同时阶码加1（右规）



IEEE754 标准

一个规格化的32位浮点数x的真值表示为

 x=(-1)S×(1.M)×2E-127 



64位的浮点数（双精度浮点数）

符号位1位，阶码域11位，尾数域52位，指数偏移值是1023。

规格化的64位浮点数x的真值为：

 x=(-1)S×(1.M)×2E-1023 



2024/6/5

28

2024/6/5

29

2.浮点数的表示方法

【例1】若浮点数x的754标准存储格式为(41360000)16，求其浮点数的十进制数值。

解：将16进制数展开后，可得二制数格式为



指数e=阶码-127=10000010-01111111=00000011=(3)10

包括隐藏位1的尾数

1.M=1.011_0110_0000_0000_0000_0000=1.011011

于是x=(-1)S×1.M×2e

=+(1.011011)×23=+1011.011=(11.375)10

2024/6/5

30

2.浮点数的表示方法

【例2】将数(20.59375)10转换成754标准的32位浮点数的二进制存储格式（16进制表示）。

解:首先分别将整数和分数部分转换成二进制数：

 20.59375=10100.10011

 规格化，尾数右移4位 10100.10011=1.010010011×24

 e=4，于是得到：

 S=0, E=4+127=131, M=010010011

最后得到32位浮点数的二进制存储格式为：

 0100_0001_1010_0100_1100_0000_0000_0000=(41A4C000)16

真值0的机器数（机器零）

阶码E＝0，尾数M＝0

正0：S＝0，负0：S＝1

非规格化浮点数：阶码E＝0，尾数M≠0

规格化浮点数：阶码E＝1～254（11111110）

无穷大的机器数

阶码E＝全1（11111111） ，尾数M＝0

＋∞：S＝0，－∞：S＝1

NaN（not a number，不是一个数）

阶码E＝全1（11111111） ，尾数M≠0

用来通知异常情况

IEEE 754标准

32位单精度浮点数

单精度IEEE浮点数区间

2024/6/5

32

1≦E≦254

E=255

E=0

M=0

M≠0

M=0

M≠0

规格化浮点数的范围

正0或负0

正/负无穷大

NaN

非规格化数

2024/6/5

33

2.浮点数的表示范围

浮点数所表示的范围远比定点数大

一般计算机中同时采用定点、浮点表示。

单片机中多采用定点表示。

IEEE 754单精度在线转换

https://www.h-schmidt.net/FloatConverter/IEEE754.html

2024/6/5

34

3.十进制数串的表示方法

有时十进制数在计算机中需要以十进制的方式进行运算，需要对十进制进行编码

二-十进制编码（BCD码）

每个十进制符号由4位二进制数表示

8421有权码

名称表示每一位的位权（8、4、2、1）

每位的数码与相应的位权相乘，再求和，得到它所代表的十进制数码

74.56表示：0111 0100 0101 0110

2024/6/5

35


2024/6/5

1

2.1.2 数的机器码表示

一般书写表示的数，称为真值

计算机中表示的数，称为机器数

在计算机中，为了妥善的处理好符号位问题，主要是负数的运算问题，引入4种表示方法：

原码、补码、反码、移码。

1. 原码表示法

定点整数的原码形式为xnxn-1… x1x0

字长8位：

X＝+105，则 [X]原 ＝01101001

X＝-105， 则 [X]原 ＝10000000+1101001

				＝11101001

0使用原码有两种表达形式

　　　 [+0]原 =00000000

　　 [-0]原 =10000000

2024/6/5

3

1. 原码表示法

特点：

表示简单，易于同真值之间进行转换，

实现乘除运算简单。

进行减法运算麻烦。

要比较绝对值的大小，然后绝对值大的数减去绝对值小数，最后给结果选择符号。

为了解决这些矛盾，找到了补码表示法。

2024/6/5

4

2. 补码表示法

2024/6/5

5

2. 补码表示法

2024/6/5

6

3. 反码表示法

定义：

正数的反码表示与原码相同

负数的反码符号位不变，数值位是将原码的数值位按位取反。



电路很容易实现，

触发器的输出正负两值。

2024/6/5

7

3. 反码表示法

反码表示有正0和负0之分

　 	 [+0]反 =00000000 [-0] 反 =11111111

负整数补码：反码加1

解决了求补码还要减法的问题

	[-105]补＝10010110＋1＝10010111

负数求补

负数原码“符号位不变，数值位取反加1”得对应补码

负数补码再求补得到负数原码

补码：11100000

原码：1[1100000]求反＋1

			＝10011111+1

		＝10100000

2024/6/5

9

4. 移码表示法

传统定义和754标准浮点数阶码的定义不同

2024/6/5

10

移码和补码尾数相同，符号位相反

[例8]设机器字长16位,定点表示,尾数15位,数符1位,问：定点原码整数表示时，最大正数是多少?最小负数是多少? 

[解:]　 定点原码整数表示



　 　最大正数值＝(215－1)10＝(＋32767)10 　



最小负数值＝－(215－1)10＝(－32767)10

 

数的机器码表示

正数的原码、反码、补码等于真值，只有负数才分别有不同的表示方法

采用补码，减法运算可以用加法运算实现，节省硬件，目前机器中广泛采用补码表示法

有些机器用原码进行存储和传送，运算时改用补码

移码表示法主要用于表示浮点数的阶码，可以直接比较大小。表示范围和补码相同，只有最高位相反

同一代码的不同含义

一个代码，采用不同编码，其数值不一样

计算机内一个二进制数：	1000 0001

不同的含义

无符号二进制数：	129

8421 BCD码：	81

有符号整数的原码：	-1

有符号整数的反码：	-126

有符号整数的补码：	-127

2.1.3字符和字符串的表示方法

非数值数据

通常指的是字符、字符串、图形符号、汉字等数据

必须按照一定的规则用一组二进制编码来表示

ASCII

美国国家标准局（ANSI）制定的ASCII（American Standard Code for Information Interchange，美国信息交换标准码）是现今最为通用的单字节编码系统

主要用于显示现代英文字母和符号

15

16

ASCII码用7位二进制编码表示一个字符，总共可以表示128个字符

计算机用一个字节来存放一个ASCII字符，最高位固定为0

2024/6/5

17

IBM PC 104 键盘keyboard (Windows格式)

18

2.1.4 汉字的表示方法

1. 汉字的输入编码 

用西文标准键盘上对汉字进行编码： 

数字编码：是用数字串代表一个汉字的输入, 如区位码等。最大优点是无重码, 但难记. 

字音编码：以汉语拼音作为编码基础。简单易学, 但重码很高, 有微软拼音、智能ABC输入法等。 

字形编码法：将汉字的字形信息分解归类而给出的编码。具有重码少的优点。常用的有表五笔字型、郑码等。

音形编码法：音形编码吸取了音码和形码的优点，使编码规则简化,重码少。常用的有全息码等。 

2.1.4 汉字的表示方法

2.汉字内码

汉字内码是汉字的机内代码。

一般采用两个字节表示。

为了与ASCII区别，汉字内码中两个字节的MSB规定为“1”。

汉字字符集编码查询https://www.qqxiuzi.cn/bianma/zifuji.php

2024/6/5

19



2024/6/5

20

汉字内码

1981年，国标码字符集GB2312

每个编码2个字节，共收集常用简体汉字6763个

1984年，BIG5 字符集

称大五码，共收录13053个中文字，港台地区使用

1995年，GBK字符集

共收录汉字21003个，支持繁体中文、日韩汉字

2000年，GB18030 字符集

收录了27484个汉字，覆盖中、日、朝鲜语和中国少数民族文字

向下兼容GBK、GB2312

2024/6/5

21

2024年6月5日星期三

22

Unicode码

容纳全世界所有语言中任意一种符号

为每种语言中的每个字符设定惟一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求

UCS-2

2-byte Universal Character Set，每个字符占用2个字节，实际使用比较多

UCS-4

每个字符占用4个字节，理论上可以表示231=2 147 483 648个字符

Unicode码

为了解决Unicode的传输、存储问题，主要是网络传输，对Unicode进行二次编码

UTF：Unicode Transformation Format

UTF-8

可变长格式

对英文使用1个字节，中文使用3 个字节来编码

UTF-16

拿2个字节来表示字符

字符编码查询https://www.qqxiuzi.cn/bianma/zifuji.php

2024/6/5

23

2024/6/5

24

Chrome浏览器中打开的web页面，点击右键，选择“查看网页源代码”

华电主页www.ncepu.edu.cn的编码

记事本编码区别？

 -25- 

2.1.4 汉字的表示方法

3. 汉字输出码

为了能显示和打印汉字，必须先存储汉字的字形，这就是汉字字形码

两类字形码：点阵字形和矢量字形

2024/6/5

26

3. 汉字输出码

点阵字形又称字模码

每个字由m×n个像素的位图表示，称m×n点阵

点阵中的每个点都只有两种状态

1表示有笔画，对应像素应置为字符颜色；

0表示无笔画，对应像素应置为背景颜色或不改变



27

2.1.4 汉字的表示方法

一个16 点阵字形（左图），一行用 2 个字节描述，总供有 16 行，它的信息量是 2*16=32 个字节。

一个 48 点阵字形用 6 个字节乘 48 行组成，它的信息量是 6*48=288 个字节。

复原字形速度快，但缩放后的字形质量难以保证



2.1.4 汉字的表示方法

矢量字形

通过数学方程来描述

包含了字形边界上的关键点、连线的导数信息等

在显示、打印时，要经过一系列的数学运算输出结果

字体可以无限放大而不产生变形

目前主流的矢量字体格式有3种：

Type1，TrueType和OpenType

29

2.1.5校验码

数据在存取和传送的过程中可能会发生错误

产生错误的原因可能有很多种

设备的临界工作状态

外界高频干扰

收发设备中的间歇性故障等

为减少和避免错误

提高硬件本身的可靠性

对数据采用专门的逻辑电路进行编码，以检测错误，甚至校正错误

30

2.1.5校验码

方法

在每个字上添加一些校验位，用来确定字中出现错误的位置

计算机中常用的检错或纠错技术

奇偶校验Parity Check 

CRC循环冗余校验(Cyclic Redundancy Check) 

Hamming码，ECC校验



2024/6/5

31

若干位有效信息（如1个字节）加上1位校验位组成校验码

奇校验：校验码中1的个数为奇数

偶校验：校验码中1的个数为偶数

奇偶校验码

32

奇校验码

设8位信息码组为D7D6D5D4D3D2D1D0 ：

若D7~D0中有奇数个“1”，则奇校验位=0

奇校验位 D奇=D7⊕D6⊕D5⊕D4⊕D3⊕D2⊕D1⊕D0

读出数据时，将9位校验码送入校验电路

G= D7⊕D6⊕D5⊕D4⊕D3⊕D2⊕D1⊕D0⊕D奇

若G=0，则无错误

若G=1，则传输出现错误

33



34

【例10】 已知下表中左面一栏有5个字节的数据。请分别用奇校验和偶校验进行编码,填在右面2栏。

【解】 假定最低一位为校验位，高8位为数据位，列表如下：



	校验位的值取0还是取1，是由数据位中1的个数决定的

奇偶校验码

奇偶校验码是一种最简单且应用广泛

硬件成本很低

可以检测出一位或奇数位错误，但不能确定出错位置，

也不能检测出偶数位错误

一位出错的概率比多位同时出错的概率要高得多

常用于存储器读写检查或ASCII字符传送过程检查

2024/6/5

35


2024/6/5

1

2.2定点加法、减法运算

2.2.1 补码加法

2.2.2 补码减法

2.2.3 溢出概念与检测方法

2.2.4 基本的二进制加法/减法器

2024/6/5

2

2.2.1补码加法

2024/6/5

3

[ｘ]补＋[ｙ]补＝[ｘ＋ｙ]补证明

2024/6/5

4

[ｘ]补＋[ｙ]补＝[ｘ＋ｙ]补证明

(3)ｘ<0,ｙ>0,则ｘ＋ｙ>0或 ｘ＋ｙ<0 

 这种情况和第2种情况一样,把ｘ和ｙ的位置对调即得证。 

(4)ｘ<0,ｙ<0,则ｘ＋ｙ<0 

　相加两数都是负数,则其和也一定是负数。

　∵[ｘ]补＝2n+1＋ｘ,　　　[ｙ]补＝2n+1＋ｙ

　∴[ｘ]补＋[ｙ]补＝2n+1＋ｘ＋2n+1＋ｙ

			 ＝2n+1＋(2n+1＋ｘ＋ｙ)= [ｘ＋ｙ]补

　　在模2n+1意义下,任意两数的补码之和等于该两数之和的补码。 

[例11] 设字长5位,ｘ＝+1001,ｙ＝+0101, 用补码求ｘ＋ｙ

[解:] [ｘ]补＝01001, [ｙ]补＝00101



 [ｘ]补　　　01001

 	 ＋[ｙ]补　　　00101　

 [ｘ＋ｙ]补　　01110　 



所以ｘ＋ｙ＝＋1110 



[例11] 设字长6位,ｘ＝+1001,ｙ＝+0101, 用补码求ｘ＋ｙ

[解:] [ｘ]补＝001001, [ｙ]补＝000101



 [ｘ]补　　　001001

 	 ＋[ｙ]补　　　000101　

 [ｘ＋ｙ]补　　001110　 



所以ｘ＋ｙ＝＋1110 



[例12]设字长5位,ｘ＝＋1011,ｙ＝－0101, 用补码求ｘ＋ｙ。

[解:][ｘ]补＝01011,　　[ｙ]补＝11011 



[ｘ]补　　　01011

＋[ｙ]补　　　11011　

 [ｘ＋ｙ]补　 100110　

 

 所以　ｘ＋ｙ＝+0110 

　　补码加法的特点，

一是符号位要作为数的一部分参加运算

二是符号位的进位要丢掉 

2024/6/5

8

2.2.2 补码减法

数用补码表示时，减法运算的公式为

[ｘ－ｙ]补＝[ｘ]补－[ｙ]补

 ＝[ｘ]补＋[-ｙ]补

只要证明[－ｙ]补＝－[ｙ]补,上式即得证。



现证明如下：

　∵　[ｘ＋ｙ]补＝[ｘ]补＋[ｙ]补　　　(模 2n+1)

　∴　[ｙ]补　＝[ｘ＋ｙ]补－[ｘ]补　　　(2.15)

又∵　[ｘ－ｙ]补＝[ｘ＋(－ｙ)]补＝[ｘ]补＋[－ｙ]补

　∴　[－ｙ]补 ＝[ｘ－ｙ]补－[ｘ]补　 (2.16)

将式(2.15)与(2.16)相加,得

[－ｙ]补＋[ｙ]补＝[ｘ＋ｙ]补＋[ｘ－ｙ]补－[ｘ]补－[ｘ]补

　　　　　　＝[ｘ＋ｙ＋ｘ－ｙ]补－[ｘ]补－[ｘ]补

　　　　　　＝[ｘ＋ｘ]补－[ｘ]补－[ｘ]补＝0

　故[－ｙ]补＝－[ｙ]补(模 2n+1)

从[ｙ]补求[－ｙ]补的法则：对[ｙ]补包括符号位“按位求反且加1”，即可得到[－ｙ]补。

写成运算表达式，则为

　　其中符号﹁表示对[ｙ]补作包括符号位在内的求反操作

[例13] 设字长5位，已知ｘ1＝－1110,ｘ2＝＋1101,

 求：[ｘ1]补,[－ｘ1]补,[ｘ2]补,[－ｘ2]补。

[解:]

　　　[ｘ1]补 ＝ 10010

　[－ｘ1]补 ＝ ﹁[ｘ1]补＋1

 ＝ 01101＋00001＝01110



　　　[ｘ2]补 ＝ 01101

　　[－ｘ2]补 ＝ ﹁[ｘ2]补＋1

 ＝ 10010＋00001＝10011



[例14] 设字长5位，ｘ＝＋1101,ｙ＝＋0110,求ｘ－ｙ。

[解:]

　　　　[ｘ]补＝01101

　　　　[ｙ]补＝00110　

[－ｙ]补＝11010

[ｘ]补　　　 　01101

＋[－ｙ]补　　 　11010　

 [ｘ－ｙ]补 　 100111



所以　ｘ－ｙ＝＋0111



[练习]设字长5位，ｘ＝-1001,ｙ＝-0110,求ｘ－ｙ。

[解:]

　　　　[ｘ]补＝10111

　　　　[ｙ]补＝11010　

[－ｙ]补＝00110

[ｘ]补　　　 　10111

＋[－ｙ]补　　 　00110　

 [ｘ－ｙ]补 　11101



所以　ｘ－ｙ＝-0011



[例15] ｘ＝＋1011,ｙ＝＋1001,求ｘ＋ｙ。

[解:]　　　[ｘ]补＝01011 [ｙ]补＝01001

[ｘ]补　　　01011

 ＋ [ｙ]补　　　01001 

[ｘ＋ｙ]补　　10100 

两个正数相加的结果成为负数,这显然是错误的。

[例16] ｘ＝－1101,ｙ＝－1011,求ｘ＋ｙ。

[解:]　　　[ｘ]补＝10011 [ｙ]补＝10101

[ｘ]补　　10011

＋　 [ｙ]补　　　10101 

 [ｘ＋ｙ]补　　01000

两个负数相加的结果成为正数,这同样是错误的。

2.2.3 溢出的概念与检测方法

2024/6/5

15

2.2.3 溢出的概念与检测方法

溢出的检测方法

单符号位法和双符号位法

双符号位法：用两个符号位表示一个数据，也称为“变形补码”

两个符号位一样参与运算

最高符号位产生的进位要丢弃

2024/6/5

16

2024/6/5

17

2.2.3 溢出的概念与检测方法

用双符号位法检测溢出



结果的两个符号位一致则没有溢出

如果两个符号位不一致则发生溢出

判断溢出的逻辑表达式为V=Sf1 ⊕ Sf2,可以用异或门来实现

2024/6/5

18

2.2.3 溢出的概念与检测方法

二、检验举例：

ｘ＝＋1100, ｙ＝＋1000,求ｘ＋ｙ 

ｘ＝－1100, ｙ＝－1000,求ｘ＋ｙ 

结果出现了01或10的情况就为溢出



[例] 设字长5位ｘ＝＋1100,ｙ＝＋1000,求ｘ+ｙ。

[解:]

　　　　[ｘ]补＝001101

　　　　[ｙ]补＝001000　

[ｘ]补　　　 　001101

＋[ｙ]补　　 　001000　

 [ｘ+ｙ]补 　010101



结果两个符号不同，表示溢出



2024/6/5

20

2.2.3 溢出的概念与检测方法

2、单符号位法

其中Cf为符号位产生的进位,C0为最高有效位产生

溢出检测V=Cf ⊕ C0 

2.2.4 基本的二进制加法/减法器

2024/6/5

21

 [X]补＝Xn Xn-1………X0

 [Y]补＝Yn Yn-1…….…Y0



+

?n ? n-1…….…?0

多位加法运算依赖于各位逐位相加的运算，

所以先讨论一位全加器

2.2.4 基本的二进制加法/减法器

半加器

两个二进制位相加



2024/6/5

22

Si＝Ai⊕Bi

Ci+1＝AiBi

全加器的真值表与表达式

23

Si ＝Ai⊕Bi⊕Ci

Ci＋1＝ AiBi＋BiCi＋CiAi

= AiBi ＋(Ai⊕Bi) Ci



输入: 加数Ai 、Bi、低位进位输入Ci

输出: 和Si ，进位输出Ci+1

2024/6/5

24

FA逻辑电路和框图



FA（全加器）逻辑电路图

延迟分析：

设异或门延迟为3T，与非门延迟为T

对一位全加器(FA)来说，Si的时间延迟为6T，Ci＋1的时间延迟为5T。

FA框图

4位补码加法器

2024/6/5

25

FA

FA

FA

FA

B0

B1

B2

B3

A0

A1

A2

A3

C0=0

S0

C1

S1

S2

S3

C2

C3

C4

溢出

符 号 位

单符号法检测溢出

只能完成补码加法

加法器的改造

2024/6/5

26

FA

FA

FA

FA

A3

M

S0

C1

S1

S2

S3

C2

C3

C4

溢出

符 号 位

B3

A2

B2

A1

B1

A0

B0

能完成补码加法和补码减法

[ｘ]补＋[ｙ]补＝[ｘ＋ｙ]补

[ｘ]补＋[-ｙ]补＝[ｘ-ｙ]补

4位补码加法器

2024/6/5

27

进位依次从地位传递高位，称为行波进位

当M＝0，加法[A]补＋[B]补运算；

当M＝1，减法[A]补- [B]补转化成[A]补＋[－B]补运算，异或。

4位补码加法器

2024/6/5

28

延迟分析：

找出时延最长的路径

B0->C1为3T+3T+2T=8T

C1->C2为10T

C2->C3为12T

C3->C4为14T

溢出为17T

2024/6/5

29

n位行波进位补码加法器

总延迟：从C0到溢出产生的延迟为(2n+9)T

8T(B0->C1)+2(n-1)T(C1->Cn)+3T(溢出)

	=(8+2n-2+3)T=(2n+9)T

加法器是算术运算电路的核心

所有算术运算都基于加法器实现

加法器不区分符号数与无符号数



2024/6/5

30


2.3定点乘法运算

采用软件实现乘法运算

利用加法运算指令，编写实现乘法的循环子程序

所需的硬件最少，但速度最慢

采用硬件实现乘法运算

串行乘法器

被乘数每次和一位乘数相乘

并行乘法器

被乘数同时和乘数所有二进制位相乘

硬件乘法器，需要乘法指令



1



硬件增加新的功能需要提供必要的指令

2



当前CPU支持的新指令

2.3.1原码并行乘法



3

1. 人工算法步骤



4



设ｘ＝1101,ｙ＝1011

　　　　　　　1101(ｘ) 　×　　　1011　(ｙ)

　　　　　1　1　0　1 

　　　 1　1　0　1

 0　0　0　0

＋ 1　1　0　1　 　

　　1　0　0　0　1　1　1　1　(ｚ)



1. 人工算法步骤



5



设ｘ＝1101,ｙ＝1011

　　　　　　　1101(ｘ) 　×　　　1011　(ｙ)

　　　　　1　1　0　1

　　　 1　1　0　1

 0　0　0　0

＋ 1　1　0　1　 　

　　1　0　0　0　1　1　1　1　(ｚ)



求部分积：从乘数 y 的最低位开始

逐位与被乘数相乘（与运算）

根据权重移位：每个部分积根据乘数的权相应左移

部分积相加：部分积统统加起来得到乘积z（z的位数扩大一倍）。

1. 人工算法步骤

求部分积：从乘数 y 的最低位开始

逐位与被乘数相乘（与运算）

根据权重移位：每个部分积根据乘数的权相应左移

部分积相加：将移位后的部分积统统加起来便得到最后乘积z（z的位数扩大一倍）。



6

计算机乘法的困难

两大困难

其一：两个n位数相乘，乘积为2n位。部分积、乘积如何存储?

其二：只有两个操作数相加的加法器如何将n个部分积相加？

设计高速并行乘法器的基本问题

就在于缩短部分积的加法时间

7



a4

a3

a2

a1

a0



两个5位的二进制无符号数相乘

乘数a和被乘数b都为5位，

乘积P为10位

阵列乘法器

b0

b1

b2

b3

b4

×

8



a3b2

a2b2

a1b2

a0b2

a4b2

a3b3

a2b3

a1b3

a0b3

a4b3

a4b0

a3b0

a2b0

a1b0

a0b0

a4b1



a3b4

a2b4

a0b4

a4b4

a1b4



两个5位的二进制无符号数相乘

乘数a和被乘数b都为5位，

乘积P为10位

生成所有部分积

9

 p1

p0



a3b2

a2b2

a1b2

a0b2

a4b2

a3b3

a2b3

a1b3

a0b3

a4b3

a4b0

a3b0

a2b0

a1b0

a0b0

a4b1



a3b4

a2b4

a0b4

a4b4

a1b4



表示全加器

斜线表示进位，竖线表示和

10

 p2

 p1

p0



a3b2

a2b2

a1b2

a0b2

a4b2

a3b3

a2b3

a1b3

a0b3

a4b3

a4b0

a3b0

a2b0

a1b0

a0b0

a4b1



a3b4

a2b4

a0b4

a4b4

a1b4



表示全加器

斜线表示进位，竖线表示和



11

 p2

 p1

p0



a3b2

a2b2

a1b2

a0b2

a4b2

a3b3

a2b3

a1b3

a0b3

a4b3

a4b0

a3b0

a2b0

a1b0

a0b0

a4b1



p3

a3b4

a2b4

a0b4

a4b4

a1b4



表示全加器

斜线表示进位，竖线表示和



12

 p2

 p1

p0



a3b2

a2b2

a1b2

a0b2

a4b2

a3b3

a2b3

a1b3

a0b3

a4b3

a4b0

a3b0

a2b0

a1b0

a0b0

a4b1



p3

p4

a3b4

a2b4

a0b4

a4b4

a1b4



表示全加器

斜线表示进位，竖线表示和



13

 p2

 p1

p0



a3b2

a2b2

a1b2

a0b2

a4b2

a3b3

a2b3

a1b3

a0b3

a4b3

a4b0

a3b0

a2b0

a1b0

a0b0

a4b1



p3

p4

p5

a3b4

a2b4

a0b4

a4b4

a1b4



表示全加器

斜线表示进位，竖线表示和



0



14

 p2

 p1

p0



a3b2

a2b2

a1b2

a0b2

a4b2

a3b3

a2b3

a1b3

a0b3

a4b3

a4b0

a3b0

a2b0

a1b0

a0b0

a4b1

p6



p3

p4

p5

a3b4

a2b4

a0b4

a4b4

a1b4



表示全加器

斜线表示进位，竖线表示和



0



15

 p2

 p1

p0



a3b2

a2b2

a1b2

a0b2

a4b2

a3b3

a2b3

a1b3

a0b3

a4b3

a4b0

a3b0

a2b0

a1b0

a0b0

a4b1

p6



 p7

p3

p4

p5

a3b4

a2b4

a0b4

a4b4

a1b4



表示全加器

斜线表示进位，竖线表示和



0



16

p8

 p2

 p1

p0



a3b2

a2b2

a1b2

a0b2

a4b2

a3b3

a2b3

a1b3

a0b3

a4b3

a4b0

a3b0

a2b0

a1b0

a0b0

a4b1

p6



 p7

p3

p4

p5

p9

a3b4

a2b4

a0b4

a4b4

a1b4



表示全加器

斜线表示进位，竖线表示和



0



17



p8

 p2

 p1

p0



a3b2

a2b2

a1b2

a0b2

a4b2

a3b3

a2b3

a1b3

a0b3

a4b3

a4b0

a3b0

a2b0

a1b0

a0b0

a4b1

p6



 p7

p3



p4

p5

p9

0

a3b4

a2b4

a0b4

a4b4

a1b4



4*5个全加器

斜线表示进位，竖线表示和



表示全加器



进位保留加法器

行波进位加法器

18



19

2、不带符号的阵列乘法器



不带符号阵列乘法器逻辑图

2、不带符号的阵列乘法器

20

3、带符号的阵列乘法器

对于补码表示的乘数和被乘数在使用阵列乘法器前，需先将补码转换为原码

求补电路

21

E=1，求补

E=0，直通输出

求补电路

22

3、带符号的阵列乘法器

求补器与原码阵列乘法器结合组成带符号的阵列乘法器

共使用三个求补器。

两个算前求补器：将操作数A和B变成正整数。

算后求补器：输出结果的补码。



23



24

3、带符号的阵列乘法器 



原码／补码

2.4 定点除法运算



25



26



0.

1

1

0

1

商q

2.4.1 原码除法运算原理

设被除数ｘ＝0.1001，除数ｙ＝0.1011，模仿十进制除法运算，以手算方法求ｘ÷ｙ的过程如下：　　　

 

　　　

 　

1 0 1 11 0 0 1 　 r0　被除数小于除数，不够减，商0

 －1 0 1 1　　 被除数低位补零，够减除数,商1

　　 1 1 1 　　　r1　　　得余数r1低位补零

　 －1 0 1 1　　 　够减除数,商1

　　　 1 1 　　r2　　　得余数r2低位补零

　　　 1 0 1 1　　 不够减除数,商0

　　　 1 1 0　r3　　　余数r3低位补零

　－ 1 0 1 1　 够减除数,商1

　　　 1　r4　　　得余数r4 



27



0.

1

1

0

1

商q

2.4.1 原码除法运算原理

设被除数ｘ＝0.1001，除数ｙ＝0.1011，模仿十进制除法运算，以手算方法求ｘ÷ｙ的过程如下：　　　

0

0

0

0

2.4.1 原码除法运算原理

二进制除法实质:“被除数（余数）减除数，求新余数”

人工算法：

求商时从高位向低位逐位求，商符单独处理 

每次上商都是由心算来比较余数和除数的大小，确定商1还是0

每做一次减法，总是保持余数不动，低位补0，再减去右移后的除数。

重复上一步骤，直到余数为0，或商的位数满足要求



28

2.4.1 原码除法运算原理



29

2.4.1 原码除法运算原理

补充：编码的移位

机器数为正时，不论左移或右移，添补代码均为0。

负数原码在移位时符号位不变，其空位均添0。

负数反码在移位时符号位不变，其空位均添1。 

负数补码在移位时，符号位不变，左移添0，右移添1.

30

补充：编码的移位

实例：A=-26，用8位二进制表示，写出三种机器数左移一位、右移一位、左移两位和右移两位后的表示形式及其真值。



10110100

10001101

11101000

10000110

11001011

11110010

10010111

11111001

11001100

11110011

10011000

11111001

-52

-13

-104

-6

-52

-13

-104

-6

-52

-13

-104

-7

31

[例23] ｘ＝0.101001, ｙ＝0.111, 求ｘ÷ｙ。（恢复余数法计算）

[解:]　　[ｙ]补＝0.111[-ｙ]补＝1.001

　　　　　　　　被除数ｘ　0.1 0 1 0 0 1　　　　　　　　　　减ｙ　1.0 0 1　               　

　　　　　　　　余数为负　1.1 1 0 0 0 1＜0　　　q4＝0

不够减，恢复余数加ｙ　0.1 1 1　

0.1 0 1 0 0 1

 　　　　y右移1位 减　1.1 0 0 1　 　     　　 

　　　　　　　　余数为正　0.0 0 1 1 0 1＞0　 　 q3＝1

　　　　　　右移2位减　1.1 1 0 0 1　     　　　 

　　　　　　　　余数为负　1.1 1 1 1 1 1＜0　　q2＝0

不够减，恢复余数加ｙ　0.0 0 1 1 1

0.0 0 1 1 0 1

　　　　　　ｙ右移3位减　1.1 1 1 0 0 1 　　　     　 

　　　　　　　　余数为正　0.0 0 0 1 1 0　＞0 　 　q1＝1

故得　　　　 　商 q ＝ q4.q3q2q1 ＝ 0.101　　　



32

2.4.1 原码除法运算原理

33

恢复余数法

34

不恢复余数法（加减交替法）

35

36

Y

N

结束

Y

N

Y

N



37



38

2、不恢复余数的除法


2024/6/5

1

2.5定点运算器的组成

2.5.1逻辑运算

2.5.2多功能算术/逻辑运算单元ALU

2.5.3内部总线

2.5.4定点运算器的基本结构

2024/6/5

2

2.5.1 逻辑运算

计算机中的逻辑运算，主要是指逻辑非、逻辑加、逻辑乘、逻辑异或四种基本运算。

非运算：按位反

逻辑加：按位或

逻辑乘：按位与

异或运算：又称“按位加”

移位运算

左移n位等于乘2n

右移n位等于除2n

移位和加法结合，实现乘（除）运算

有符号数的移位称算术移位

空出位补0或1

无符号数的移位称逻辑移位

空出位补0

移位运算-算术移位

有符号数的移位叫算术移位 

机器数为正时，不论左移或右移，添补代码均为0。

负数原码在移位时符号位不变，其空位均添0。

负数反码在移位时符号位不变，其空位均添1。 

负数补码在移位时，符号位不变，左移添0，右移添1.

补充：编码的移位

实例：A=-26，用8位二进制表示，写出三种机器数左移一位、右移一位、左移两位和右移两位后的表示形式及其真值。



10110100

10001101

11101000

10000110

11001011

11110010

10010111

11111001

11001100

11110011

10011000

11111001

-52

-13

-104

-6

-52

-13

-104

-6

-52

-13

-104

-7

2024/6/5

6

2.5.2多功能算术/逻辑运算单元ALU

由全加器构成的加法器，可以实现补码的加法/减法运算。问题：

由于串行进位它的运算时间很长

不能完成逻辑运算

以加法器为核心的算术/逻辑运算单元(ALU- Arithmetic Logic Unit)

具有算术和逻辑运算的功能

先行进位逻辑，能实现高速加法运算

2024/6/5

7

2.5.2多功能算术/逻辑运算单元ALU

改变FA的输入端Ai和Bi来实现算术运算和逻辑运算功能。

一位全加器FA



将Ai和Bi输入一个函数发生器得到输出Xi和Yi，作为一位全加器的输入。

2024/6/5

8

1位ALU的逻辑图与逻辑表达式

控制参数

2024/6/5

9

2.5.2多功能算术/逻辑运算单元ALU

可以处理16种算术\逻辑运算，

每种运算只针对1位二进制

10

2.5.2多功能算术/逻辑运算单元ALU

进一步化简得到下式

代入全加器的求和与进位表达式，可得如下逻辑表达式

2.5.2多功能算术/逻辑运算单元ALU

2024/6/5

11

2.5.2多功能算术/逻辑运算单元ALU

2024/6/5

12

2024/6/5

13

2.5.2多功能算术/逻辑运算单元ALU

4位ALU:4个1位ALU串行连接



能进行4位算术和逻辑运算

进位信号太慢

2024/6/5

14

2.5.2多功能算术/逻辑运算单元ALU



  串行进位，速度慢

Cn＋1

Cn＋2

Cn＋3

Cn＋4

15

对串行进位的改进

串行改并行



先行进位

（CLA- Carry Look Ahead ）

2.5.2多功能算术/逻辑运算单元ALU

Cn＋4＝Y3＋Y2X3＋Y1X2X3＋Y0X1X2X3＋X0X1X2X3Cn

令G＝Y3＋Y2X3＋Y1X2X3＋Y0X1X2X3P＝X0X1X2X3

G(Generation)为进位发生函数

P(Propagation)为进位传递函数

增加P和G的目的在于实现多片ALU之间的先行进位

Cn＋4＝G＋PCn

16

逻辑电路图

2024/6/5

17

G＝Y3＋Y2X3＋Y1X2X3＋Y0X1X2X3P＝X0X1X2X3

2024/6/5

18

74181 4位ALU逻辑图



函数发生器



先行进位



运算方式

控制



A=B？

2024/6/5

19

74181功能

20

2.5.2多功能算术/逻辑运算单元ALU

4片74181组成16位ALU



片内先行进位，片间串行进位



21

2.5.2多功能算术/逻辑运算单元ALU

4片74181组成16位ALU



C4=G0+P0C0C8=G1+P1C4

 C12=G2+P2C8 C16=G3+P3C12



Cn＋ｘ＝G0＋P0Cn

Cn＋ｙ＝G1＋P1Cn＋ｘ＝G1＋G0P1＋P0P1Cn

Cn＋ｚ＝G2＋P2Cn＋ｙ＝G2＋G1P2＋G0P1P2＋P0P1P2Cn

Cn＋4 ＝G3＋P3Cn＋ｚ

＝G3＋G2P3＋G1P1P2＋G0P1P2P3＋P0P1P2P3Cn

＝G*＋P*Cn

P*＝P0P1P2P3

G*＝G3＋G2P3＋G1P1P2＋G0P1P2P3 

根据以上表达式实现的部件称为74182（组间先行进位产生器），与4个74181配合使用

74182的逻辑电路图　

23

2024/6/5

24

16位先行进位ALU



片内先行进位，片间先行进位



2024/6/5

25

32位ALU 

2片741828片74181



64位先行进位系统

 16片74181 ，5片74182芯片组成多级先行进位



2.5.3 内部总线

将计算机各个部件之间的数据传送通路加以归并，组成总线结构

任何一个时刻，总线上只能有一个来源的数据，数据源独占总线

不同来源的信息在总线上分时传送

只要数据源不撤销数据，该数据在总线上一直存在

根据所在位置分类：

内部总线：CPU内各部件的连线

外部总线：CPU与存储器、I/O系统之间的连线

2024/6/5

27

2.5.3 内部总线

按总线的逻辑结构分：

单向总线：信息只能向一个方向传送。

传送地址信息或控制信息的总线

双向总线：信息可以两个方向传送

数据总线既可以发送数据，也可以接收数据。

总线的基本电路是三态门

逻辑1、逻辑0、高阻



2024/6/5

28

29

2.5.4 定点运算器的基本结构

基本组成包括：

ALU：核心部件

乘除法器，组合逻辑电路

数据存储部件：存放参与计算的数据及运算结果

暂存器：只对硬件设计者可见

通用寄存器：可以被软件设计者所访问 

内部总线：连接各个部件的通道 

30

2.5.4 定点运算器的基本结构

一个二元运算需要两个操作数，产生一个结果

操作数 op 操作数 = 操作结果

按照数据从存储部件传输到ALU的方式将ALU分为三种结构

单总线，双总线，三总线



1、单总线结构的运算器

两个操作数要分两次输入到ALU

需要A、B两个暂存器临时保存操作数

操作速度慢、控制简单

2024/6/5

31

一次运算要三步完成：

通用寄存器->A

通用寄存器->B

A+B,ALU->通用寄存器

2、双总线结构的运算器

两个操作数通过两条总线同时输入到ALU进行运算

ALU的输出经过缓冲器送入通用寄存器

因为ALU的输入数据没有暂存器，计算过程中，两条总线都被输入数据占据，必须在ALU输出端设置缓冲器。

2024/6/5

32

一次运算要两步完成：

通用寄存器->总线1 ，通用寄存器->总线2， 总线1+总线2>缓冲器

缓冲器->通用寄存器

3、三总线结构的运算器

总线旁路器：总线之间的数据传送

一次运算一步完成：

通用寄存器->总线1 ，通用寄存器->总线2， 总线1+总线2>总线3，总线3->通用寄存器

速度快，硬件复杂，成本高

33

Intel 8086运算器结构

34

通用寄存器

暂存器

标志寄存器

16位ALU

单总线结构

ARM的ALU

35

三总线结构

通用寄存器

Intel pentuim的ALU



36

三总线结构

通用寄存器

CPU和GPU

37

GPU中有海量的ALU，因而其计算能力很强大

GPU的ALU



38

GTX 1080的核心GP104 

每个SM 有128个 CUDA内核（绿色方块）

CUDA内部

39




2024/6/5

1

2.6浮点运算方法和浮点运算器

2.6.1 浮点加法、减法运算

2.6.2 浮点乘法、除法运算

2.6.3 浮点运算流水线

2.6.4 浮点运算器实例



2.6.1 浮点加法、减法运算

2

2024/6/5

3

2.6.1 浮点加法、减法运算

浮点加减运算步骤如下：

1. 0操作数检查；

2. 比较阶码大小并完成对阶；

3. 尾数求和/差运算；

4. 结果规格化

5. 舍入处理

6. 溢出处理



2024/6/5

4

2.6.1 浮点加法、减法运算

0 操作数检查

能否简化操作、节省运算时间

比较阶码大小并完成对阶

对阶：使得小数部分可以按位权值相加

变为定点数

定点加法器运算

小数点位置是否对齐

对阶:小阶向大阶看齐

2.6.1 浮点加法、减法运算

两个浮点数相加：

1.11011×23 1.11011×25

浮点格式中，尾数为定点小数

如果向小阶对齐，尾数左移

易导致高位数据丢失

如果向大阶对齐，尾数右移

丢失的是低位数据

5

2024/6/5

6

2.6.1 浮点加法、减法运算

2024/6/5

7

2.6.1 浮点加法、减法运算

2024/6/5

8

IEEE 754的四种舍入方法

就近舍入：类似于四舍五入，

多余位：最低有效位之后的若干位，用于舍入判断

多余位中间值位： 100…0

多余位比100…0大，进位；比100…0小，舍去

对于100……0的情况：

有效位末尾是1：进1

有效位末尾是0：舍弃

例：保留有效位到0.001

 0.10111-0.00101

 0.11110-0.01010

IEEE754的四种舍入方法

朝0舍入：截尾

保留有效位到0.001：

 0.10111-0.00101

 0.11110-0.01010



9

2024/6/5

10

IEEE754的四种舍入方法

IEEE754的四种舍入方法

11

M＝10011001100110011001100110011

例题：真值0.2，求32位单精度浮点数

② 移动小数点，使其在第1、2位之间

S＝0

e＝-3，E＝-3+127＝124＝01111100

③ 得到32位浮点数的二进制存储格式为：

0011 1110 0100 1100 1100 1100 1100 1101

＝(3E4CCCCD)16



23位

就近舍入



2024/6/5

13

2.6.1 浮点加法、减法运算

真值0的机器数（机器零）

阶码E＝0，尾数M＝0

正0：S＝0，负0：S＝1

非规格化浮点数：阶码E＝0，尾数M≠0

规格化浮点数：阶码E＝1～254（11111110）

无穷大的机器数

阶码E＝全1（11111111） ，尾数M＝0

＋∞：S＝0，－∞：S＝1

NaN（not a number，不是一个数）

阶码E＝全1（11111111） ，尾数M≠0

用来通知异常情况

IEEE 754标准

32位单精度浮点数



2024/6/5

15

2.6.1 浮点加法、减法运算

2.6.2 浮点乘法、除法运算 

22

2.6.2 浮点乘法、除法运算 　

23

2.浮点乘、除法运算步骤

浮点数的乘除运算大体分为六步：

　　 ①0 操作数检查；

②阶码加/减操作；

③尾数乘/除操作；

④结果规格化；

⑤舍入处理；

⑥确定积的符号；

2.6.2 浮点乘法、除法运算 　

(1) 浮点数的阶码运算

乘法：两阶码求和，减偏移量

除法：两阶码求差，加偏移量

(2)尾数处理

规格化与舍入

与浮点加减法相同

24

现代处理中的浮点运算单元

浮点运算单元FPU，floating-point Unit

27

华为海思麒麟990

4个ALU、2个FPU

ARM A77中的FPU

28

RISC-V中的FPU

用于物联网的一种处理器架构

平头哥玄铁910

3个ALU、1个FPU

29

龙芯3A4000

30

FP32浮点性能比较

31

以 CNN 为例，用于输入图像大小为224× 224 的分类任务的典型 CNN 模型需要高达 390 亿次(39G)FLOP和500 MB 以上的模型参数。 

第二章小结

一个定点有符号数由符号位和数值域两部分组成。按小数点位置不同，定点数有纯小数和纯整数两种表示方法。

按 IEEE754 标准，一个单精度浮点数由符号位S、阶码E、尾数M三个域组成。阶码E等于指数的真值e加上固定偏移值127

32

第二章小结

数的真值变成机器码时四种表示方法：原码，反码、补码和移码

移码主要用于表示浮点数的阶码

字符信息属于符号数据，国际上采用的字符系统是7位的ASCII码。

汉字有输入码、汉字内码和输出码三种不同用途的编码。

为运算器构造的简单性，运算方法中算术运算通常采用补码加、减法，原码乘除法。

33

第2章教学要求-1

掌握定点整数（有符号数和无符号数）的表示范围

掌握IEEE754 单精度浮点格式的表示，规格化，与真值的相互转换

理解真值和机器数，掌握定点整数的补码、反码、原码，理解移码表示法

了解汉字输入编码、机内码、输出码

理解检验码的作用，掌握奇偶校验

第2章教学要求-2

掌握补码加减法运算

掌握溢出的概念及检测方法

理解运算器的三种组成方式

掌握浮点加减法运算步骤

理解IEEE754标准的4种舍入处理方法，掌握就近舍入


C语言数据表示

非数值数据 char(8位)

数值数据

定点整数 

signed / unsigned

char(8位)/short（16位）/int（32位）/long（64位） 

浮点数

Float（32位）/double（64位）



 -1- 

C语言中的整数（定点数）

无符号整数

unsigned char/unsigned short/unsigned int 

一般用于地址运算

有符号整数

char/short/int/long

采用补码表示

无符号整数/带符号整数的最大值

8位无符号整数最大是255（1111 1111）

8位带符号整数最大为+127（0111 1111）



 -2- 

编程实践

在线编程网站

https://c.runoob.com/compile/9

c、c++、python等

https://gcc.godbolt.org/

离线

python：anaconda

c：ubuntu、gcc

数据的真值、机器码、存储值间的关系

3

C语言中的机器码？ ex2_1.c

 -4- 

int main()

{

char a=127,b=128,c=129,d=257; 

printf("%d\n",a);

printf("%d\n",b);

printf("%d\n",c);

printf("%d\n",d);

}

127

-127

-128

？？？？

无符号数赋值

补码真值输出

变量a,b,c,d机器码实际存储值是多少？

1

变量的内存值 ex2_2.c 

 -5- 

main()

{

char a=127,b=128,c=129,d=257; 

printf("a = %d =%X\n",a,a);

printf("b = %d =%X\n",b,b);

printf("c = %d =%X\n",c,c);

printf("d = %d =%X\n",d,d);

}

a = 127 = 7F

b = -128 = FFFFFF80

c = -127 = FFFFFF81

d = 1 = 1

补码输出

机器码输出

32位补码表示范围

[-231，231-1]

 -6- 

0000 0000 0000 0000 0000 0000 0000 0000two = 0100000 0000 0000 0000 0000 0000 0000 0001two = + 1100000 0000 0000 0000 0000 0000 0000 0010two = + 210...0111 1111 1111 1111 1111 1111 1111 1110two = + 2,147,483,646ten0111 1111 1111 1111 1111 1111 1111 1111two = + 2,147,483,647ten1000 0000 0000 0000 0000 0000 0000 0000two = – 2,147,483,648ten1000 0000 0000 0000 0000 0000 0000 0001two = – 2,147,483,647ten1000 0000 0000 0000 0000 0000 0000 0010two = – 2,147,483,646ten...1111 1111 1111 1111 1111 1111 1111 1101two = – 3ten1111 1111 1111 1111 1111 1111 1111 1110two = – 2ten1111 1111 1111 1111 1111 1111 1111 1111two = – 1ten	

程序 ex2_3.c

 -7- 

main()

{

int x=-1;

unsigned u = 2147483648;

printf ("x = %u = %X = %d\n",x,x,x);

printf ("u = %u = %X = %d\n",u,u,u);

}

机器码输出

真值赋值

 x = 4294967295 = FFFFFFFF = -1

 u = 2147483648 = 80000000 = -2147483648

无符号数输出

一个奇怪的程序ex2_4.c

8

main()

{

	double a,b,c; 

	int d;

	b = 3.3; c = 1.1;

	a = b/c;

	d = b/c;

	printf("%f,%d\n",a,d);

	if (3.0!=a)

 		printf("Really? 3.0!=a\n");

}

3.000000,2

??????????

Really?3.0!=a

二进制存储

浮点数不是精确数

浮点转整数只保留浮点数的整数部分

Double 3.3/1.1 ex2_5.c

main()

{

double a,b,c;

b = 3.3; c = 1.1;

a = b/c;

printf("a = %.60f \n",a);

printf("b = %.60f \n",b);

printf("c = %.60f \n",c);

printf("a = %f,n",a);

}

 -9- 

a = 2.999999999999999555910790149937383830547332763671875000000000

b = 3.299999999999999822364316059974953532218933105468750000000000

c = 1.100000000000000088817841970012523233890533447265625000000000 

a = 3.000000 

一个奇怪的程序 ex2_6.c

10

main()

{

float a,b,c; 

int d;

b = 3.3; c = 1.1;

a = b/c;

d = b/c;

printf("%f,%d\n",a,d);

if (3.0!=a)

printf("Yeah!\n");

}

3.000000,3

Float 3.3/1.1 ex2_7.c

main()

{

float a,b,c;

b=3.3; c=1.1;

a=b/c;

printf(" = %.60f \n",a);

printf("b = %.60f \n",b);

printf("c = %.60f \n",c);

}

 -11- 

a = 3.000000000000000000000000000000000000000000000000000000000000

b = 3.299999952316284179687500000000000000000000000000000000000000

c = 1.100000023841857910156250000000000000000000000000000000000000

a = 3.000000

舍入的影响

例题

假定变量i、f和d的数据类型分别为int、float和double（int用补码表示，float和double分别用IEEE 754单精度和双精度浮点数格式表示），已知i=785，f=1.5678e3，d=1.5e100。若在32位机器中执行下列关系表达式，则结果为“真”的是I．i == (int)(float)i     II．f == (float)(int)fIII．f == (float)(double) f    IV．(d+f)-d == fA．仅I和II 			B．仅I和III

C．仅II和III 		D．仅III和IV 

解答

float到double的转换完全相等

double到float转换可能会发生舍入

float/double到int，小数部分会丢弃

int到float，当int有效数字超过24位，转换时需要舍入

int到double，double尾数53位，能精确表示int型

13

I．i == (int)(float)i

float是单精度，尾数24位

int型有效数字有31位

i=785,能实现精确转换，条件成立

若i = 16777217=224-1 

14

II．f == (float)(int)f

f= 1.5678e3

浮点转换整数，只保留整数部分，小数部分舍去

条件不成立

15

III．f == (float)(double) f

双精度尾数53位

f = 1.5678e3,单精度

float转double有效数字不变,条件成立

若double f = 1.5678e3

f ==(double)(float)f则不成立

16

IV．(d+f)-d == f

浮点运算不满足交换律、结合律

(d+f)-d 不等于 (d-d)+f

(d+f)-d 不等于 d+(f-d)

C语言中单双精度混合运算，都按照双精度处理

大数吃小数，两个差别巨大的浮点数相加，较小的数由于有效数字位数不够，会被舍去



17

浮点处理精度造成的事故

1990年2月25日，海湾战争期间，在沙特的爱国者导弹防御系统未能拦截一枚伊拉克飞毛腿导弹，造成28名美军死亡。

原因是浮点数舍入误差导致

爱国者反导系统的计算机精度仅有24位，存在0.0001%的计时误差，所以有效时间阙值是20个小时。当系统运行100个小时以后，已经积累了0.3422秒的误差。这个误差导致导弹系统不能正确地瞄准目标。



浮点处理精度造成的事故

19

失之毫厘，谬以千里

浮点处理精度问题解决办法

制度：每隔二十小时重启一次

硬件：修改24位为32位或64位

软件：升级软件

20

其他案例

1996年6月4日，在阿丽亚娜五号运载火箭发射后37秒，偏离预定轨道炸毁。原因是软件系统将64位浮点数转换为16位浮点数，造成计算错误。

温哥华证券交易所在1982年推出一项股票指数，指数的值是1000.000。后来，重新计算时多次运用舍入到小数点后三位的操作。22个月以后，指数的值是524.881，然而事实上应该是1009.811

21

浮点处理精度问题

树立计算机系统的思想，理解软硬件的相互影响

小概率事件常会导致大损失，在工程实践中要精益求精

22


1

第三章 多层次存储器

3.1 存储器概述

3.2 SRAM存储器

3.3 DRAM存储器

3.4 只读存储器和闪速存储器

3.5 并行存储器

3.6 Cache存储器

3.7 虚拟存储器

3.8 奔腾系列机的虚存组织



3.1 存储器概述

存储器是计算机系统中的记忆设备，用来存放程序和数据

存储器中最小的存储单位叫存储元，可存储1bit

若干个存储元组成一个存储单元

许多存储单元组成一个存储器

2

3.1.1 存储器的分类

按存储介质

满足两个基本要求：

有两个明显区别的状态，分别表示0和1

两个状态的改变速度要快，影响存储器的读写速度

半导体存储器：内存，闪存

速度快、容量小，成本高

磁表面存储器：磁带、磁盘

容量大，速度慢、成本低

光盘存储器：DVD、蓝光

容量大，速度慢，成本低

按存取方式　　

随机存储器RAM（Random Access Memory）

任何存储单元的内容都能被随机存取，且存取时间和存储单元的物理位置无关

内存

顺序存储器

按顺序存取，存取时间和存储单元的物理位置有关

磁带、磁盘

3

3.1.1 存储器的分类

按信息掉电易失性　

非易失性存储器Non-Volatile Memory

断电后仍能保存信息

磁表面存储器、光盘存储器、闪存

易失性存储器Volatile Memory

断电后信息立即消失

内存(SRAM、DRAM)

半导体存储器按其存储内容可变性

只读存储器(ROM-Read Only Memory)

存储的内容一般是固定不变的，只能读出而不能写入

随机读写存储器(RAM)：

既能读出又能写入



4

3.1.1 存储器的分类

按在计算机系统中的作用 　　

主存储器：和CPU直接交换信息

辅助存储器：主存的后援存储器

高速缓冲存储器Cache：用于两个速度不同的部件之间，起到缓冲作用

控制存储器等

5

3.1.2 存储器的层次结构

CPU对存储器的要求

容量大、速度快、价格低（每位价格）

目前技术下，存储器的特点是：

速度快的存储器价格贵，容量小；

价格低的存储器速度慢，容量大

不可能三角:既要。。。又要。。。。还要。。。。

从在容量，速度和价格作折中考虑，建立存储器层次结构

6

存储系统层次结构



存储速度

访问频率

单位成本



存储容量



外存/辅存

内存

 -7- 

8

3.1.2存储器分级结构

三级存储系统

3.1.3 存储器的编址和端模式

存放一个字节的单元称为字节存储单元，其地址称为字节地址

一个字由多个字节组成，存放一个字的单元称为字存储单元，其地址称为字地址

存储器编址

编址的最小单位是字单元，称为按字编址

编址的最小单位是字节单元，称为按字节编址

既可以按字编址，也可以按字节编址

存储器访问

按地址访问：按字节地址访问、按字地址访问。

9

字的概念

字：word

a word is the natural unit of data used by a particular processor design. 

一串固定长度的二进制数，对应部件处理数据的固定长度。

不同的部件其字长不同

计算机字长、机器字长、运算器字长

存储器字长、存储芯片字长

指令字长



10

存储器的编址

11



字节地址

机器字长32位

16个字节存储单元组成存储器

按字节编址

存储器的编址

12

机器字长32位

16个字节存储单元组成存储器

按字编址

存储器的编址

13



字节地址

机器字长32位，16个字节存储单元

字节编址下按字访问

存储该字的第一个字节的字节单元地址为该字的字地址

存储器的编址

14



字节地址

机器字长16位，

16个字节存储单元

存储器的编址

设有一个1MB容量的存储器，字长32位，问：按字节编址，按字编址各自的寻址范围? 

按字节编址：

20位字节地址，0x0~0xFFFFF

按字编址：

18位字地址，0x0~0x3FFFF

15

数据的存储和排列顺序

上世纪80年代开始，几乎所有计算机都以字节编址

存储系统和指令设计时要考虑的问题（按字节编址，按字访问）：

一个字如何在字节单元存放？

- 字的存放顺序问题(端模式\字节序\端序\尾序)

字地址与字节地址关系

- 字的边界对齐问题



存储器的端模式：存储字为多个字节时，在存储器中存放顺序

大端(big-endian)：大尾端优先存储，高字节在低地址

MIPS，IBM 360/370, Sparc, 网络传输

小端(little-endian)：小尾端优先存储，低字节在低地址。

X86(高高低低)

ARM的端模式可通过寄存器改变

 -16- 

3F

27



LSB



MSB



A8

31

D0

D31

3F

27



LSB



MSB



A8

31

D0

D31

数据在内存中的存放顺序

将0x12345678写入到以0x0000开始的内存中



 -19- 

内存地址对齐

20

内存按字节编址

16位访问对齐

32位访问对齐

字节编址下的按字访问：

以一个字中最低字节的字节地址作为该字的字地址

对齐：

字地址能被字节数整除。

字长为16位，包含2个字节，其字地址能被2整除，地址最低位为0；

字长为32位，包含4个字节，其字地址能被4整除，最低两位为0.

Alignment(对齐)

 -21- 

 如：int i, short k, double x, char c, short j,……

 则：&i=0; &k=4; &x=8; &c=16; &j=18;……

x：2个周期

j：1个周期

目前来看，浪费一点存储空间没有关系！ 

 则： &i=0; &k=4; &x=6; &c=14; &j=15;……

x：3个周期

j：2个周期

存储器按字节编址，CPU按字对齐访问，字长32位

变量地址没有对齐

变量地址对齐

虽节省了空间，但增加了访存次数！

22

#include <stdio.h>

//内存对齐测试

int memory_display(long unsigned int addr)

//以16进制输出 addr开始的16个内存字节单元

{

int i,j;

for(i=0;i<4;i++)

{

printf("0x%lX:\t",addr + i*4);

for(j=0;j<4;j++)

{

printf("0x%X \t ", *(unsigned char*)(addr + i*4 +j));

}

printf("\n");

 }

 return 0;

}

int main()

{

int i = 13457;

short j = 345;

char c='A';

int k=123;



printf("i=0x%X\n",i);

printf("j=0x%X\n",j);

printf("c=0x%X\n",c);

printf("k=0x%X\n",k);

printf("int I memory address is 0x%lX\n",(long unsigned int)&i);

printf("short j memory address is 0x%lX\n",(long unsigned int)&j);

printf("char c memory address is 0x%lX\n",(long unsigned int)&c);

printf("int k memory address is 0x%lX\n",(long unsigned int)&k);

memory_display((long unsigned int)&i-16);

memory_display((long unsigned int)&i);

}

23

内存对齐是一种软硬件协同提高性能的一种方式

3.1.4 主存储器的技术指标

3.2 SRAM存储器

内部存储器是半导体存储器

根据信息存储的机理不同可以分为两类：

静态读写存储器(SRAM- Static)：

速度快、成本高、容量小、功耗低，一般用作Cache

动态读写存储器(DRAM-Dynamic)：

容量大、成本低、速度慢、功耗高、用作主存



25

26

3.2.1 基本的静态存储元阵列

存储位元

SRAM的存储位元是由两个MOS反相器交叉耦合而成的触发器，一个存储位元存储一位二进制代码

六管SRAM存储元的电路结构示意图

3.2.1 基本的静态存储元阵列

三组信号线

地址线

字数

数据线

字长

控制线

27

单译码结构：1个译码器N位地址，寻址2n个存储单元

存储元阵列又称存储芯片

63

芯片容量=字数X字长

=存储单元数量X存储单元字长

3.2.2 基本的SRAM逻辑结构

大容量SRAM芯片采用双译码方式：将地址分成行、列两部分，降低译码电路的规模

CS：Chip Select 片选

3.2.3 读/写周期波形图

先给地址，再给片选和读信号

3.2.3 读/写周期波形图

先给地址，再给片选和是写信号



3.3.1 DRAM存储位元的记忆原理

DRAM存储器的存储位元是由一个MOS晶体管和电容器组成的记忆电路 



31

电容用于存储电荷，有电荷代表1，否则代表0

MOS管

电容器



读放



读出1是破坏性读出

由于(c)中读出1是破坏性读出，必须恢复存储位元中原存的1

输入缓冲器关闭，刷新缓冲器打开，输出缓冲器读放打开，

DOUT=1经刷新缓冲器送到位线上，再经MOS管写到电容上



3.2.2 DRAM芯片的逻辑结构

两个电源Vcc

两个地线脚

一个空管教NC

11个地址线A0~A11

4个数据线D1~D4



36

方法：复用地址线A0-A9

存储器需要地址20位，但芯片物理地址引脚只有11位，如何处理？

1M×4位DRAM芯片的管脚图

37

3.2.2 DRAM芯片的逻辑结构



与SRAM芯片不同之处

增加了行地址锁存器和列地址锁存器

增加了刷新控制电路

DRAM读出后必须刷新，而未读写的存储元也要定期刷新（电容自放电），

按行刷新，刷新计数器的长度等于行地址锁存器

刷新操作与读/写操作交替进行

通过2选1开关来选择刷新行地址或正常读/写的行地址

38

3.3.3 读/写周期、刷新周期

39

先给行地址和行选通，再给列地址和列选通

40

3.3.3 读/写周期、刷新周期

3.3.3 刷新周期

刷新：DRAM存储元基于电容器上的电荷存储信息，电荷量随着时间和温度而减少，因此必须定期地刷新，以保持原来记忆的正确信息

刷新过程：将原有信息读出，再由刷新放大器形成原信息并重新写入的过程

刷新按行进行

刷新周期：从上次对整个存储器刷新结束到下次对整个存储器全部刷新一遍为止的时间间隔称为刷新周期

集中式刷新 

分散式刷新

41

集中刷新方式



例:1024行, 工作周期=500ns, 刷新周期=8ms

8ms内集中安排所有刷新周期

总工作周期数= 8ms/500ns = 16000个

用在实时要求不高的场合

集中式刷新：DRAM的所有行在每一个刷新周期中都被刷新刷新期间停止正常读写

分散刷新方式



各刷新周期分散安排在8ms内

每隔一段时间刷新一行

每隔15.5微秒提一次刷新请求，刷新一行；8毫秒内刷新完所有行

用在大多数计算机中

8ms



1024行

≈7.8 微秒=7800ns

主存储器特点

由半导体存储器组成

存储单元：字存储单元，字节存储单元

编址：按字节编址

按地址进行访问：字节地址访问字，访问字节

属于随机访问存储器RAM

DRAM需要刷新

 -44- 

3.3.5 高级的DRAM结构

FPM DRAM：快速页模式动态存储器

SDRAM同步动态存储器

读写操作与CPU时钟同步,

猝发式读取：输入一个行地址，一个列地址，连续读出后续几个列地址数据



45

输入一个行地址，连续输入多个列地址，该行中的对应列的存储单元数据就连续输出 

DDR SDRAM

DDR：Double Date Rate

DDR在相同时钟频率下的数据传输速率比SDRAM提高一倍

上下沿都传输数据



DDR2、DDR3：时钟频率比上一代提高一倍，速率提高一倍



46



DDR SDRAM



47

全球DRAM产业

三星技术最先进，产量最大

2021 年 10 月开始大规模生产基于 EUV 的 14nm DDR5 

48



49

中国DRAM产业发展

1975年，中国第一块1K DRAM诞生，但总体技术力量薄弱，和国外差距比较大，没有竞争力。

21世纪后，通过政府扶持、自主研发、技术引进、收购等方式逐步建立起国产DRAM产业。

2015年的紫光收购德国奇梦达、收购美国ISSI。

目前，国产DRAM市场的主要厂家紫光国芯、福建晋华、合肥长鑫、长江存储等。

2019年 9 月，合肥长鑫宣布正式量产 DDR4 

2023年预计将试产17nm DDR5,产能大约能占到全球内存产能的 3%，目前最被看好

50

困难和阻力

全球半导体需求将近1/3来自中国

2016年开始，美光开始对福建晋华发起诉讼

2018年10月30日，美国商务部将福建晋华添加进实体清单，导致整个企业进度不理想

2017年，美光曾对从台湾华亚科跳槽到合肥长鑫的上百名员工发存证信函

51

砥砺前行

从DRAM内存的角度来说，中国企业在技术、产业链方面，距离全球顶尖的厂商都有较大的差距，产品自给率方面更是不容乐观。

我们需要进一步加大企业自主创新+国家意志支持的力度，坚定IDM的发展模式，进行产业全链路的布局，高度重视技术、专利的原创性，避开巨头们的干扰、阻挠。

只有做到这些，才能在机遇和风险并存的产业环境中不断前行，实现我们在半导体产业独立自主的目标。

52


1

3.4只读存储器

3.4.1 只读存储器概述

3.4.2 Flash 存储器

3.4.3 存储器容量扩展

2

3.4.1 只读存储器概述

只读存储器ROM：Read-Only Memory

在正常工作状态下只能读取数据，不能写入数据

掉电不易失

ROM和RAM都属于内部存储器，属于同一个内存空间

用于保存计算机运行所需的最基础、最核心的程序。

BIOS：基本输入输出系统

引导程序等

8086内存空间

3

总容量1MB

RAM

ROM

RAM

ROM



4

3.4.1 只读存储器概述

ROM中写数据称为编程(program)，包括擦除和写入

根据是否可编程，分为：

掩模ROM：制造中写入信息，用户无法更改 

可编程ROM：用户可写入内容

PROM：可编程一次

EPROM和E2PROM：可多次编程

EPROM：紫外线擦除，专用设备写入

E2PROM：电擦除，联机写入

EPROM-Erase PROM

紫外线擦除，编程器写入

EPROM上方有一个石英窗口。将芯片置于紫外灯下，以擦除其中的内容，相当于存储器又存了全“1”。然后用专用的设备将信息重新写入

6

E2PROM

E2PROM 为Electric Erase PROM

电擦除，擦除时间较快

联机写入

无需把器件从电路板取下

E2PROM允许改写上千次，编程大约需20ms，数据可存储20年以上

7

3.4.2Flash存储器

在E2PROM基础上发展而来

高密度、非失易失性

有很高的读取速度，易于擦除和重写，功耗小



FLASH 存储器的逻辑结构

8

(重点)存储器容量扩充

一、存储芯片简介

二、存储器容量扩展的三种方法

位扩展

字扩展

字位扩展

一、背景知识——存储芯片简介

存储芯片的引脚



芯片容量：字数×字长

	(存储单元数量×存储单元的位数)

9

二、存储器容量扩展的三种方法

1、位扩展

给定芯片的字长较短，不满足存储器字长要求，要用多片来扩展字长

2、字扩展

给定的芯片字数少，用多片给来扩展字数

3、字位扩展

从字长和字数两个方向扩展

10

1、位扩展

11



1、位扩展

12

存储器一个存储单元分为高4位和低4位分别位于两个芯片中

两个芯片并行工作

1、位扩展

总容量= 210×8位

13

1、位扩展

14

2、字扩展

15

2、字扩展

16

2、字扩展

分析地址：

存储器地址线A10~A0



A10用于选择芯片

A9~A0用于选择芯片内的某一存储单元

17

2、字扩展

18

2、字扩展

19

2、字扩展

20

3、字位扩展

需扩展的存储器容量为M× N位 , 已有芯片的容量为L× K位 (L<M,K<N)

21

用M/L 组 芯片进行字扩展

每组内有N/K 个 芯片进行位扩展

22

23

24

每4片一组进行位扩展

25



8组进行字扩展

26

存器容量与地址范围的关系

高3位通过3：8译码器产生每组的片选信号

27



8组进行字扩展

28



字位扩展一起画

29

例：设CPU有16根地址线，8根数据线，并用MREQ#作访存控制信号，用R/W#作读/写控制信号。

现有下列存储芯片：

SRAM：1K×4、4K×8、8K×8；

ROM：2K×8、4K×8、8K×8；

及3：8译码器和各种门电路

主存的地址空间满足下述条件：

最小8KB地址为系统程序区(ROM区)，

与其相邻的16KB地址为用户程序区(RAM区)，

最大4KB地址空间为系统程序区(ROM区)。



请画出CPU与存储器的连接图。



三、主存储器与CPU的连接

确定各区域地址范围；

根据存储器容量，确定存储芯片的数目和扩展方法；

分配地址线

地址线低位直接连接存储芯片的地址线；

高位地址线参与形成存储芯片的片选信号；

连接数据线、读写控制等其他信号线

MREQ#可用作地址译码器的使能信号

30

31

解：1）根据题目的地址范围写出相应的二进制地址码。



存器容量与地址范围的关系

32



33



3.5并行存储器

加速CPU与存储器之间的数据传输的方式：

采用更高速性能的存储器，加大字长

采用并行操作的双端口存储器

在CPU和主存之间使用高速缓存Cache

在每个存储周期中存取多个字

多模块交叉存储器

DDR



34

35

3.5.1 双端口存储器

结构特点：具有左右两个端口，每一个端口都有独立的读写控制电路

读写冲突：若左、右端口同时对相同的存储单元进行读写操作

左读右写、右读左写、左写右写

解决方法：判断逻辑决定对哪个端口优先进行读写操作，而暂时关闭另一个被延迟的端口，即置其忙信号BUSY#=0。

36

双端口存储器IDT7133逻辑框图



R

37

双端口存储器读写时序

CE判断：如果地址匹配且在CE之前有效，片上的控制逻辑在CEL和CER之间进行判断来选择端口。

38

3.5.2 多模块交叉存储器

设存储器由M个的独立的存储模块组成，

每个模块有相同的容量和存取速度

存储模块就是存储芯片

存储器地址的编排方式：顺序方式和交叉方式。

顺序方式：地址按顺序分配给一个模块后，又按顺序为下个模块分配

39



内存地址

模块2bit

字3bit

M0

M1

M2

M3



数据总线

 顺序方式

5位地址： 高2位选模块，低3位选块内地址

故障隔离

扩充容量比较方便

连续地址单元在同一个模块，各模块串行工作

带宽没有提升

40

3.5.2 多模块交叉存储器

交叉方式：

两个相邻地址的物理单元不属于同一个存储模块，一般在相邻的存储模块中；

同一个存储模块内的地址都不连续。



41



内存地址

模块2bit

字3bit

M0

M1

M2

M3



数据总线

交叉方式

5位地址：高3位选块内地址，低2位选模块

连续地址单元在不同同模块，各模块并行工作

存储对齐（软件）+交叉编址（硬件）可以系统运行速度

3.5并行存储器

42



地址总线ABUS

M0

M1

M2

M3

单字长 数据总线DBUS

交叉编址

AR

AR

AR

AR

CPU

每个模块独立工作

各模块分时使用数据总线进行信息传递。

流水线方式

数据总线是瓶颈

43



多体交叉存储器

流水线方式存取示意图

连续读取m 个字所需的时间为

模块内访问一个存储单元（字）的存储周期是T

多体并行存储器

44



地址总线ABUS

M0

M1

M2

M3

多字长 数据总线DBUS

交叉编址

AR

AR

AR

AR

CPU

也称为多通道

优化瓶颈



多模块应用

两条4G内存条 单条8G内存条性能差异？

 -45- 

双通道内存实例128bit

 -46- 

双通道内存性能评测

SiSoftware Sandra Pro Business 2011 

 HP DL120 G7Intel SandyBridge



 -47- 

新型存储器: PCRAM相变储存器

又称 PCM和 CRAM，它利用相变材料作为储存介质。

相变材料在非晶相态时具有较高的电阻值；在结晶相态时具有较低的电阻值

非易失性存储器

对相变材料施加不同时长的电脉冲，使相变材料呈现出不同的结晶状态，并在两种状态之间快速切换

储存密度较 DRAM 更高

48

新型存储器: ReRAM电阻式存储器

也称 RRAM，是以非导性材料（金属氧化物）为存储介质的非易失性存储器

施加电压，材料的电阻在高阻态和低阻态间发生相应变化，并利用这种性质储存各种信息。

RRAM 不仅高读写速度和高存储密度，同时延迟更低

49

新型存储器: MRAM和FRAM

MRAM是一种利用磁性工作的非易失性随机存储器。

基于两个铁磁层磁化状态来存储信息，当电流流过时会表现出不同的阻值。

FRAM，采用铅锆钛形成结晶体存储数据。

通过判断晶体内的电荷高低来读取数据。

50


3.6 Cache存储器



1

3.6 Cache存储器

为什么要引入Cache？

解决CPU和主存之间的速度不匹配问题

延迟（ns）和带宽（GB/s）

2

CPU带宽简单测算

个人电脑的DDR4-3200 内存单通道带宽25600MB/s

CPU默认频率位1500MHz，4核心64位处理器，每次运算需要2个数据

CPU所需带宽：1500x4x(8+8)=96000MB/s

内存墙（memory wall）



3



4

3.6 Cache存储器

在CPU和内存之间设置一个小容量的存储器Cache，保存的内容是主存内容的一个子集

Cache存取速度要比主存快，用SRAM实现

Cache功能全由硬件调度，对所有用户透明

运行过程无需软件参与

5

2. Cache基本原理

程序的局部性原理

在一段时间内，程序的执行仅限于程序中的某一部分。相应地，执行所访问的存储空间也局限于某个内存区域

时间局部性：被访问过一次的内存区域在未来会被多次访问

空间局部性：如果一个内存区域被访问，那么将来它附近的单元也会被访问

6

sum = 0;

for (i = 0; i < n; i++)

	sum += a[i].x + a[i].y;

return sum;

程序局部性举例

数据

数组元素访问 (空间)

结构体、数据库记录访问(空间)

局部变量，计数器，指针等被重复使用 (时间)

指令

顺序访问的指令 (空间)

重复使用的循环体 (时间)

子函数 (时间)

 -7- 

程序局部性举例

程序1：

int a[M][N];

for (i = 0; i < M; i++)

 for (j = 0; j < N; j++)

 sum += a[i][j];

程序2：

int a[M][N];

for (j = 0; j < N; j++)

for (i = 0; i < M; i++)

sum += a[i][j];

哪个程序具有更好的局部性

 -8- 

9

3.Cache的命中率

10

Cache的平均访问时间

11

Cache的访问效率

12

例3.4 CPU执行一段程序时，Cache完成存取的次数为1900次，主存完成存取的次数为100次，已知Cache存取周期为50ns，主存存取周期为250ns，求Cache/主存系统的效率和平均访问时间。 

解：

13

背景：相联存储器（CAM）

普通存储器都是按地址访问

相联存储器是按内容访问

Content Addressable Memory

相联存储器的基本原理

存放在相联存储器中的内容：标记+数据

查找的主要操作是比较

按地址访问存储器

按地址访问：

存储器只保存数据，数据的地址不保存

寻址时译码器根据地址直接选中对应数据

14

按地址访问：

存储器只保存数据，数据的地址不保存

寻址时译码器根据地址选中对应存储单元

15

按地址访问存储器

按内容访问：

增加标记(标识、Tag)，一般用地址的部分或全部

查找时，将访问地址和表中的所有标记比较，相同的一行就是要访问的存储单元

16

CAM存储器

按内容访问：

增加标记(标识、Tag)存储，

一般用地址的部分或全部作为标记

查找时，将访问地址和标记存储中的所有标记比较，相同的一行就是要访问的存储单元

17

CAM存储器

相联存储器

在计算机系统中，CAM主要用于需要快速查找的领域：

虚拟存储器中存放段表、页表和快表；

Cache

网络设备中路由的查找

18

19

3.6.2 主存与Cache的地址映射



20

3.6.2 主存与Cache的地址映射

Cache分为若干行（Line），每行的容量和主存块相同

Cache与主存的数据交换是以块为单位

Cache按内容访问，主存按地址访问

必须应用某种方法，把主存的地址定位到Cache中的确切位置——地址映射



例题

主存地址空间大小为256MB，按字节编址。主存块大小为64B。数据Cache有8行

假定int型数据为32位补码，数组a按行优先方式存放，首地址为320（十进制）



1）数据Cache的总容量是多少？

2）数组元素a[0][31],a[1][1]所在主存块分别是多少?

int a[256][256];

Cache原理图

22

主存分块

Cache替换管理



Cache与主存之间的数据交换是以块为单位

CPU与Cache/主存之间的数据交换是以字为单位

标记存储

Cache数据存储

Cache的基本工作原理示意图 

23

CPU将内存地址同时发往Cache和主存。

Cache的四个问题

当把一块调入Cache时，放在哪行?（映射方式）

全相联、直接映射、组相联 

如何判断当所要访问的地址在Cache中?（地址变换）

当发生失效时，应替换哪一行？（替换算法）

当进行写操作时，应进行哪些操作?（写策略）

保证数据的一致性

24

1. 全相联

多对多：主存一个块可以放到Cache任一行

将整个块地址作为Cache行的标记

25

XXXXXXXX

XX

主存地址：

块号（s位） 块内偏移（w位）

2r=8行

2s=256块

2w=4字



B0

B1

B2

B3

B124

B124

B3

B1

B0

B2



1. 全相联

26

主存256块，每块4个字，Cache有8行



1. 全相联

地址变换

CPU将内存地址同时发往Cache和主存

发往Cache的访存地址会分为块地址和块内偏移

块地址同时和Cache中所有行的Tag进行比较

相同表示命中，再根据块内偏移从该行中读取一个字，同时撤销内存寻址过程

若没有命中，则等待访存过程结束，然后将被访问内存的相对应块调入Cache

27

00000000

00000001

00000010

00000011

01011000

01011001

00000010

0101100101

0000001010

00000010

00000001

01011001

块地址（块号）

1. 全相联地址变换

内存地址

11111111

28

1. 全相联

特点：

优点：冲突概率小，Cache的利用高。

冲突：所选择的Cache行包含近期要使用的信息

缺点：比较电路实现成本高

适用于小容量的Cache



29

2. 直接映射

30

31

2. 直接映射

Cache将s位块地址分为两部分：

低r位作为Cache的行号（index）:r = log2m

高s-r位作为该行tag

直接映射的Cache组织



32

33

2. 直接映射-地址变换

第一步：用访存地址中的块号的r位行号找到Cache中对应的一行

第二步：用块号的s-r位与该行的tag比较。

若命中，而后用低w位读取所要求的字

若不命中，访问主存

二、直接映射

映射检索过程

00000000

00000001

00000010

00000011

01011000

01011001

01011011

01011010

0101111101

0000001011

01011

11001

01011

块号

蓝色：行号；绿色：字地址

Cache地址000

Cache地址010

Cache地址111

34

2. 直接映射

优点：硬件简单，成本低

缺点：每个块只有一个固定的行可存放，容易产生冲突

频繁置换会导致Cache抖动，效率下降

适合大容量Cache采用

更多行减小冲突

35

3. 组相联

将Cache分成u组，每组v行

组间采用直接映射，组内采用全相联映射

主存中的每一块可以被放置到Cache中唯一的组的任何一行

组相联是全相联和直接映射的折中方案

q组号，j主存块地址、m为Cache总行数

m＝u×v 　　　组号　q＝j mod u

设u ＝ 2d，q = log2 d: 



36

3. 组相联映射方式

低d位表示组号(组索引，组index)

高s-d位作为tag

37

Cache分为4组，每组2行



38

3. 组相联映-地址变换

第一步：用块号的低d位找到对应组

第二步：将块号的高s-d位与该组中所有行的标记同时进行比较

命中，选中该行，用内存地址的低w位选择相应的字

不命中，则访问内存

39

三、组相联映射地址变换



00000000

00000001

00000010

00000011

01011000

01011001

11111111

01011010

010110 00 11

000000 10 01

00

10

11

000000

010110

000000

010110

块号

蓝色：组号；绿色：字地址

40

3. 组相联映射方式

特点：比全相联容易实现，冲突低

u=1，则为全相联映射方式

v表示每组的行数，称之为v路组相联Cache。v=1，则为直接映射方式

得到普遍采用



41

全相联映射载入过程



22

101102

26

110102



22

101102



26

16

4

16

18

载入

载入

命中

命中

载入

载入

命中

载入



t

22

26

16

4

18

主存32块，Cache8行

42

直接相联映射载入过程



22

（10110）

22

26

16

4

16

18

载入

载入

命中

命中

载入

载入

命中

替换



t

22

26

16

4

16

18

26

（11010）

主存32块，Cache8行

43

2路组相联映射载入过程



22

26

22

26

16

4

16

18

载入

载入

命中

命中

载入

载入

命中

载入



t

22

26

16

4

18

主存32块，Cache8行

44


Cache基本概念

Cache的作用：

解决CPU和主存之间的速度不匹配问题

小容量存储器，用SRAM实现

对用户透明

Cache的原理

程序局部性：时间和空间

Cache性能

命中率、平均访问时间、效率

1

Cache基本概念

CAM

按内容访问、比较器

主存地址：块地址和块内偏移



Cache分为若干行（Line），每行的容量和主存块相同

Cache与主存的数据交换是以块为单位



2

1. 全相联

多对多：主存一个块可以放到Cache任一行

将全部块地址作为Cache行的标记

3

1. 全相联

地址变换

CPU发出的访存地址中的块地址同时和Cache中所有的Tag进行比较。

特点

冲突概率小，成本高

适用于小容量的Cache

4

2. 直接映射

多对一：一个主存块只能映射到Cache的一个特定行上



5

6

2. 直接映射-地址变换

地址变换

用访存地址中的块号的r位行索引找到Cache中对应的行

然后用块号的s-r位与该行的tag比较。

特点

硬件简单，成本低，容易产生冲突

频繁置换会导致Cache抖动，效率下降

适合大容量Cache采用

3. 组相联

将Cache分成u组，每组v行

V路组相联

组间采用直接映射，组内采用全相联映射

7

3. 组相联映-地址变换

地址变换

首先访存地址的块地址的低d位找到对应组，

然后将块地址的高s-d位与该组v行中的所有tag同时进行比较。

特点

比全相联容易实现，冲突低

全相联映射和直接映射的折衷

得到普遍采用

8

9

10

一个4路组相联Cache由64行组成，主存储器包含4K个块，每块128字。请表示主存地址的格式？

典型题

组相联映射下的主存地址格式如下：



每块128字

块内的字地址需要7位

Cache由64个行组成，每组4行

Cache共包含16组，需4位组号

主存包含4K个块

主存块号为12位

标记位12－4=8位



7位

4位

8位

解：主存容量1M=220，主存地址共20位

		块大小=24字节，字号(块内偏移) w=4

		块地址：20-4=16位

		全相联映射 ，标记位数等于块地址位数，为16位

主存格式



主存地址(F0010)16 =(1111 0000 0000 0001 0000)2

对应的标记=1111 0000 0000 0001 字号=0000

11

 有一个存储体系，主存容量1MB，字长1B，块大小16B，Cache容量64KB。若Cache采用全相联映射，对内存地址（F0010H ）给出相应的标记和字号。

例：

某PC主存容量为128KB,Cache容量4KB,每块32B。

主存多少块？块地址多少位？Cache多少行？

主存块：128K/32=4K，块地址占12位

Cache行：4K/32=128=27

用直接映射时，Cache标记几位？

12位块地址中，低7位定位Cache行，高5位为标记

用全相联映射，Cache标记几位？

12位

12

例：

某计算机的Cache有16行，采用二路组相联映射方式，每个主存块大小为32字节，按字节编址。则主存129号单元的主存块装如Cache的组号是：

A、0       B、2       C、4       D、6

解：二路组相联，共有16/2=8组，组号占3位。      每块32字节，所以块内地址占5位。    129转化为二进制：100_00001：前3位为组号，组号为4。

	129/32 = 4 ，4 mod 8 = 4



13



块地址=块号

块内偏移 =块内地址 =字地址 = 字号

14

3.6.3 替换策略

当从主存向Cache传送一个新块，而Cache中可用位置已被占满时，就会产生替换问题

直接映射：替换Cache中指定的一行

全相联和组相联： 从所有行或组内所有行中选取一行换出

Cache的常用替换算法：

最不经常使用LFU算法

近期最少使用LRU算法

随机

15

3.6.3 替换策略

最不经常使用LFU(Least Frequently Used)算法

每行设置一个计数器，0开始计数

每访问一次， 被访行的计数器增1。

当需要替换时，将计数值最小的行换出，同时将该行的计数器都清零。

不能严格反映近期访问情况。

刚调入Cache的新行很容易被换出

16

17

3.6.3替换策略

例子：设Cache有1、2、3、4共4行(全相联映射)，a、b、c、d、e等为主存中的块,访问顺序一次如下：a、b、c、d、c、b、c、e、d、d、a ,e。1）采用LFU算法替换 

 



18

 



 



计数器从0开始计数

每访问一次，该行的计数器增1。

将计数值最小的行换出，该行计数器清零。

3.6.3 替换策略

近期最少使用(LRU-Least Recently Used的)算法

将近期内长久未被访问过的行换出

每行设置一个计数器

访问时，命中行的计数器清零，其它各行的计数器增1

替换时，将计数值最大的行换出

保护了刚拷贝到Cache中的新行，提高了命中率

随机替换

随机地选取一行换出

19

 



 



20

命中行的计数器清零，其它各行的计数器增1

将计数值最大的行换出。

3.6.4 Cache的写操作策略

Cache的内容只是主存部分内容的副本

对Cache的写入导致与主存内容的不一致

三种写策略

写回法（Write-Back）

全写法（Write-Through、写穿透、写直达）

写一次法（Write-Once）

考虑写命中和写不命中两种情况



21

(1) 写回法

写命中：

修改Cache的内容，而不立即写入主存

只有当此行被替换时才写回主

写未命中：

首先将内存中对应块调入Cache，然后对其修改

当此行换出时，写回主存

特点

减少了访问主存的次数

存在不一致的隐患

每行配置一个修改位，以反映此行是否被CPU修改过。 被修改过的行称为脏行（dirty）



22

例题

(2) 全写法 

写命中时：

同时写入Cache与主存

写未命中时：直接向主存进行写入

特点：

无需增加修改位

写Cache和写主存同步进行，不存在数据不一致的情况

一定程度上降低了Cache的性能 

24

(3) 写一次法 

写回法+全写法

写命中时：

第一次：采取全写法

不是第一次：采取写回法

写未命中时：

与写回法相同

主要用于多处理器系统

25

Intel i7 Cache 结构

26



27



28



例题

主存地址空间大小为256MB，按字节编址。指令数据Cache，均有8行，Cache行大小为64B，数据Cache直接相联。现有两功能相同的程序A，B，其伪代码如下所示：

假定int型数据为32位补码，程序编译时i,j,sum均分配在寄存器中，数组a按行优先方式存放，首地址为320（十进制）。



1）数组元素a[0][31],a[1][1]所在主存块对应的Cache行分别是多少，行号从零开始。

2)程序A，B的数据访问命中率各是多少？那个程序的执行时间更短?



int a[256][256];

for (i = 0; i < 256; i++)

 for (j = 0; j < 256; j++)

 sum += a[i][j];

int a[256][256];

for (j = 0; j < 256; j++)

for (i = 0; i < 256; i++)

sum += a[i][j];

程序A

程序B


3.7虚拟存储器

原因？

多用户、多任务的出现，要求每个程序有自己独立的内存空间

用户编程时希望不考虑实际程序的运行空间？

虚拟存储器只是一个容量非常大的存储器的逻辑模型，它借助于磁盘等辅助存储器来扩大主存容量，使之为更大或更多的程序所使用。



3.7虚拟存储器

1. 实地址与虚地址

用户编制程序时使用的地址称为虚地址或逻辑地址，其对应的存储空间称为虚存空间或逻辑地址空间；

计算机物理内存的访问地址则称为实地址或物理地址，其对应的存储空间称为物理存储空间或主存空间。程序进行虚地址到实地址转换的过程称为程序的再定位。

注意：

　　物理地址由CPU地址引脚送出，用于访问主存的地址。

　　虚拟地址由编译程序生成的，是程序的逻辑地址。

主存～外存层次所用的地址变换映射方法和替换策略与cache～主存层次所用的方法和策略是相同的，即都基于程序局部性原理。它们遵循的原则是：



3.7虚拟存储器

2. 虚存访问过程：

虚存空间用户程序按照虚地址编程并存放于辅存之中

运行时，操作系统将程序的部分调入内存。

每次访存时，判断：虚地址对应部分是否在内存？

若在：虚实地址转换

不在：从辅存中调入



3.7虚拟存储器

虚存是概念模型，不是实物

对系统程序不透明、对应用程序透明

虚存能有效提高存储体系性能

Cache

主存

辅存

Cache-主存访问机制

主存-辅存 访问机制



3.7虚拟存储器

3. Cache与虚存的异同：

出发点相同：提高存储系统性能

原理相同：局部性原理

侧重点不同：

Cache：解决速度差异，提高访存速度；

虚存：容量、分配、保护等

数据通路不同：

CPU与主存和Cache有直接通路；

CPU不能直接访问辅存

3.7虚拟存储器

3. Cache与虚存的异同：

透明性不同：

Cache：完全由硬件完成，透明；

虚存：硬件软件完成，仅对用户程序透明

未命中损失不同：

Cache：未命中时间损失小

虚存：未命中时间损失大



3.7虚拟存储器

4.虚存机制要解决的关键问题

调度问题：哪些程序、数据调入主存？

地址映射问题：虚实地址变换

替换问题：决定哪些程序和数据应被调出主存

更新问题：主存、辅存内容一致性

3.7虚拟存储器

不同的虚拟存储器机制

页式虚拟存储器

段式虚拟存储器和段页式虚拟存储器

不同的替换算法：

FIFO、LRU、LFU

3.7.2页式虚拟存储器

 页式虚拟存储系统中，虚拟空间分成页，称为逻辑页；主存空间也分成同样大小的页，称为物理页。

　虚存地址分为两个字段：逻辑页号+页内行地址。

　实存地址也分两个字段：物理页号+页内行地址。

　页表中每一个虚存逻辑页号有一个表目，表目内容包含该逻辑页所在的主存页面地址(物理页号)，用它作为实存地址的高字段，与虚存地址的页内行地址字段相拼接，产生完整的实主存地址，据此来访问主存

页式虚拟存储器结构



　页表通常在主存中，也至少要访问两次物理存储器才能实现一次访存，这将使虚拟存储器的存取时间加倍。为了避免对主存访问次数的增多，把页表中的最活跃的部分存放在高速存储器中，这个专用于页表缓存的高速存储部件通常称为转换后援缓冲器(TLB)。保存在主存中的完整页表则称为慢表。        

　　

3.6.2页式虚拟存储器

TLB的地址映射过程

3.7.3 段式虚拟存储器和段页式虚拟存储器

1、段式虚拟存储器

段是按照程序的自然分界划分的长度可以动态改变的区域。

子程序、操作数和常数等划分到不同的段中，并且每个程序可以有多个相同类型的段。

虚地址由段号和段内地址（偏移量）组成。虚地址到实主存地址的变换通过段表实现。

14

段式虚拟存储器地址变换



段页式虚拟存储器是段式虚拟存储器和页式虚拟存储器的结合。

　　它把程序按逻辑单位分段以后，再把每段分成固定大小的页。

　　程序对主存的调入调出是按页面进行的，但它又可以按段实现共享和保护，兼备页式和段式的优点。

　　缺点是在映象过程中需要多次查表。



段页式虚拟存储器

在段页式虚拟存储系统中，每道程序是通过一个段表和一组页表来进行定位的。段表中的每个表目对应一个段，每个表目有一个指向该段的页表起始地址及该段的控制保护信息。 如果有多个用户在机器上运行，多道程序的每一道需要一个基号，由它指明该道程序的段表起始地址。

虚拟地址格式如下：

段页式虚拟存储器

【例10】 假设有三道程序(用户标志号为A，B，C)，其基址寄存器内容分别为SA，SB，SC ，逻辑地址到物理地址的变换过程如下图所示。在主存中，每道程序都有一张段表，A程序有4段，C程序有3段。每段应有一张页表，段表的每行就表示相应页表的起始位置，而页表内的每行即为相应的物理页号。请说明虚实地址变换过程。

3.7.4 替换算法

虚拟存储器中的页面替换策略和cache中的行替换策略有很多相似之处，但有三点显著不同：

　(1) 缺页至少要涉及一次磁盘存取，读取所缺的页，缺页使系统蒙受的损失要比cache未命中大得多。

　(2) 页面替换是由操作系统软件实现的。

　(3) 页面替换的选择余地很大，属于一个进程的页面都可替换。

虚拟存储器中的替换策略一般采用LRU算法、LFU算法、FIFO算法，或将两种算法结合起来使用。

　　对于将被替换出去的页面，假如该页调入主存后没有被修改，就不必进行处理，否则就把该页重新写入外存，以保证外存中数据的正确性。为此，在页表的每一行应设置一修改位。

21

【例7】假设主存只有a,b,c三个页框，组成a进c出的FIFO队列，进程访问页面的序列是0，1，2，4，2，3，0，2，1，3，2号。若采用①FIFO算法，②FIFO算法+LRU算法，用列表法分别求两种替换策略情况下的命中率。

3.8 虚拟存储器实例

1. 奔腾PC机的虚地址模式

奔腾PC的存储管理部件MMU包括分段部件SU和分页部件PU两部份，可允许SU，PU单独工作或同时工作。

分段不分页模式： 虚拟地址由一个16位的段参照和一个32位的偏移组成。分段部件SU将二维的分段虚拟地址转换成一维的32位线性地址。优点是无需访问页目录和页表，地址转换速度快。对段提供的一些保护定义可以一直贯通到段的单个字节级。

分段分页模式：在分段基础上增加分页存储管理的模式。即将SU部件转换后的32位线性地址看成由页目录、页表、页内偏移三个字段组成，再由PU部件完成两级页表的查找，将其转换成32位物理地址。兼顾了分段和分页两种方式的优点。

不分段分页模式：这种模式下SU不工作，只是分页部件PU工作。程序也不提供段参照，寄存器提供的32位地址被看成是由页目录、页表、页内偏移三个字段组成。由PU完成虚拟地址到物理地址的转换。这种模式减少了虚拟空间，但能提供保护机制，比分段模式具有更大的灵活性。

2. 保护模式的分页地址转换

奔腾页面大小为4MB

使用单级页表。

32位线性地址分为高10位的页面和低22位的页内偏移两个字段 。

页表项的I位指示页面大小，P位为出现位，A位为访问过位，D位为修改过位。RW位用于读/写控制，US位用于用户/监督控制，PCD位用于页cache禁止的控制，PWT位用于页全写法的控制。 

奔腾4MB分页方式地址变换

3.9存储保护 



 当多个用户共享主存时，就有多个用户和系统软件存于主存中，为使系统能正常工作，应防止由于一个用户程序出错而破坏其他用户的程序和系统软件，还要防止一个用户程序不合法地访问不是分配给它的主存区域。为此，系统应提供存储保护。通常采用的方式是：

1存储区域保护

2访问方式保护

3.9.1 存储区域保护

非虚拟存储器的主存系统可采用界限寄存器方式。

由系统软件经特权指令设置上、下界寄存器，为每个程序划定存储区域，禁止越界访问。

界限寄存器方式只适用于每个用户占用一个或几个连续的主存区域。

在虚拟存储系统中，通常采用页表保护、段表保护和键式保护方法。

1. 页表保护和段表保护

每个程序的段表和页表本身都有自己的保护功能。每个程序的虚页号是固定的，经过虚地址向实地址变换后的实存页号也就固定了。那么不论虚地址如何出错，也只能影响到相对的几个主存页面。不会侵犯其他程序空间。段表和页表的保护功能相同，但段表中除包括段表起点外，还包括段长。

2. 键保护方式

为主存的每一页配一个键，称为存储键

每个用户的实存页面的键都相同。为了打开这个锁,必须有钥匙，称为访问键。

访问键赋予每道程序，并保存在该道程序的状态寄存器中。

当数据要写入主存的某一页时，访问键要与存储键相比较。若两键相符，则允许访问该页，否则拒绝访问。 

3. 环保护方式

对正在执行的程序本身的核心部分或关键部分进行保护。

它是按程序的重要性及对整个系统的正常运行的影响程度进行分层，每一层叫做一个环。

在现行程序运行前由操作系统定好程序各页的环号，并置入页表中。然后把该道程序的开始环号送入CPU的现行环号寄存器。

程序可以访问任何外层空间；访问内层空间则需由操作系统的环控例行程序判断这个向内访问是否合法。

3.9.2 访问方式保护

　对主存信息的使用可以有三种方式：读、写和执行。相应的访问方式保护就有R、W、E三种方式形成的逻辑组合。这些访问方式保护通常作为程序状态寄存器的保护位，并且和区域保护结合起来实现。

表3.11　访问方式保护的逻辑组合 



35

本 章 小 结

对存储器的要求是容量大、速度快、成本低。为了解决了这三方面的矛盾，计算机采用多级存储体系结构，即cache、主存和外存。

存储器的技术指标有存储容量、存取时间、存储周期、存储器带宽。

SRAM、DRAM和ROM各自的特性


第四章指令系统

4.1 指令系统的发展与性能要求

4.2 指令格式

4.3 操作数类型

4.4 指令和数据的寻址方式

4.5 典型指令

1

4.1 指令系统的发展与性能要求

冯诺依曼结构主要思想

五大部件

存储程序

程序控制

计算机程序由一系列的机器指令组成

指令是计算机执行某种操作的命令

每个指令的执行过程依靠硬件实现



2

4.1 指令系统的发展与性能要求

指令是软件和硬件分界面(Interface)

硬件设计人员采用各种手段实现它；

软件设计人员则利用它编制系统软件和应用软件



指令系统：一台计算机中所有机器指令的集合

表征一台计算机性能的重要因素 

影响计算机的硬件结构、系统软件，机器的适用范围

指令集架构(Instruction Set Architecture, ISA)



3

指令系统

4

4.1.1指令系统的发展 

系列计算机

基本指令系统相同、基本体系结构相同的一系列计算机

同一系列的各机种有共同的指令集

指令集向下兼容

X86系列、ARM系列

5

4.1.1指令系统的发展 

复杂指令系统计算机

CISC-Complex Instruction Set Computer

单条指令功能复杂，整个指令系统数量庞大

控制器研制开发周期变长，正确性难以保证，调试维护困难

X86、IA32\IA64、

IBM System/360 

Intel MCS-51



精简指令系统计算机

RISC-Reduced Instruction Set Computer

克服CISC缺点，便于VLSI技术实现

单条指令功能简单

2/8规则：80%的指令完成20%的功能

控制器设计难度降低

ARM: Advanced RISC Machine

RISC-V、MIPS

AVR: Alf and Vegard's RISC processor



6

4.2 指令格式

表示一条指令的二进制串称为指令字，指令

指令格式：用二进制代码表示的结构形式



操作码（OP-Operation Code）

该指令执行的操作，编码表示

地址码（AC-Address Code）

描述指令的操作对象，可以是操作数本身，也可以是操作数的位置

存储器单元----存储器地址

寄存器----寄存器编号

I/O设备中的缓冲-----端口号



7

4.2.2 地址码

操作数有被操作数、操作数及操作结果这三种数

形成了三种指令格式

8

三地址指令

二地址指令

一地址指令

零地址指令

4.2.2 地址码

零地址指令  

指令字中只有操作码，而没有地址码

一种是无需操作数

如NOP、HLT停机指令等

另一种是操作数为默认的（或称隐含的）

如操作数在累加器或者堆栈中



9

零地址指令

4.2.2 地址码

一地址指令

常称为单操作数指令，指令中只有一个地址码

可能是单操作数运算

给出的地址既作为操作数的地址，也作为结果的地址

OP (A) -> A

也可能是二元运算

指令中提供一个操作数，另一个操作数则是隐含的

(A) OP (AC) -> A　　　

10

一地址指令

4.2.2 地址码

二地址指令

最常见的指令格式，又称为双操作数指令

运算结果保存在其中一个地址码中，原来的数据被覆盖

		（A1）OP（A2）→ A1

地址码A1兼做存放操作结果

11

4.2.2 地址码

三地址指令

	 (A1)　OP　(A2)　->　A3

A1和A2为源操作数

A3为目的操作数

	

12

4.2.2 地址码

在二地址和三地址指令格式中，从操作数的物理位置划分为三种类型

存储器-存储器 (Storage-Storage, SS) 型指令：

从内存单元中取操作数，操作结果存放至内存单元

需要多次访问内存

寄存器-寄存器 (Register-Register, RR) 型指令：

从寄存器中取操作数，把操作结果放到另一寄存器

这类指令的速度很快，因为不需要访问内存

寄存器-存储器 (Register-Storage, RS) 型指令：

此类指令既要访问内存单元，又要访问寄存器

13

4.2.3 指令字长度

指令字长度：一条指令的二进制位数

为了取指方便，一般为机器字长倍数

半字长、单字长、双字长

多字长指令

指令字长度等于两个或多个机器字长

优点：地址码更多，解决内存的寻址问题；

缺点：多次访存才能取得一条指令，降低了速度，占用存储空间大



14

4.2.3 指令字长度

指令集中所有指令长度是否相等

等长指令：所有指令长度相等

结构简单，控制线路简单

MIPS、ARM

变长指令：指令字长度随功能而异

结构灵活，控制较复杂

X86

现在指令字长一般为32位固定长度

15

4.2.4 指令助记符

为了便于书写和阅读，指令通常用3个或4个英文缩写字母来表示，叫做指令助记符

16

指令格式举例：ARM指令格式 

指令长度为32位，定长指令

单字长指令

RR型指令、三地址指令

17

指令格式举例 X86指令格式 

变长指令，1~15字节，典型的CISC指令系统 

多字长指令

18

X86指令格式 

JE20H

Call

PUSH ESI

MOV EBX,[EDI+45]



[例1]　机器字长16位，指令格式如下所示，其中OP为操作码，试分析指令格式的特点。 

15　 9　7　 4 3　0

[解]： 

(1)单字长二地址指令

(2)操作码字段OP可以指定27=128条指令

(3)源寄存器和目标寄存器都是通用寄存器（总共16个），所以是RR型指令，两个操作数均在寄存器中

[例2]机器字长16位，指令格式如下所示，OP为操作码字段，试分析指令格式特点。

15　　10　　7　43　　 　0 

(1)双字长二地址指令

(2)操作码字段OP为6位，可以指定64种操作

(3)一个操作数在源寄存器，另一个操作数在存储器中,所以是RS型指令。 通用寄存器（总共16个)

H&P 和RISC

John Hennessy

MIPS是在是其在Stanford的研究成果

Hennessy于1984年在硅谷创立了MIPS公司

后任Stanford大学校长

David Patterson

加州大学伯克利分校教授，研究成果发展出SUN公司SPARC处理器

是谷歌的杰出工程师

RISC-V Foundation 董事会副主席



H&P 和RISC

两人出版了两本著名的教科书：

Computer Organization and Design : The Hardware/Software Interface(计算机组成与设计：硬件/软件接口)

Computer Architecture : A Quantitative Approach(计算机体系结构：量化方法)

2017 ACM图灵奖

MIPS架构历史

MIPS（Microprocessor without Interlocked Pipelined Stages）ISA 是经典的RISC架构之一

1981 年由斯坦福大学的Hennessy 团队研制

1984 年被 MIPS Technologies公司商业化,1992 年SGI收购

2013 年Imagination Technologies 公司收购

2017 年卖给Tallwood,2018 年Wave Computing收购（命运多舛）

2019 年成为MIPS Open，正式开源（2020年闭源）

MIPS ISA版本

MIPS32/MIPS64 多个版本

基于MIPS ISA的处理器

龙芯系列，君正系列

MIPS 指令集特点

单字长指令

指令长度为4 字节=32位

定长指令

大部分为三地址指令，RR型

32个32位的通用寄存器

$0, $1, $2, … $30, $31

内存按字节编址，内存严格4字节对齐访问

MIPS里没有状态码，没有标志寄存器

MIPS指令格式

OP

RS

Rt

shamt

Rd

6bits

funct

5bits

5bits

5bits

5bits

6bits

OP

RS

Rt

6bits

偏移量

5bits

5bits

16bits

OP

6bits

地址

26bits

R 型指令

I 型指令

J 型指令

Register format

Immediate format

Jump format

MIPS指令格式（R型指令）

OP

RS

Rt

shamt

Rd

6bits

funct

5bits

5bits

5bits

5bits

6bits

例：add $s1, $s2, $s3

000000100101001110001 00000 100000

MIPS指令格式 (R型指令)

0x02538820

$s2 + $s3 = $s1

MIPS指令格式（I型指令）

OP：操作码

Rs：第1个源操作数寄存器

Rt：目的操作寄存器

偏移量：第二个原操作数

OP

RS

Rt

6bits

偏移量

5bits

5bits

16bits

MIPS指令格式（J型指令）

OP：操作码

跳转指令，用一个26位的立即数作为跳转的目标地址

OP

6bits

立即数

26bits

31

4.3 操作数类型

操作数类型

地址数据：地址是无符号整数。

数值数据：定点数、浮点数

字符数据：字符或字符串，使用ASCII码

逻辑数据：一个单元中有几位二进制bit项组成，每个bit的值可以是1或0。当数据以这种方式看待时，称为逻辑性数据

RISC-V

完全开放

大道至简

包含一个最小的核心ISA 

适合硬件实现

轻装上阵的后发优势

模块化的可扩展指令集

方便简化硬件实现，提升性能

更规整的指令编码、更简洁的运算指令和访存模式

高效分支跳转指令（减少指令数目）、简洁的子程序调用

无条件码执行、无分支延迟槽、无零开销硬件循环（支持for循环的硬件支撑）

MIPS 32 & RISC-V

指令助记符及语法格式大同小异

RISC-V 分支预测，MIPS延迟槽

RISC-V支持变长指令扩展

RISC-V 将源寄存器rs1，rs2和目标寄存器（rd）固定在同样位置，以简化指令译码

立即数分散在不同位置，但符号位固定在第31位，可加速符号扩展电路

RISC-V （2022年）

34

三大事件：

第一，发布首台RISC-V的便携式计算机

第二，Intel设立创新基金，支持RISC-V生态；

第三，SiFive估值超25亿美元

RISC-V全球会员超过3100家，超过160个核开源；

SPECint首次超过10分，进入高性能计算行列

在IoT领域的应用规模超过100亿颗

中国公司的出货量占据50%

RISC-V （2022年）

阿里平头哥发布了高性能RISC-V芯片平台“无剑600”及SoC原型“曳影1520”，兼容龙蜥操作系统,并成功运行LibreOffice

无剑600平台是当前全球性能最高的可量产RISC-V平台：支持4核RISC-V处理器，主频可达2.5GHz，CPU+XPU异构架构；支持64位LPDDR4X，最高吞吐率4266MT；整合4TOPs的Int8 AI算力

35

RISC发展

1964年Seymour Cray设计的CDC 6600采用了load/store设计，被认为是RISC架构的先驱

70年代，RISC的概念由IBM的约翰·科克（John Cocke）和斯坦福大学的约翰·亨尼（John Hennessy）等人提出

1981年，斯坦福大学的Hennessy发布了首款MIPS芯片

1981年，加州大学伯克利分校的David Patterson 推出了RISC-I

1983年RISC-II；1984年发布了RISC-III；1988年发布了RISC-IV

2010年，发布了RISC-V

1987年，SUN公司在RISC-II基础上开发了SPARC处理器

36



RISC架构在1980年代末至1990年代得到了广泛的应用和普及。许多公司开始推出基于RISC架构的处理器，如IBM的POWER架构、DEC的Alpha架构和HP的PA-RISC架构等。

RISC-V是一种开源的RISC架构，在2010开始兴起，并得到了全球范围内的关注和采用。RISC-V的开放性和灵活性使得它成为教育、研究和嵌入式系统等领域的理想选择。

37


1

4.4 指令和数据的寻址方式

存储器中既存放指令，也存放数据

在存储器中，操作数或指令字写入或读出的方式，有地址指定方式、相联存储方式和堆栈存取方式

几乎所有计算机在内存中都采用地址指定方式

当采用地址指定方式时，形成操作数或指令地址的方式，称为寻址方式

2

4.4 指令和数据的寻址方式

寻址方式问题

确定本条指令中各操作数的地址

下一条指令的地址

寻址方式分为两类

顺序寻址方式

(1) 指令寻址方式 跳跃寻址方式

 

(2) 数据寻址方式

1.顺序寻址方式

指令地址在内存中按序排放

执行程序时，通常是顺序执行

称为指令的顺序寻址方式

使用程序计数器PC（program counter）保存指令的顺序号

顺序号就是指令在内存中的地址

新指令地址：PC = PC +常量

常量就是当前指令的长度

MIPS：PC+4

3

图4.1 指令的寻址方式

2.跳跃寻址方式

当程序转移执行顺序时，指令寻址采取跳跃寻址方式

所谓跳跃，是指下条指令的地址码不是由PC给出，而是由本条指令直接给出

程序跳跃后，按新的指令地址开始顺序执行

PC的内容也必须相应改变，以便及时跟踪新的指令地址

2.跳跃寻址方式

6

跳跃寻址方式功能

实现程序转移或构成循环程序

或将某些程序作为公共程序引用（子程序调用）

各种条件转移或无条件转移指令，属于跳跃寻址

4.4.2 操作数寻址方式

形成操作数的有效地址（EA-Effective Address）的方法，称为操作数的寻址方式

地址码由形式地址（偏移量）和寻址方式特征位组合形成

例如，一种单地址指令中用X，I，A各字段组成该指令的地址码



寻址方式特征位指明如何对形式地址进行变换

7

8

4.4.2 操作数基本寻址方式

计算机中操作数的存放位置有

操作数包含在指令中；

操作数包含在CPU的某一个内部寄存器中；

操作数包含在主存中；

操作数包含在I/O设备的端口中

根据操作数放在不同的地方，从而派生各种不同的寻址方式

4.4.2 操作数寻址方式

9

1、隐含寻址

在指令中不明显的给出而是隐含着操作数的地址

例如，单地址指令、双地址指令

10

2、立即寻址

地址码中不是操作数的地址，而是操作数本身

也叫立即数

特点：

操作码和操作数被同时取出，提高了指令的执行速度

操作数是指令的一部分，不能修改

操作数的大小将受到指令长度的限制，寻址方式灵活性差

例如： ADD BX, 33H	;33H为立即数（X86）

	 addi $3, $0, 3 ;3为立即数（MIPS）



11

3.直接寻址

直接寻址：形式地址A就是操作数的有效地址EA

EA＝A

直接寻址方式由寻址方式特征位给予指示



12

X86：MOV AX , [200]



EA = A

Imm为寻址方式特征位

3.直接寻址



77



200

200

内存

4、间接寻址

间接寻址：形式地址A是操作数内存地址的指示，A单元的内容才是操作数的有效地址。

结合直接寻址和间接寻址，定义指令格式如下：



I＝0，表示直接寻址，有效地址EA＝A

I＝1，表示间接寻址，有效地址EA＝(A)　



14

4、间接寻址

间接寻址要比直接寻址灵活

至少需要两次访问主存储器才能取出操作数



400



788



300

300

400

间接寻址方式示意图

5、寄存器寻址 

操作数在通用寄存器中

地址码为通用寄存器编号，即EA=R

从寄存器中取操作数比访问主存快



X86：MOV AX,BX

MIPS: add $4, $15, $17

16

6、寄存器间接寻址 

寄存器中存放的不是操作数，而是操作数的内存地址

地址码给出通用寄存器的编号，有EA=(R)

17



300

R

7. 偏移寻址

偏移寻址是直接寻址和寄存器间接寻址的结合

有效地址EA = A +（R）。

寻址特征位指明某个专用寄存器

常用的三种偏移寻址是相对寻址、基址寻址、变址寻址。

18

7.偏移寻址

7.1相对寻址方式

专用寄存器是程序计数器PC

即有效地址EA = A + (PC)。

“相对”寻址，就是相对于PC的地址

形式地址A可正可负

一种指令寻址方式

20

7.1相对寻址方式



2000



 PC

2100

 程序指令计数器

7.2基址寻址方式

专用寄存器是基址寄存器

形式地址A是通常是无符号整数

可以扩大寻址能力，基址寄存器的位数长，可以访问较大的地址范围



MIPS:LW $18, 8($15) #EA = $15 +8 

22

7.3 变址寻址方式

专用寄存器是变址寄存器

目的而在于实现程序块的规律性变化

例如，一个数组在内存的首地址为X，将首地址X作为指令中的形式地址A，并在变址寄存器中指出元素的序号，便可访问任一元素

X86：MOV AX, 200[SI] 

SI,DI 都称为变址寄存器



23

7.3 变址寻址方式

X86：MOV AX, 200[SI] 

SI,DI 都称为变址寄存器



24

3000



操作数



 R

 3200

内存

8.段寻址

Intel 8086/8088微机中，ALU16位运算，但其内存容量可到1M，即地址有20位

将整个1M空间存储器以64K为单位

划分成若干段。

在形成20位物理地址时，段寄存器

中的16位数会自动左移4位，

 然后以16位偏移量相加

9.堆栈寻址方式 

堆栈有寄存器堆栈和存储器堆栈两种形式，都以先进后出的方式存取数据

不论哪种堆栈，需要一个隐式或显式的堆栈寄存器来指明栈顶（栈指针）的位置（地址）

X86中，SP(Stack Point,栈顶指针)

BP(Base Point,栈底)

26

9.堆栈寻址方式 

根据栈顶状态不同，堆栈分为：

满栈：栈指针指向栈顶元素位置

空栈：栈指针指向下一个空位置

根据增长方向不同，堆栈分为：

递减栈：堆栈向内存地址减小的方向生长，即向下生长。

递增栈：堆栈向内存地址增加的方向生长，即向上生长。

X86:满栈、递减栈

27

栈指针指向最后压入堆栈的有效数据项，称为满栈（先改变SP，再放数据）；

栈指针指向下一个待压入数据的空位置，称为空栈（先放数据，再改变SP）。 

0x12345678



栈底

栈区

0x12345678

0x12345678

递增栈： 

递减栈：

30

寻址方式举例： Pentium

EA = 段寄存器 + 描述符寄存器 + 基址寄存器 + 变址寄存器*比例因子 + 偏移量 

寻址方式举例：MIPS

31

寻址方式举例：RISC-V

32

[例]一种二地址RS型指令的结构如下所示：

　　6位　 　4位　　 1位 2位　 16位

其中I为间接寻址标志位，X为寻址模式字段，A为偏移量字段。通过I，X，A的组合，可构成下表所示的寻址方式。 请写出六种寻址方式的名称。



200

500

1100

200

100



500



800



100



200



2100

OP

X

A=100

PC=1000

R基=2000 

寻址方式

X

操作数

立即

0

100

直接

1

200

间接

2

500

相对

3

100

基址

4

200

有效地址EA



EA=A=100

EA=(A)=200

EA=PC+A=1100

EA=(R)+A=2100

例设某机的指令格式、有关寄存器和主存内容如下，X为寻址方式，A为形式地址，请在下表中填入有效地址EA及操作数的值。？



指令格式设计举例

例. 某机字长32位，采用三地址指令，支持8种寻址操作，完成60种操作，各寻址方式均可在2K主存范围内取得操作数，并可在1K范围内保存运算结果。问应采用什么样的指令格式？指令字长最少应为多少位？执行一条直接寻址模式指令最多要访问多少次主存？



47位指令字需占用2个存储字

取指需访存2次，取源操作数访存2次，写结果1次，共5次

4.5.1指令的分类

按指令的功能：

数据传送

实现主存和寄存器之间，或寄存器和寄存器之间的数据传送

数据处理

定点或浮点算术运算，向量运算、逻辑运算与移位等

程序控制

用于控制程序的执行方向

分支、转移、调用子程序

其他指令

系统控制，特权，安全等

36

37

设存储字长和指令字长均为24位，若指令系统可完成108种操作，且具有直接、间接、变址、基址、相对和立即6种寻址方式。

在保证最大范围内直接寻址的前提下，指令字中操作码占几位？寻址特征位占几位？可直接寻址的范围是多少？间接寻址的范围是多少？

38

某计算机的字长为16位，数据用补码表示，存储器按字编址，访存指令格式为16位，其中5位操作码，3位寻址方式字段，分别表示立即寻址、直接寻址、间接寻址、变址寻址和相对寻址这5种，8位地址码字段。设PC和Rx分别为程序计数器和变址寄存器(其中Rx的位数为16位)

问：立即寻址的数据范围多大？

 各种寻址方式的寻址范围大小是多少？



下列关于各种寻址方式获取操作数快慢的说法中，正确的是

I . 立即寻址快于堆栈寻址

II. 堆栈寻址快于寄存器寻址

III. 寄存器间接寻址快于变址寻址

IV. 变址寻址快于间接寻址

11:21

39


MIPS指令系统



MIPS 指令集特点

定长指令，指令长度固定 4 字节

简单的load/store结构，内存中的数据访问严格4字节对齐

load/store结构：只有load/store类指令可以访问存储器

寻址方式简单，每条指令的操作也简单

易于流水线设计

易于编译器开发

MIPS寄存器

字长32位

32个通用寄存器

$0, $1, $2, … $30, $31

3个特殊寄存器

PC（程序计数器）

HI和 LO

HI乘积高32位(余数)，LO：乘积低32位（商）；

除了用在乘除法之外，也不能有做其他用途

硬件没有强制性的指定寄存器使用规则，但是在实际使用中，这些寄存器的用法都遵循一系列约定

MIPS里没有状态码，没有标志寄存器

32个通用寄存器



IA-32的寄存器组织

8个通用寄存器

两个专用寄存器

6个段寄存器

MIPS寻址方式

数据寻址方式

立即寻址

寄存器寻址

基址寻址

基址寄存器+偏移量

任一通用寄存器都可以作为基址寄存器

MIPS寻址方式

指令寻址

顺序寻址：PC=PC+4

PC相对寻址

PC = 偏移量左移两位+PC

伪直接寻址（跳跃寻址）

26位偏移量

PC = {PC[31..28],偏移量, 00 }

MIPS指令格式

OP

RS

Rt

shamt

Rd

6bits

funct

5bits

5bits

5bits

5bits

6bits

OP

RS

Rt

6bits

偏移量

5bits

5bits

16bits

OP

6bits

偏移量

26bits

R 型指令

I 型指令

J 型指令

Register format

Immediate format

Jump format

MIPS指令格式（R型指令）

主要是运算类指令

OP：操作码，所有R型指令OP为全0

Rs：第1个源操作数寄存器

Rt：第2个源操作数寄存器

Rd：存放结果的目的操作数寄存器

shamt：用于移位指令，指明移位次数

funct：功能码，对操作码进行补充

OP

RS

Rt

shamt

Rd

6bits

funct

5bits

5bits

5bits

5bits

6bits

R 型指令

MIPS指令格式 (R型指令)

寄存器寻址

汇编格式：op Rd, Rs, Rt

例：add$s1, $s2, $s3

指令编码：000000100101001110001 00000 100000

MIPS指令格式 (R型指令)

0x02538820



$s2 + $s3 = $s1

MIPS指令格式（I型指令）

L/S指令和分支指令

Rt：目的操作数寄存器

Rs 和 偏移量：源操作数

OP

RS

Rt

6bits

偏移量

5bits

5bits

16bits

I 型指令

汇编格式：op Rt, (偏移量)Rs

MIPS指令格式（I型指令）

三地址，RR型，立即数运算指令

Rs：第1个源操作数寄存器

Rt：目的操作寄存器

偏移量：第2个源操作数(立即数)

OP

RS

Rt

6bits

偏移量

5bits

5bits

16bits

I 型指令

汇编格式：op Rt, Rs, 偏移量

MIPS指令格式 (I型指令)

立即寻址

基址寻址

相对寻址

MIPS指令格式 (I型指令)

addi $21,$22,-50

op = 810

rs = 2210 (原操作数寄存器)

rt = 2110 (目的寄存器)

偏移量 = -5010 ,负数用补码表示

请写出指令的机器码

十进制指令格式:



二进制指令代码:

0x22D5 FFCE

十六进制指令代码:

MIPS指令格式（J型指令）

单地址指令

跳转指令，用一个26位的偏移量作为跳转的目标地址

OP

6bits

偏移量

26bits

J 型指令

汇编格式：op 偏移量

MIPS指令格式（J型指令）

伪直接寻址——跳转地址为指令中的26位偏移量与PC中的高4位拼接得到

	新的PC = {PC[31..28], 目标地址, 00 }

例：	j 10000

0x08002710

0000 1000 0000 0000 0010 0111 0001 0000

指令编码：

新PC

MIPS指令系统

（1）数据传送类：

（2）算术/逻辑运算类：

（3）控制类：

1、数据传送类：内存数据访问指令

读内存指令：lw lb lh （I型指令）

w:word	b:byte	h:half word

访问元素A[8]，A[0]保存在$t3		

lw$t0,32($t3) # 基址寻址

写内存指令：sw sb sh （I型指令）

$t0的数据保存到A[12]；			

sw$t0,48($t3)

2、算术/逻辑运算类：加减指令 

加法add （R型指令）

add $s4,$s1,$s2 #$s1+$s2=$s4	

减法sub （R型指令）

sub $s3,$s4,$s5 #$s4-$s5=$s3 		

 -20- 

2、算术/逻辑运算类：加减指令

如何编译下面的C语言表达式?

a = b + c + d - e;

编译成多行汇编指令

add $t0, $s1, $s2# temp = b + c

add $t0, $t0, $s3# temp = temp + d

sub $s0, $t0, $s4# a = temp - e

2、算术/逻辑运算类：加立即数

立即数相加指令 addi （I型指令）

addi $s3,$s3,4# $s3=$s3+4	

立即数传送

addi $s3,$zero,1# $s3=1 

寄存器间数据传送

add$s3,$s2,$0 # $s3=$s2

利用$zero($0)实现寄存器之间的数据传输



2、算术/逻辑运算类：逻辑运算

逻辑移位指令 sll、srl、sra （R型指令）

sll$s1,$s2,2 # $s2左移两位 

srl$s1,$s2,2 # $s2右移两位

逻辑运算 and/or/xor/addi/ori/xori （R型和I型指令）

and$t0,$t1,$t2 # t0=t1&t2

or $t0,$t1,$t2 # t0=t1|t2

andi $t0,$t1,100 # t0=t1&100

ori$t0,$t1,100 # t0=t1|100

3、控制类指令: 跳转指令

3、控制类指令

C语言条件判断指令

If(a==b)

 {i=1; } 

else 

 { i=2; }



等效C指令

If (a==b) goto L1;

 i=2;

 goto L2;

L1:i=1;

L2:



等效MIPS指令

 beq$s0,$s1,L1 

 addi $s3,$zero,2

 j L2; 

L1:addi $s3,$zero,1

L2:



 -25- 

等效MIPS指令

$s0 = a

$s1 = b 

$s3 = i

3、控制类指令:比较指令 sltslti

比较指令(slt:Set on Less Than)

slt reg1,reg2,reg3

如果reg2 < reg3, 则reg1 = 1

先比较，再分支

If ($s1<$s2) goto Less; 

slt $t0,$s1,$s2# $t0 = 1 if $s1<$s2

bne $t0,$0, Less # if $t0!=0 goto Less



 

 -26- 

循环结构

C语言简单循环结构，A为int数组

	do {

 g = g + A[i]; i = i + j;} while (i != h);

重写代码

	Loop:	g = g + A[i];		i = i + j;		if (i != h) goto Loop;

编译后的变量映射:

循环结构

最后编译的MIPS代码:

Loop: sll$t1,$s3,2# $t1= 4*iadd$t1,$t1,$s5# $t1=&A[0]+4ilw $t1,0($t1) # $t1=A[i]add$s1,$s1,$t1# g=g+A[i]add$s3,$s3,$s4# i=i+jbne$s3,$s2,Loop # if i!=h goto Loop 

原始C代码: Loop:g = g + A[i];	i = i + j;		 if (i != h) goto Loop;



循环结构

最后编译的MIPS代码:

Loop: sll$t1,$s3,2# $t1= 4*iadd$t1,$t1,$s5# $t1=&A[0]+4ilw $t1,0($t1) # $t1=A[i]add$s1,$s1,$t1# g=g+A[i]add$s3,$s3,$s4# i=i+jbne$s3,$s2,Loop # if i!=h goto Loop# 

原始C代码: Loop:g = g + A[i];	i = i + j;		 if (i != h) goto Loop;



MIPS 函数调用

C语言函数调用

int function(int a,int b) 

{return (a+b); }

MIPS实现函数调用的机制

返回地址寄存器$ra

参数寄存器	 $a0, $a1, $a2, $a3

返回值寄存器$v0 $v1

局部变量 $s0~$s7

堆栈指针 $sp



过程调用实现机制

sum(a,b);/* a,b:$s0,$s1 */}int sum(int x, int y)

 {return x+y;}



1000 add$a0,$s0,$zero# x = a1004 add$a1,$s1,$zero# y = b 1008 addi $ra,$zero,1016 # $ra=10161012 jsum 		# 调用函数sum1016 …2000 sum: add $v0,$a0,$a1 # 过程入口2004 jr $ra	 # new # 返回主程序instruction



过程调用实现机制

sum(a,b);/* a,b:$s0,$s1 */}int sum(int x, int y)

 {return x+y;}



1000 add$a0,$s0,$zero# x = a1004 add$a1,$s1,$zero# y = b 1008 addi $ra,$zero,1016 # $ra=10161012 jsum 		# 调用函数sum1016 …2000 sum: add $v0,$a0,$a1 # 过程入口2004 jr $ra	 # new # 返回主程序instruction



J1016

1008 jal sum

1012

过程调用机制

jal label #link and jump 

$ra=PC+4; #save next instruction address 

j Label

过程返回指令

jr $ra#return to main program



在32位MIPS体系结构下，最多可寻址4GB地址空间

0xFFFFFFFF

0xA0000000

0xC0000000

0xBFFFFFFF

0x80000000

0x9FFFFFFF

0x7FFFFFFF

0x00000000

MIPS 内存地址空间

数据通路流水线化



MARS

开源MIPS仿真器，汇编器

MIPSX86差异

4.5.3精简指令系统RISC

选取使用频率最高的一些功能实现，指令条数少

便于硬件实现，用软件实现复杂指令功能

指令长度固定，指令格式简单，寻址方式简单

只有存数/取数指令可以访问存储器(RS型)，其余指令的操作都在寄存器之间进行(RR型)

设置大量寄存器（32~192）

一个机器周期完成一条机器指令

RISCCPU采用硬布线控制，CISC采用微程序

CSIC与RISC互相融合

38

2010研究生统考例题

例. 某计算机字长为16位，主存地址空间大小为128KB，按字编址。采用单字长指令格式，指令各字段定义如图，转移地址采用相对寻址方式，相对偏移量用补码表示。寻址方式如图。



注(x)表示存储器地址x或寄存器x的内容

（1）该指令系统最多可有多少条指令？该计算机最多有多少个通用寄存器？存储器地址寄存器MAR和存储器数据寄存器MDR至少需要多少位？

2010研究生统考例题

注(x)表示存储器地址x或寄存器x的内容

（2）转移指令的目标地址范围是多少？

例. 某计算机字长为16位，主存地址空间大小为128KB，按字编址。采用单字长指令格式，指令各字段定义如图，转移地址采用相对寻址方式，相对偏移量用补码表示。寻址方式如表。



2010研究生统考例题

注(x)表示存储器地址x或寄存器x的内容

（3）若操作码0010B表示加法操作，助记符为add，寄存器R4，R5的编号分别为100B和101B，R4的内容为1234H，R5的内容为5678H，地址1234H中的内容为5678H，地址5678H中的内容为1234H，则汇编语句add(R4),(R5)+逗号前为源操作数，逗号后为目的操作数，对应的机器码是多少？用十六进制表示。该指令执行以后，哪些寄存器和存储单元的内容会发生改变？改变后的内容是什么？

例. 某计算机字长为16位，主存地址空间大小为128KB，按字编址。采用单字长指令格式，指令各字段定义如图，转移地址采用相对寻址方式，相对偏移量用补码表示。寻址方式如图。




MIPS仿真工具MARS 

MIPS汇编程序

汇编源程序由数据声明段和代码段组成。汇编程序文件以.s或.asm为后缀

数据声明 

以 .data开始，声明在代码中使用的变量、常量

在主存中创建了对应的空间    

代码段

以 .text开始，由指令构成的程序代码

代码以main: 开始。 

程序的注释 

使用#符号进行注释。  

MIPS汇编程序模板

# Title:	Filename:

# Author:	Date:

# Description:

# Input:

# Output:

###############数据段/Data segment #################

.data

 . . . #自定义的数据

###############代码段/Code segment ##################

.text

.globl main

main:	# main program entry

 . . . #自己写的代码

li $v0, 10	# Exit program

syscall

数据声明

格式： 

val_name: storage_type  value(s) 

创建一个以val_name为变量名，value(s)为初值，存储类型是storage_type的变量。  

变量名后要跟一个英文冒号

数据存储类型storage_type

.word， .half， .byte –字、半字、字节

.asciiz -字符串，以null结尾



var1: 	.word 3 			# var1为一个字变量，初值为	3，整数 

array1: .byte ‘a’,‘b’ 		# array1为两个元素的字节数	组，初值					# 分别为a和b的ASCII码 

array2: .space 40 		# 分配一块连续的内存区域，容量为40字节 

string1: .asciiz “Print this.\n” # 定义一个字符串 

汇编指令语句

代码部分的语句格式：

	[label:] mnemonic [operands][#comment]

Label: (标记)

标记一条指令在内存中的位置，以英文冒号结尾

Moemonic(助记符)

MIPS机器指令、汇编伪指令（比如add, sub,等)

Operands(操作数)

根据指令格式定义的操作数，可以是寄存器、内存变量、常量

	L1:	addiu $t0, $t0, 1	# $t0加1

系统调用(syscall)



1.取数、存数

################# code segment #####################

.data

value: .word 10, 20, 0

.text

.globl main

main:# main 入口

	la$t0, value # 将变量value的地址装入 $t0

		# la是伪指令

	lw$t1, 0($t0)# 将地址($t0+0)的字数据装入$t1

	lw$t2, 4($t0)# 将地址($t0+4)的字数据装入$t2

	add $t3, $t1, $t2# $t1 + $t2 = $t3

	sw$t3, 8($t0)# 将$t3中的数据存入地址($t0+8)



	li$v0, 10# 退出

	syscall

机器指令与汇编语言

伪指令

汇编器定义的，用于增强汇编程序可读性和提高编程效率

编译时，汇编器将伪指令翻译为一条或多条机器指令

汇编器建立符号表，以记录每个变量和标记的内存地址

例	符号表

	.DATA

	var1:.byte 1, 2,'Z'

	str1:.asciiz "My String\n"

	var2:.word 0x12345678

	.ALIGN3

	var3:.half 1000

符号表-symbol table 

Label

var1

str1

var2

var3

Address

0x10010000

0x10010003

0x10010010

0x10010018

2.读取并显示一个整数

################# code segment #####################

.text

.globl main

main:		# main program entry

	li	$v0, 5	# 5号功能调用，读取整数

	syscall	# $v0 = 读取的值



	move	$a0, $v0	# $a0 = 要显示的整数值

	li	$v0, 1	# 1号功能调用，显示整数

	syscall



	li	$v0, 10	# 退出程序

	syscall

MARS仿真步骤

点击工具栏 编译程序（快捷键F3）

运行（快捷键F5），“Run I/O”窗口显示并输出



程序运行结束，系统复位(F12)，重新开始

3.输入并显示字符串

################# Data segment #####################

.data

	str: .space10	# array of 10 bytes

################# Code segment #####################

.text

.globl main

main:		# main program entry

	la	$a0, str	# $a0 = address of str

	li	$a1, 10	# $a1 = max string length

	li	$v0, 8	# read string

	syscall

	li	$v0, 4	# Print string str 

	syscall

	li	$v0, 10	# Exit program

	syscall

4.三个整数相加（1/2）

# Input: 分别输入三个整数

#Output: 输出和

################### Data segment ###################

.data

prompt:	.asciiz "Please enter three numbers: \n"

sum_msg:	.asciiz "The sum is: "

################### Code segment ###################

.text

.globl main

main:

la$a0,prompt	# 显示提示字符串prompt

li$v0,4

syscall

li$v0,5	# 读第一个数到$t0

syscall

move$t0,$v0

4.三个整数相加（2/2）

li$v0,5	# 读第二个数到$t1

syscall

move$t1,$v0

li$v0,5	# 读第三个数到$t2

syscall

move$t2,$v0

addu$t0,$t0,$t1	# 累加	

addu$t0,$t0,$t2

la$a0,sum_msg	# write sum message

li$v0,4

syscall

move$a0,$t0	# 输出结果

li$v0,1

syscall

li$v0,10	# exit

syscall

运行结果

5.小写字母到大写转换(1/2)

# Objective: 小写字母转换到大写

# Input: 输入一个字符串.

#Output: 以大写形式输出.

################### Data segment #####################

.data

name_prompt:	.asciiz "Please type a string: "

out_msg:	.asciiz "Your name in capitals is: "

in_name:	.space 31	# space for input string

################### Code segment #####################

.text

.globl main

main:

la$a0,name_prompt	# print prompt string

li$v0,4

syscall

la$a0,in_name	# read the input string

li$a1,31	# at most 30 chars + 1 null char

li$v0,8

syscall



5.小写字母到大写转换(2/2)

la$a0,out_msg# write output message

li$v0,4

syscall

la$t0,in_name#t0为输入字符串的首地址

loop:

lb$t1,($t0)# load一个字节

beqz$t1,exit_loop# if t1 = 0, 退出循环

blt $t1,‘a’,no_change# t1 < ‘a’ ,表示大写，处理下一个字符

bgt $t1,‘z’,no_change# t1 > ‘z’ ,表示非字母字符，处理下一个字符

addiu $t1,$t1,-32# ‘a’<t1<‘z’ 小写转大写: 'A'-'a'=-32

sb$t1,($t0)	#保存于字符原位置

no_change:

addiu $t0,$t0,1# t0指向下一个字符

j loop

exit_loop:

la$a0,in_name# 输出转换完成的大写字符串

li$v0,4

syscall

li$v0,10 # exit

syscall




第五章 中央处理器

本章讨论CPU的功能组成，控制器的工作原理和实现方法，微程序控制原理，基本控制单元的设计以及先进的CPU系统设计技术

1

返回

第五章 中央处理器

5.1 CPU功能和组成

5.2 指令周期

5.3 时序产生器和控制方式

5.4 微程序控制器

5.5 硬布线控制器



5.6 流水CPU

5.7 RISC CPU



2



3

5.1CPU的功能和组成

5.1.1 CPU的功能

冯.诺依曼的“存储程序、程序控制”

用计算机解决某个问题时，首先编写程序

程序是一个指令序列，这个序列明确告诉计算机

应该逐步执行什么操作（操作码）

在什么地方找到用来操作的数据，结果存到何处（地址码）

4

5.1.1 CPU的功能

计算机进行信息处理的过程可分为两步：

①将程序和数据装入存储器；

②从程序入口开始取指令，执行指令，得到所需结果，然后结束运行

中央处理器是控制计算机自动完成取出指令和执行指令任务的部件

计算机的核心部件，简称为CPU（Central Processing Unit）

5.1.1 CPU的功能

指令控制：

保证控制器按顺序执行程序

操作控制

管理并产生一系列操作信号，将它们送往相应的部件

时间控制：

对各种操作实施时间上的定时

数据加工：

对数据进行算术和逻辑运算

5

6

5.1.2 CPU的基本组成

早期的CPU由运算器和控制器两大部分组成

现在将外围的一些逻辑功能部件纷纷移入CPU，使CPU的组成越来越复杂

7

8



9

运算器

数据加工处理部件

组成

ALU、通用寄存器、DR和PSW

主要功能

执行算术运算

执行逻辑运算



10

控制器 

协调和指挥整个计算机系统的操作

组成

PC、IR、指令译码器、时序发生器和操作控制器



功能

(1) 从指令Cache中取出一条指令，生成下一条指令在指令Cache的位置；

(2) 对指令进行译码，产生相应的操作控制信号

(3) 控制CPU、内存和输入/输出设备间的数据流动

11

5.1.3 CPU中的主要寄存器

在CPU中主要有以下六类寄存器

1. 数据寄存器（DR-Data Register）

2. 指令寄存器（IR-Instruction Register）

3. 程序计数器（PC-Program Counter）

4. 数据地址寄存器（AR-Address Register） 

5. 通用寄存器（R0~R3 –General Register）

6. 状态字寄存器（PSW-Program Status Word）

1. 数据寄存器（DR）

暂时保存要写入寄存器的数据

12



　　

2. 指令寄存器（IR）

Instruction Register

保存当前正在执行的指令内容



OP字段的输出作为指令译码器的输入

　　

3. 程序计数器（PC）

Program Counter

保存下一条指令的地址

在程序开始执行前必须将起始地址(入口地址)送入PC

修改PC的内容

顺序寻址：PC = PC+常量；

常量与指令长度有关

相对寻址：PC = PC+偏移量

跳跃寻址：PC = 偏移量

X86：EIP MIPS：PC



4.数据地址寄存器（AR） 

保存访问数据Cache的地址

本例中为保持访问数据Cache单元的地址



5. 通用寄存器

模型中有4个通用寄存器（R0~R3）

作为ALU的数据源和目的寄存器

用作地址指示器、变址寄存器、堆栈指示器等



6. 状态字寄存器（PSW）

一个由各种状态标志拼凑而成的寄存器

模型机中的PSW由ALU的运算结果设置

还保存中断和系统工作状态等

X86： FLAGS MIPS：无



18

5.1.4 操作控制器和时序发生器

数据通路 ：

部件之间传送信息的通路

操作控制器在各部件之间建立数据通路

操作控制器

根据指令OP码和时序信号，生成各种操作控制信号，以便正确地建立数据通路，从而完成取指令和执行指令的控制



19

5.1.4 操作控制器和时序产生器

操作控制器分为

硬布线控制器，采用时序逻辑技术实现

微程序控制器，采用存储逻辑实现



时序产生器

产生并发出计算机所需要的时序信号

对各种控制信号实施时间上的控制

20

5.2 指令周期

指令周期的基本概念

MOV、的指令周期

LAD指令的指令周期

ADD指令的指令周期

STO指令的指令周期

JMP指令的指令周期

用方框图语言表示指令周期

指令格式设计-编码

操作码位数

地址码位数：双地址码、单地址码

偏移量、寄存器位数

数据寻址方式

直接寻址、寄存器寻址、寄存器间接寻址

指令寻址方式

顺序寻址、跳跃寻址

不设定寻址特征位，由操作码默认指定寻址方式

21

5.2.1指令周期的基本概念

运行程序

第一步：从内存中取一条指令

第二步：执行该指令

周而复始



23

5.2.1指令周期的基本概念

上述步骤所需时间

从内存取出一条指令的时间：取指周期

分析并执行这条指令的时间：执行周期

指令周期=取指周期+执行周期

从内存取出一条指令、分析并执行这条指令的时间总和

指令功能不同，其指令周期不同

24

5.2.1指令周期的基本概念

一个指令周期划分为若干CPU周期

CPU周期又称机器周期

通常指从内存读一个字的最短时间

取指周期包含若干CPU周期

执行周期包含若干CPU周期

功能不同的指令，可能包含不同数目的CPU周期

25

5.2.1指令周期的基本概念

一个CPU周期包含若干时钟周期

时钟周期：T周期、节拍脉冲

处理操作的最基本时间单位

ALU完成一次正确的运算

寄存器间的一次数据传送等

相互关系： 

            1个指令周期 = 取指周期+执行周期

 =若干个CPU周期 

            1个CPU周期 = 若干时钟周期 

26

5.2.1指令周期的基本概念

指令周期=取指周期+执行周期

取指周期=1个CPU周期

执行周期=1个CPU周期

1CPU周期=4个 T周期

单周期CPU和多周期CPU

单周期CPU

在一个CPU周期内完成从取指、译码到执行的所有工作

效率低

多周期CPU

把指令执行周期分成多个阶段，每个阶段在一个CPU周期完成

容易流水线执行，效率高

27

简单定义一个指令集

6条指令，单字长，字长为1B，4个寄存器

MOV		寄存器数据传输 	RR型

LAD/STO 	取数/存数		RS型

ADD/AND 	加法/与	 	RR型

JMP 		转移 			RS型



28

简单定义一个指令集

指令寻址方式

顺序寻址：PC+1

跳跃寻址：PC=偏移量

数据寻址方式

直接寻址：EA=偏移量

寄存器寻址： EA=R

寄存器间接寻址：EA=(R)



29

指令格式设计

操作码（OP）定义

6条指令：MOV/LAD/STO/ADD/AND/JMP 

30

MOV

寄存器寻址 双地址码，功能：Rs -> Rd

LAD



直接寻址，功能：(A)->Rs

STO



寄存器间接寻址， Rs ->(Rd)

指令格式设计(类MIPS)

31

JMP

跳跃寻址	A->PC



ADD

寄存器寻址Rs + Rd -> Rd



AND

寄存器寻址Rs & Rd -> Rd

指令格式设计

32

一个小程序

33

一个小程序

34

六条典型指令组成的简单程序示例

35

程序运行到105地址时，各寄存器的值是多少？

36

如何设计指令周期

前提：

掌握每个指令要执行的操作

识别出各个部件的控制命令

两个阶段

取指阶段、执行阶段

两个步骤

找出数据通路：数据从哪里来，经过哪些部件，最终达到哪里

确定操作信号：形成上述数据通路所需的操作控制信号

37

图5.1的结构

控制信号

总线三态门：C1、C2、C3

存储器：数据Cache 读/写(RD(D))、指令Cache读(RD(I))

寄存器：每个寄存器都有输入和输出控制信号

输入控制信号：PCin、 Riin，DRin等

输出控制信号：PCout、 Riout等

PC：PC+1

ALU：加、与、传送

38

39



DCache读/写

ICache读

+\&\M

DRin

PCout

PCin

ARin

Riout

Riin

IRin

如何设计指令周期

时间设计：各个操作在哪个时钟周期发生

取指周期=？CPU周期

执行周期=？CPU周期

1个CPU周期定义

从内存读/写一个数据

或使用共享总线传输一个数据，总线只能有一个源

一个CPU周期内数据不能产生冲突

图5.1中

IBUS是独占的、DBUS是共享的

1个CPU周期包括4个T周期：T1~T4

40


指令周期

从内存取出一条指令、分析并执行这条指令的时间总和

指令周期=取指周期+执行周期= 若干个CPU周期 

            1个CPU周期 = 若干时钟周期 



1

如何设计指令周期

前提：

掌握每个指令完成的功能，要执行的操作

识别出各个部件的控制命令

分两个阶段

取指阶段、执行阶段

三个步骤

1. 找出数据通路：数据从哪里来，经过哪些部件/总线，最终达到哪里

2. 确定操作信号：形成上述数据通路所需的操作控制信号

3. 分配CPU周期

2

如何设计指令周期

分配CPU周期：各个操作信号在哪个CPU周期发出

取指周期=？CPU周期

执行周期=？CPU周期

1个CPU周期定义

从内存读/写一个数据

或使用共享总线传输一个数据，总线只能有一个源

一个CPU周期内数据不能产生冲突

3



4

4



DCache读/写

ICache读

+\&\M

DRin

PCout

PCin

ARin

Riout

Riin

IRin

IBUS是独占的、DBUS是共享的

1个CPU周期包括4个T周期：T1~T4

5.2.2 MOV指令的指令周期

MOV R0,R1

单字长，RR型

取指阶段：

数据通路：从指令Cache中取出指令经过IBUS写入IR

PCABUS(I)ICacheIBUSIR

操作控制：形成上述数据通路的控制信号

PC内容输出到指令Cache

指令Cache读操作，通过IBUS写入IR

PC+1，为取下一条指令做好准备

对IR中的OP译码，以确定进行什么操作

5

PCout

IRin

ICache读



6

5.2.2 MOV指令的指令周期

1. 取指周期：完成三件事

从指令Cache取出指令到IR

PC+1，为取下一条指令做好准备

对IR中的OP译码，以确定进行什么操作

2. 执行周期

将数据从R1传送到R0

由于操作简单，只需要一个CPU周期



7

PC中装入第一条指令地址101；

101

8

101

① PC的内容被放到ABUS（I）上，指令Cache进行译码，发出读命令；

101



R



②从101号地址读出的MOV指令通过IBUS装入IR；

③PC+1，变成102，为取下一条指令做好准备；



102

④ 对IR中的OP译码，识别出是MOV指令，取指阶段即告结束



MOV指令的取指阶段

9

5.2.2 MOV指令的取指周期

操作

PC内容输出到指令Cache

读指令Cache取出，指令写入IR

PC+1；

对IR中的OP译码

时间

访问内存取一条指令，需要1个CPU周期

10

MOV指令的执行周期

将数据从R1传送到R0

(1) OC送出控制信号到通用寄存器，选择R1做源寄存器，选择R0作目标寄存器；

(2) OC送出控制信号到ALU，指定ALU做传送动作；

(3) OC送出控制信号，打开ALU输出三态门C1，将ALU输出送到DBUS上；

(4) OC送出控制信号，将DBUS上的数据打入到DR

(5) OC送出控制信号，将DR中的数据打入R0，R0的内容由00变为10至此，MOV指令执行结束

11

MOV指令的执行阶段



M

DRin

Riout

Riin

5.2.2 MOV指令的指令周期

MOV R0,R1

单字长，RR型

执行阶段：

数据通路：寄存器R1的数据传输到R0

R1ALUDBUSDRR0

操作控制：形成上述数据通路的控制信号

选择R1做源寄存器，指定ALU做传送动作

打开ALU输出三态门C1，将ALU输出送到DBUS上

将DBUS上的数据写入到DR

将DR中的数据写入R0，R0的内容由00变为10



12

13

① OC送出控制信号到通用寄存器，选择R1做源寄存器，指定ALU做传送操作

M

10

② OC送出控制信号，打开C1，将ALU输出送到DBUS上



③ 将DBUS上的数据10打入到DR；

④将DR中的数据打入到R0，R0的内容由00变为10

MOV指令的执行周期

DRin

R1out

R0in

MOV指令的执行周期

操作

(1) 选择R1做源寄存器，指定ALU做传送动作；

(2) 打开ALU输出三态门C1，将ALU输出送到DBUS上；

(3) 将DBUS上的数据写入DR

(4) 将DR中的数据写入R0

时间：使用一次共享总线DBUS，需要1个CPU周期

14

15

5.2.2 MOV指令的指令周期

1. 取指 



2. 执行



16

5.2.2 MOV指令的指令周期（简化）

1.取指 



2. 执行



只考虑一个CPU周期内的操作

17

5.2.2 MOV指令的指令周期（再简化）



5.2.2 MOV指令的指令周期

MOV R0,R1

取指周期

1个CPU周期

执行周期

1个CPU周期

18

5.2.3 LAD指令

LAD R1,6

单字长，RS型

取指阶段

同MOV指令相同

执行阶段

数据通路：访问内存地址6的单元，取出数据写入R1

IRARABUS(D)DBUSDRR1

19

20

控制信号：

打开C3，将地址码6放到DBUS上；

将地址码6装入AR，数存进行地址译码；

读数存6号单元，数100读出到DBUS上；

将DBUS上的数据100写入DR；

将DR中的数据100写入R1



ARin

DCache读

DRin

R1in

21

LAD指令的执行周期

控制信号：

打开C3，将地址码6放到DBUS上；

将地址码6装入AR，DCache进行地址译码；

读数存6号单元，数100读出到DBUS上；

将DBUS上的数据100写入DR；

将DR中的数据100写入R1

22

LAD指令的执行周期

时间设计：

序号1和2，访问一次内存并使用DBUS，需要1个CPU周期

序号3、4和5，使用一次DBUS，需要1个CPU周期

23

LAD指令的执行周期（简化）



5.2.3 LAD指令的指令周期

24



5.2.3 LAD指令的指令周期

LAD R1,6

单字长

RS型

25

取指令

PC+1

译码指令



取出

操作数

取下条

指令PC+1



取指周期



开始



执行周期



装入通用

寄存器



5.2.3 LAD指令的指令周期

LAD R1,6

单字长

RS型

26

取指令

PC+1

译码指令



取出

操作数

取下条

指令PC+1



取指周期



开始



执行周期



装入通用

寄存器



5.2.5 ADD指令的指令周期

ADD R1,R2

单字长，RR型

执行阶段



27

28

OC送出控制信号到通用寄存器，选择R1和R2做源寄存器

100

20

OC送出控制信号到ALU，指定ALU做加法

120

打开C1，将运算结果120输出送到DBUS上



OC送出控制命令，将DBUS上的数据打入到DR

120

OC送出控制命令，将120装入R2，R2的内容由20变为120

ADD指令的执行

R1out

R2out

+

DRin

R2in

29

ADD指令的执行

数据通路

R1→ALU、R2→ALU，ALU→DBUS→DR→R2

操作控制

(1) 选择R1和选择R2，R1和R2加法操作

(3) 打开三态门C1，将运算结果120输出送到DBUS；

(4) 将DBUS上的数据打入DR；

(5) 将DR中的数据120写入R2，R2的内容由20变为120

30

ADD指令的执行周期

(1) 选择R1和R2输出到ALU，指定让ALU做加法操作；

(2) 打开C1，运算结果120输出送到DBUS；

(3) DBUS上的数据写入DR；

(4) DR中的数据写入R2

时间：占用一次DBUS总线，1个CPU周期

31

5.2.2 ADD指令的指令周期



5.2.5 ADD指令的指令周期

ADD R1,R2

单字长

RR型

取指周期：1个CPU周期

执行周期：1个CPU周期

32



5.2.5 STO指令的指令周期

STO R2,(R3)

单字长、RS型

执行阶段

数据通路：R3通过DBUS到AR，数据Cache地址译码，R2的内容通过Dbus写入数据Cache

33

21:16

34

（1）OC送出操作命令到通用寄存器，选择R3；



STO指令的执行

R3out

35

（2）OC送出命令, 打开C2，将地址30放到DBUS上；

30



STO指令的执行

36

（3）OC发出操作命令，将30装入AR，数存开始地址译码



30

30

STO指令的执行

ARin

37

（4）OC发出命令到通用寄存器，选择R2



30

STO指令的执行

R2out

38

（5）OC发出操作命令，打开三态门C2，将数据120放到DBUS上；



120

120



30

STO指令的执行

39

 （6）OC发出命令，将数据120写入30号单元，它原先的数据40被覆盖



30

120

STO指令的执行

DCache写

40

STO指令的执行

(1) 选择R3，打开三态门C2，将地址30放到DBUS上；

(2) 地址30装入AR；

(3) 选择R2 ，打开三态门C2，将数据120放到DBUS上；

(4) 将数据120写入数存30号单元

时间：使用两次DBUS，需要两个CPU周期

21:05

5.2.5 STO指令的指令周期

41

5.2.5 STO指令的指令周期

21:05

42

STO R2,(R3)

单字长

RS型

3个CPU周期

5.2.6 JMP指令的指令周期

JMP 101

无条件转移指令，改变程序的执行顺序

单字长、单地址

执行阶段

数据通路：IP中的101通过DBUS到达PC

操作控制

43

21:05

44

（1）打开三态门C3，将IR中的地址码101发送到DBUS上



JMP指令的执行

45

（2）将DBUS上的地址码101打入到PC中，PC中原先的内容106被覆盖

JMP指令的执行

PCin

46

5.2.6 JMP指令的执行周期

(1) 打开C3，地址码101发送到DBUS

(2) DBUS上的地址码101写入到PC

时间：占用一次总线，需要1个CPU周期

21:05

47

5.2.6 JMP指令的指令周期

5.2.6 JMP指令的指令周期

JMP 101

2个CPU周期

21:05

48

5.2.7 指令周期

49

5.2.7 指令周期

50

5.2.7 用方框图语言表示指令周期

采用方框图（指令流程图）来表示指令周期

一个矩形框代表一个CPU周期

矩形框中的内容表示数据通路

矩形框右边写出控制信号

菱形框表示判断或测试

时间上依附于前一个方框的CPU周期，不独占一个CPU周期

公操作符号“～”

一条指令执行完毕后CPU进行的一些共性操作，中断请求、DMA请求等

51

21:05

5.2.2 指令周期

52

译码

PCout,,IRin,PC+1

PCIR

5.2.7方框图表示指令周期

由上图可见，对于图5.1的模型机

所有指令的取指周期是完全相同的，而且是一个CPU周期。

在执行周期，由于各条指令的功能不同，所用的CPU周期也是各不相同

MOV、ADD、JMP指令是一个CPU周期

LAD、STO指令是两个CPU周期，需要访问内存

53

21:05

R1i

R1o

R2o

R2i

例1的数据通路图

R1i

R1o

R2o

R2i

画出下面指令的指令周期流程图，假设该指令的地址已放入PC中。列出相应的微操作控制信号序列

“ADD R2，R0”指令完成(R2)+(R0)→R0的功能

(2) “SUB R1，R3”指令完成(R3)-(R1)→R3的操作

基本步骤

取指周期

写出取指周期数据通路

PC xxxx IR

写出的控制信号形成上述数据通路

要记得PC+1

设定操作控制信号的时间

使用一次总线或访问一次内存为一个CPU周期

根据经验

执行周期

根据执行周期要完成的操作写出数据通路

具体指令具体分析，依据具体功能

写出形成上述数据通路的控制信号

设定操作控制信号的时间

RS型指令需要更多的CPU周期

56

取指周期(ADD R2，R0)

数据通路：PCBGA AR M DR B G A IR

57

取指周期(ADD R2，R0)

数据通路：PCBGA AR M DR B G A IR

控制信号： PCo、 G、ARi RDRo，G、 IRi

58

取指周期(ADD R2，R0)时间分配

数据通路：控制信号

PCBGAAR	：PCo、G、ARi 	（1个CPU周期）

M DR		：R			 （1个CPU周期）

DRB G AIR	：DRo，G、 IRi	 （1个CPU周期）

59

取指周期(ADD R2，R0)

60

PCAR	

PCo、G、ARi

M  DR

R

DRIR	

DRo，G、 IRi ，PC+1



ADD指令

执行周期(ADD R2，R0)

ADD R2，R0”指令完成(R2)+(R0)→R0的功能

数据通路：

R2BGA X； R0BGA Y； ALUBGAR0

61

执行周期(ADD R2，R0)

ADD R2，R0”指令完成(R2)+(R0)→R0的功能

数据通路：控制信号

R2BGA X: R2o，G、 Xi

R0BGA Y: R0o，G、 Yi

ALUBGAR0: +，ALUo，G、 R0i

62

执行周期(ADD R2，R0)时间分配

ADD R2，R0”指令完成(R2)+(R0)→R0的功能

数据通路：控制信号

R2BGA X: R2o，G、 Xi	 （1个CPU周期）

R0BGA Y: R0o，G、 Yi	（1个CPU周期）

ALUBGAR0: +，ALUo，G、 R0i （1个CPU周期）

63

执行周期(ADD R2，R0)

64

R2 X

R2o，G、 Xi

R0 Y

R0o，G、 Yi

ALUR0

+，ALUo，G、 R0i



65

 (1)“ADD R2，R0”指令是一条RR型加法指令

图的右边部分标注了每一个机器周期中用到的微操作控制信号序列。

ALU0

R0

66

(2)“SUB R1，R3” 在执行阶段，微操作控制信号序列与ADD指令有所不同。

ALU0


5.3时序产生器和控制方式

5.3.1 时序产生器作用和体制

5.3.2 时序信号产生器

5.3.3 控制方式

1

11:23

2

5.3.1 时序产生器作用和体制

计算机的协调动作需要时间标志，而时间标志则是用时序信号来体现

用时序信号辨认从内存中取出的是指令还是数据，是取指周期还是执行周期

一个CPU周期中时钟脉冲对CPU的动作有严格的约束

操作控制器发出的各种信号是时间（时序信号）和空间（部件操作信号）的函数

11:23

数据：电位

控制信号：脉冲

5.3.1、时序产生器作用和体制

时序信号的基本体制是电位—脉冲制（以触发器为例）

电位：用电平的高低进行控制

脉冲：用信号的边沿进行控制

11:23

3

在微程序控制器中，采用节拍电位-节拍脉冲二级体制

时序信号产生电路简单

一个CPU周期称为一个节拍电位

4

5.3.1、时序产生器作用和体制



Φ

T1

T2

T3

T4



节拍电位

节拍脉冲

11:23



C1

C2

在微程序控制器中，采用节拍电位-节拍脉冲二级体制

时序信号产生电路简单

一个CPU周期称为一个节拍电位

5

5.3.1、时序产生器作用和体制



Φ

T1

T2

T3

T4



CPU周期



CPU周期

节拍电位

节拍脉冲

11:23

硬布线控制器中，时序信号往往采用状态周期-节拍电位-节拍脉冲三级体制

时序信号产生电路复杂

状态周期是电位信号，指明当前指令处于哪个状态

比如，一个指令的状态周期包括取值周期和执行周期两个状态，取指周期包括1个CPU周期，执行周期包括2个CPU周期

6

5.3.1、时序产生器作用和体制

11:23



Φ

T1

T2

T3

T4



CPU周期



CPU周期

节拍电位

节拍脉冲

状态周期

状态周期-节拍电位-节拍脉冲三级体制

11:23

7



取指周期

执行周期



C1

C2

C3

8

5.3.2、时序信号产生器

时钟源:

石英晶体振荡器

环形脉冲发生器

节拍脉冲

启停控制逻辑

本书模型机启动时，一定要从T1前沿开始；

停机时一定要在T4结束后关闭时序产生器



11:23

9

1. 时钟源

时钟源用来为环形脉冲发生器提供频率稳定且电平匹配的方波脉冲信号

它通常由石英晶体振荡器和与非门组成的正反馈振荡电路组成，其输出为一个理想的方波

11:23

2、环形脉冲发生器



C4

C1

C2

C3

Φ

作用：产生一组有序间隔相等或不等的脉冲序列

11:23

10

3、节拍脉冲

11

11:23

3、节拍脉冲

12

11:23

3、时序信号举例

MOVR0 R1

该指令的取指周期的需要一个节拍电位，即一个CPU周期，

操作信号的节拍脉冲划分为：

PC->ABus(I)：T1

IBus->IR：T2

IR中OP->指令译码器：T3

11:23

13

3、时序信号举例

MOVR0，R1

该指令的执行周期需要一个节拍电位

操作信号的节拍脉冲划分为：

设置ALU完成传送操作：T1

R1->ALU：T2

DBus->DR：T3

DR->R0：T4

在一个节拍电位中完成四个有时序关系的操作

11:23

14

11:23

15



T1

T2

T3

T4



CPU周期

节拍脉冲

DBus->DR：T3

 信号来自译码器，持续一个节拍电位时间



4、节拍脉冲和读/写时序

16



11:23

17

节拍脉冲

节拍电位

11:23

4.启停控制逻辑

启动、停机具有随机性

当计算机启动时，一定要从节拍点位T1前沿开始工作

停机时一定要在节拍点位T4结束后关闭时序产生器

18

11:23

5.3.3控制方式

指令周期由若干个CPU周期组成

每条指令所需的时间各不相同

每个操作控制信号所需的时间及出现的次序各不相同

形成控制操作序列的方法，称作控制器的控制方式

有同步控制、异步控制、联合控制三种方式

19

11:23

1. 同步控制方式

CPU周期数固定、时钟周期数固定

节拍电位数固定，节拍脉冲数固定

与指令功能、操作复杂度、操作数类型无关

设计时固定，与指令的执行无关

具体方案：

(1) 采用统一的CPU周期

(2) 采用不定长CPU周期

(3) 中央控制与局部控制结合

大部分采用统一CPU周期，个别指令采用不定长CPU周期

20

11:23

21

2. 异步控制方式

CPU周期数可变、时钟周期数可变

可变：在指令执行时变化

每条指令的指令周期所需的CPU周期数不等

需要多少时间就占用多少时间

反馈机制：执行部件完成操作后发“回答”信号

11:23

22

3. 联合控制方式 

同步控制和异步控制相结合的方式

两种实现方法

1. 大部分指令同步控制，少数操作采用异步方式

2. CPU周期数可变、时钟周期数固定

11:23

5.4微程序控制器

英国剑桥大学的M·V·Wilkes教授于1951年首先提出

1964年，IBM公司在IBM 360系列机上成功地采用了微程序设计技术

20世纪70年代以来，由于VLSI技术的发展，推动了微程序设计技术的发展和应用

目前，x86系列几乎都采用微程序设计技术，ARM采用微程序和硬连线相结合

23

11:23

24

5.4微程序控制器

微程序控制（microprogramming control）基本思想

把操作控制信号编制成微指令，存放到只读存储器（控制存储器）里；

运行时，从控存中取出这些微指令，从而产生所需的各种操作控制信号

微程序设计技术是用软件方法来设计硬件

11:23

5.4.1微程序控制原理 

1微命令和微操作

部件分为两种：控制部件和执行部件



微命令：控制部件通过控制线向执行部件发出的控制命令

微操作：执行部件接受微命令后所进行的操作

微操作在执行部件中是最小、最基本的操作

25

11:23

1.微命令和微操作

微命令和微操作一一对应

控制门电位信号的变化、寄存器输入端的控制、ALU的基本执行过程…

微操作可分为相容和互斥两种：

互斥：是指不能同时或不能在同一个CPU周期内并行执行的微操作

相容：是指能够同时或在同一个CPU周期并行执行的微操作

26

11:23

27

（+，-，M）在同一个CPU周期中只能选择一个，因而是互斥的微命令

类似地，4，6，8也是互斥的

微命令1，2，3是可以同时进行的，所以是相容的微命令

X输入控制4，6，8和Y输入的5，7，9中任意两个微命令也是相容的

11:23

28

2微指令和微程序

微指令(Micro-instruction) ：在一个CPU周期中，一组实现一定操作功能的微命令的组合

在同一CPU周期内并行或并发执行的微命令的组合

微指令存储在控制器中的控制存储器中



11:23

2微指令和微程序

微程序

一系列微指令的有序集合就是微程序

一段微程序对应一条机器指令

微地址：存放微指令的控制存储器的单元地址

机器指令-》微程序-》微指令-》微命令-》微操作

以简单运算器通路图的微指令格式为例：



29

11:23



30

11:23

PC+1

LDIR

LDAR

LDDR

RD



31

2. 微指令和微程序

微指令格式举例



微指令字长为23位，由操作控制和顺序控制两大部分组成



11:23

2. 微指令和微程序

操作控制字段，发出控制信号

每一位表示一个微命令

某一位为1表示发出相应的微命令，为0不发出

32



11:23

33

5.4.2微指令和微程序

顺序控制字段，产生下一条微指令的地址（微地址）

后四位：直接微地址

P1P2：判断测试标志

P1P2=00：使用后四位直接微地址

P1P2=01：P2测试

条件满足，新微地址=直接微地址

条件不满足，新微地址=对直接微地址修改

P1P2=10：P1测试



11:23

3.微程序控制器原理框图

它主要由控制存储器、微指令寄存器和地址转移逻辑三大部分组成



34



AR 

11:23

(1)控制存储器(CM：Control Memory)

CM是微程序控制器的核心部件

存放微程序

只读存储器

CM的字长是微指令字的长度

字数=微指令数量

存储容量=微指令字的长度 X 微指令数量

35



11:23

控制存储器

用于存放微程序

控制存储器与主存对比



11:23

36

（2）微指令寄存器(μIR)

微地址寄存器和微命令寄存器组成

微地址寄存器μAR ：下一条微指令的微地址

微命令寄存器：微指令的操作控制字段和判别测试字段

37



11:23

（3）地址转移逻辑

修改微地址

根据IP中的OP字段译码产生微地址（入口微地址）

顺序控制字段中的直接微地址给出下一条微指令的地址

通过判别测试字段P和执行部件的反馈信息，形成新的微地址

38



11:23

4微程序举例

假设在某编程环境下，需要完成BCD码加法运算，代码：b = b + a

假定该代码的汇编语言是

 

 

b-》R2，a-》R1

对于该指令，共耗费3~4个CPU周期(异步控制)

指令:ADDBR2R1

11:23

39

40

十进制加法指令周期流程图

取指令

a+b运算

a+b+6运算

减6运算

P1测试，表示译码操作，用OP字段作为形成微指令的地址

加法运算

P2测试，用Cy的状态来修改微地址寄存器的最后一位



本条微指令

的微地址

默认后继微地址

11:23

4.微程序举例

一条微指令对应一个方框

微指令周期等于一个CPU周期

一个方框对应与一个CPU周期

指令流程图中有多少方框意味着该指令对应的微程序包含多少条微指令

41

11:23

第一条是取指微指令，要发出的微命令是

LDIR、PC+1，LDAR

P1译码测试



4.微程序举例

42

00000000000000

10

0000



111

11:23

4.微程序举例

第二条微指令的二进制编码是



 第二条微指令发出的微命令是

R1X，R2  Y，+，LDR2`



11:23

43

4.微程序举例

第三条微指令的二进制编码是



 第三条微指令发出的微命令是

R2  X，R3  Y，+，LDR2`

P2判断测试



11:23

44

4.微程序举例

第四条微指令的二进制编码是



 第四条微指令发出的微命令是

R2  X，R3  Y，-，LDR2`



11:23

45

0000



1001

0000



00000000000011110 

01000100100100000 00

微程序存放示意图

顺序控制

地址

…

…



1101



1100



1011

1010

1001

…

…



0010

0001

0000

0000

操作控制字段

…



01010010010000000

01000100110000000 

…



控制存储器CM

取指微指令

R2-R3->R2 微指令



R2+R3->R2 微指令

R1+R2->R2 微指令



…

指令:ADDBR2R1



01

00

00

10

11:23

46



执行微程序

一条机器指令的微程序由取指微程序和执行微程序组成

微程序存放

图5.1的主存

控存CM

11:23

47

微程序控制器的工作过程

(1)取指微程序执行取指周期的操作

PCIR，PC+1

译码：OP字段输出到地址转移逻辑，产生对应的执行微程序的入口地址，送入μAR



11:23

48



微程序控制器的工作过程

(2)根据μAR从CM中取出微指令，并产生下一条微指令的地址送入μAR 



11:23

49



微程序控制器的工作过程

(3) 执行微程序的最后一条微指令执行完毕后，将μAR设为取指微程序的入口地址，从而返回第(1)步

周而复始，直到所有机器指令执行完毕



11:23

50

51

5. CPU周期和微指令周期的关系

一个微指令周期与CPU周期时间相等



T1, T2, T3时间执行微指令(如运算等)

T4上升沿打入结果至寄存器

T4时间读取微指令



11:23

6. 机器指令与微指令的关系

一条机器指令对应一段微程序

一段微程序由若干条微指令组成

一个微指令包含多个微命令

机器指令、程序和地址与内存有关

微指令、微程序和微地址与控制存储器有关

52



11:23

53

　　　写控制

　　　　读控制



选择

WA1

WA0

　W

选择

RA1

RA0

　R



不写入

　*

　*

　0

不读出

　*

　*

　0

　R3

　1

　1

　1

　R3

　1

　1

　1

　R2

　0

　1

　1

　R2

　0

　1

　1

　R1

　1

　0

　1　

　R1

　1

　0

　1

　R0

　0

　0

　1

　R0

　0

　0

　1



 例 设某计算机运算器框图如图所示，其中ALU为16位的补码加法器，SA,SB为16位暂存器，4个通用寄存器的读、写控制功能见下表 

11:23

机器采用微程序控制方式，微指令操作控制字段格式如下(未考虑顺序控制字段)：

11:23

54

要求：写出如下指令执行周期微程序的编码： 

 (1)“ADD R0，R1”指令，即(R0)+(R1)→R1

 (2)“SUB R2，R3”指令，即(R3)-(R2)→R3

 (3)“MOV R2，R3”指令，即(R2)→(R3)

11:23

55

 2.写出微程序：

00**10100000

01**10010000

**0101001001



1. 画出ADD R0，R1指令的流程图

RA0RA1=00

R

LDSA

LDSB

RA0RA1=01

R

SB-ALU

WA0WA1=01

W

~

11:23

56

57

 2.写出微程序：11**10100000

10**10010000

**1101000101

1. 画出SUB指令的流程图

RA0RA1=11

R

LDSA

LDSB

RA0RA1=10

R

WA0WA1=11

W

~

11:23

58

 2.写出微程序： 10**10100000

**1101001011

1. 画出MOV指令的流程图

RA0RA1=10

R

LDSA

SB-ALU

WA0WA1=11

W

~

Reset

11:23

59

5.4.2微程序设计技术

设计微指令应当追求的目标

缩短微指令的长度

减小控制存储器的容量

提高微程序的执行速度

便于对微指令的修改

提高微程序设计的灵活性

操作控制字段和顺序控制字段的设计

如何用二进制表示各种操作控制信号

如何形成下一个微地址



目标可能是矛盾的！

11:23

1、微命令编码

操作控制字段采用的表示方法

直接表示法

编码表示法

混合表示法

60

11:23

（1）直接表示法

每一位表示一个微命令

“0”表示不发出该微命令

“1”表示发出该微命令

优点：

结构简单，并行性强，操作速度快

缺点：

每条微指令要包含所有的微命令，微指令太长，导致CM容量较大

61

11:23

（2）编码表示法

把相斥的微命令编成一个小组，然后通过译码器对小组信号进行译码，输出作为微命令



微指令字缩短，译码电路使微指令的执行速度减慢

比如：4个微命令如何编码？

要考虑不发出任何微命令的状态

62

11:23

（3）混合表示法

直接表示法与编码法结合

综合考虑指令字长、灵活性、执行微程序速度等方面的要求

63

11:23

2、微地址的形成方法

确定下一条微指令的微地址

下一条微指令的微地址成为后继微地址 

1. 计数器方式

2. 多路转移方式（断定方式）



64

11:23

（1）计数器方式

顺序执行时

后继微地址=当前微地址+增量；

类似指令的顺序寻址

非顺序执行（分支）时

后继微地址=微地址字段

类似跳跃寻址

特点

顺序控制字段较短，微地址产生机构简单

多路并行转移功能较弱，速度较慢，灵活性较差 

65

11:23

2）多路转移方式（断定方式）

一条微指令具有多个转移分支的能力称为多路转移

顺序执行时

后继微地址=微地址字段

非顺序执行（分支）时

按“判别测试”标志和“状态条件”信息产生一个微地址

66

11:23

2）多路转移方式

特点：

能以较短的顺序控制字段配合，实现多路并行转移，灵活性好，速度较快，

需要设计地址转移逻辑

67

11:23

68

某计算机采用微程序控制器，共有 32 条机器指令，公共的取指令微程序包含 2 条微指令，各指令对应的执行微程序平均由 4 条微指令组成，采用多路转移法确定下条微指令地址，则微指令中下址字段(微地址字段)的位数至少是( ) 

A. 5

B. 6

C. 7

D.8

11:23

69

微指令分类

微指令格式分成两类：水平型微指令和垂直型微指令

（1）水平型微指令

一次能定义并执行多个并行操作微命令的微指令，叫做水平型微指令



11:23

70

微指令中设置微操作码字段，由微操作码规定微指令的功能，称为垂直型微指令

其结构类似于机器指令的结构

每条微指令的功能简单

采用较长的微程序结构去换取较短的微指令结构



（2）垂直型微指令

11:23

71

垂直型微指令

寄存器-寄存器传送型



运算控制型



访问主存



条件转移



11:23

水平型微指令与垂直型微指令

水平型微指令

并行操作能力强，效率高，执行时间短、灵活性强

微指令字较长，微程序短，控存容量大，性能佳

垂直型微指令

字长短，微程序长，控存容量小，性能差

垂直型与指令相似，易于掌握

72

11:23

微指令设计与微指令格式

73

11:23

74

微程序设计

静态微程序设计

微程序设计好之后，存放在ROM中，无法修改

动态微程序设计

采用EPROM/Flash作为控制存储器，微程序可以根据改变

指令仿真

在一台机器上实现不同类型的指令系统

11:23



75



11:23


5.5硬连线控制器

硬连线控制器(Hard-wired controller)

也称为硬布线控制器

把控制器看作产生控制信号的逻辑电路

由门电路和触发器构成



1

2

返回

1.基本思想

输出信号

微操作控制信号(微命令)

CPU结构

3

LDIR(T4)

LDDR(T3)

PC+1

LDPC(T4)

RD(I)

RD(D)

WE(D) (T3)

LDR(T4)

LDAR(T4)

CPU结构

4

LDIR(T4)

LDDR(T3)

PC+1

LDPC(T4)

RD(I)

RD(D)

WE(D) (T3)

LDR(T4)

LDAR(T4)

每个操作控制信号的含义是：

RD(I)—读指存

RD(D)—读数存

WE(D)—写数存

LDPC—写入PC

LDIR—写入IR

LDAR—写入AR

LDDR—写入DR

PC+1

LDR2—写入R2寄存器

指令周期流程图

5

如何区分不同的CPU周期？

指令周期流程图

6

如何区分不同的CPU周期？

硬连线控制器时序

设定M1、M2、M3三个电位信号，各自等于一个CPU周期

每个CPU周期包括4个节拍脉冲（T1~T4）

三级时序 同步控制

M1

M2

固定3个机器周期，12个节拍

M3

节拍电位

硬连线控制器的指令周期流程图

采用同步控制方式，将所有指令的指令周期都设为3个CPU周期

图中M1、M2、M3为节拍电位信号，各自等于一个CPU周期

MOV、ADD和JMP指令在M3不执行任何操作

10

3. 微操作控制信号产生

在微程序控制器中

微命令由微指令产生。

在硬连线控制器中

微命令由布尔代数表达式描述的输出函数产生。

11

硬连线控制器设计方法

画出指令周期流程图，明确各节拍控制信号

找出产生同一个微操作信号的所有条件，建立操作时间表



与时序信号组合，写出逻辑表达式

化简、用门电路或可编程器件物理实现。

12

[例3]根据图5.29，写出以下操作控制信号RD(I)、RD(D)、WE(D)、LDPC、LDIR、LDAR、LDDR、PC+1、LDR2的逻辑表达式。其中每个操作控制信号的含义是：

RD(I)—指存读命令

RD(D)—数存读命令

WE(D)——数存写命令

LDPC—打入程序计数器

LDIR—打入指令寄存器

LDAR—打入数存地址寄存器

LDDR—打入数据缓冲寄存器

PC+1—程序计数器加1

LDR2—打入R2寄存器

13

LDIR(T4)

LDDR(T3)

PC+1

LDPC(T4)

RD(I)

RD(D)

WE(D) (T3)

LDR(T4)

LDAR(T4)

每个操作控制信号的含义是：

RD(I)—读指存

RD(D)—读数存

WE(D)—写数存

LDPC—写入PC

LDIR—写入IR

LDAR—写入AR

LDDR—写入DR

PC+1

LDR2—写入R2寄存器

[例3]根据图5.1，写出以下操作控制信号RD(I)、RD(D)、WE(D)、LDPC、LDIR、LDAR、LDDR、PC+1、LDR2的逻辑表达式。

解：（1）画出指令周期流程图 

15

（2）列出微操作时间表（根据数据通路和操作流程图）

16

（2）列出微操作时间表（根据数据通路和操作流程图）

列出在每个微命令在哪个电位、哪个节拍、哪个指令发产生？

17

（2）列出微操作时间表（根据数据通路和操作流程图）

设M1、M2、M3是节拍电位信号；T1、T2、T3、T4为一个CPU周期中的节拍脉冲信号；MOV、LAD、ADD、STO、JMP是机器指令OP操作码字段译码输出信号

18

（3）进行微操作信号的组合

得到如下逻辑表达式：      

       LDIR=M1·T4

		LDAR=M2· T4· (LAD+STO)

	LDDR=M2·T3· (MOV+ADD) +M3·T3·LAD 	PC+1 = M1	 	

 LDR2 = M2·T4·ADD



（4）最后给出电路（省略）

硬连线与微程序控制器比较

硬连线控制器执行速度快

硬连线控制器设计复杂，代价昂贵

微程序控制器设计简单，便于维护修改



20

5.6.4 Pentium CPU

1989年初0.8um工艺，310万晶体管

5V电压，功耗20W

非固定长度指令格式，9种寻址方式，191条指令，兼具有RISC和CISC特性

提供了更加灵活的存储器寻址结构，可以支持传统的4k大小的页面，也可以支持4M大小的页面（TLB）

动态转移预测技术（BTB转移目标缓存）



21

Pentium结构图

哈佛结构Cache

2路超标量

32位CPU

80位FPU

外部数据总线宽度为64位，外部地址总线宽度为32位

微程序控制器



22

5.7 RISC CPU

三个要素：

(1) 一个有限的简单的指令集；

(2) 配备大量的通用寄存器；

(3) 对指令流水线的优化

编译技术

5.7 RISC CPU

RISC机器的特征：

(1) 使用等长指令（4B）

(2) 寻址方式少且简单

(3) 只有取数指令、存数指令访问存储器

(4) 指令数目相对较少，指令格式简单

(5) 指令功能简单，控制器多采用硬连线方式

(6) 指令的执行平均时间(CPI)为一个时钟周期。

(7) 配置大量寄存器、优化使用。

(9) 支持指令流水并强调指令流水的优化使用。

(10)RISC技术的复杂性在它的编译程序



23

RISC与CISC的主要特征对比

25

MIPS Aptiv框图

硬布线控制器

指令缓存

数据缓存

总线接口

内存管理单元

算术与逻辑运算器

协处理器

指令译码器

通用寄存器

浮点运算器

26

ARM处理器 框图

平均微程序为1.8条微指令

本章重点内容

CPU的功能（控制器的功能、6类寄存器）

指令周期基本概念

设计指令周期，画指令周期流程图

时序产生器和控制方式基本原理

微程序控制器工作原理

微程序设计基本概念

硬连线控制器基本概念

本章容易混淆的一些概念

周期表示一段时间。

指令周期指机器指令从取指到执行完成所花的时间，包括取指周期和执行周期。

CPU周期=机器周期，一个CPU周期包括多个节拍脉冲。

节拍脉冲=T周期，处理操作的最基本单位

指令周期 ＞CPU/机器周期 ＞ 节拍脉冲

数据通路举例

某机字长16位，指令16位定长；

指令ADD (R1)，R0的功能为(R0)+((R1)) (R1)，即将R0中数据与R1内容所指向的主存单元的数据相加，并将结果送入R1内容所指向的主存单元中；

数据通路图中控制信号为1表示有效，假设MAR输出一直处于使能状态；



数据通路举例---取指令周期



C1

C2

C3

MAR

MDR

PC

IR

下表为取指令和译码阶段每个节拍(时钟周期)的功能和控制信号，请按相同方式给出执行阶段各节拍的功能和有效控制信号。



数据通路举例---执行指令周期



C1

C2

C3



MAR

MDR

A



((R1))  A



数据通路举例---执行指令周期



C4

C5



MAR

MDR

A



AC



(R0)+((R1))(R1)


5.6流水CPU

5.6.1并行处理技术

5.6.2流水CPU的结构

5.6.3流水线中的主要问题

5.6.4 Pentium CPU

1

5.6.1 并行处理技术

并行性的两种含义：

同时性 指两个以上事件在同一时刻发生；

并发性 指两个以上事件在同一时间间隔内发生。

计算机的并行处理技术主要有以下三种形式：

1. 时间并行

2. 空间并行

3. 时间并行+空间并行

2

1. 时间并行

让多个处理过程在时间上相互错开，轮流重叠地使用同一套硬件设备的各个部分，以加快硬件周转而赢得速度。

实现方式是采用流水处理部件。

目前的高性能微型机几乎无一例外地使用了流水技术。

3

5.6.1 并行处理技术

5.6.1 并行处理技术

2. 空间并行

指资源重复（空间因素），以“数量取胜”

VLSI为其提供了技术保证。

3. 时间并行+空间并行

指时间重叠和资源重复的综合应用 

4

流水线原理

1.时间并行

把任务分成若干子任务，使子任务在流水线的各阶段并发地执行

2.空间并行

资源重复 多处理器系统和多计算机系统

3.时间并行+空间并行

时间重叠和资源重复的综合应用。

奔腾CPU采用超标量流水技术，一个机器周期执行两条指令。

指令周期细分

 取指令IF(Instruction Fetch)

 指令译码ID(Instruction Decode)

 执行运算EX (Execution)

 访存阶段 MEM

 结果写回WB(Write Back)

一条指令不一定经历所有阶段



IF

ID

EX

MEM



WB

非流水线时空图

流水线时空图

完成N条指令需要的时间 5+(n-1)



超标量流水线时空图



时间T



IF

ID

EX

WB

空间S

I12

I34

I1

I2

I3

I4

I1

I2

I3

I4

I1

I2

I3

I4

I1

I2

I3

I4



 具有两条以上的指令流水线。满载时，每一时钟周期可以执行2条指令

I56



I78



流水线分类 

 1.指令流水线

取指---译码---取数---执行

 2.算术流水线

加法器, 乘法器, 快速傅里叶变换器

 3.处理机流水线

 由一串级连的处理机组成.

 每台处理机负责某一特定任务.

11

一个计算机系统可以在不同的并行等级上采用流水线

常见流水线有：

处理机流水线：程序步骤的并行

由一串级联的处理机构成流水线的各个过程段，每台处理机负责某一特定的任务。处理机流水线应用在多机系统中。 

指令流水线：指令步骤的并行

将指令流处理过程分为取指令、译码、执行、写回等几个并行处理过程段。

算术流水线：运算操作步骤的并行

如流水加法器、流水乘法器、流水除法器等。



3.流水线分类

流水线的相关冲突（hazzard）

资源相关

取操作数与取指令都需要访问主存

计算PC、分支地址，运算指令复用ALU

增加部件消除

数据相关

指令操作数依赖于前一条指令的执行结果

引起流水线停顿直到数据写回

分支相关

转移指令使得流水线发生中断

提前取出的指令作废，流水线清空



理想指令流水线

将指令过程分成5个阶段 

IF、ID、EX、MEM、WB

不同阶段之间设置缓冲接口部件（绿色部分）

接口部件本质是寄存器

各段通过接口传递与指令相关的数据，控制，反馈信息

对数据的加工处理依赖于前段接口传递过来的信息

MIPS经典5段流水线

14

流水线段间寄存器

5.6.3流水线中的主要问题 

流水线要有良好的性能，必须能够畅通流动，不发生断流

流水过程中通常会出现以下三种相关冲突（Hazard），使流水线断流。

1.资源相关

2.数据相关

3.控制相关

15

数据相关处理

增加相关检测判定逻辑

当前指令读寄存器与后续3条指令写寄存器相同

当前指令可能有0~2个读寄存器

后续3条指令可能有0~1个写寄存器

相关处理逻辑

流水线停顿

数据重定向

 -16- 

数据相关处理机制

软件方法（编译器完成）

插入空指令

调整程序顺序，使相关性在流水线中消失

硬件方法

寄存器堆写入和读出分离（先写后读，下跳沿写）

插入气泡（空操作）

数据重定向bypass（数据旁路）

将后端处理后的数据（还没来得及写回）重定向

数据在哪就从哪送到运算器



1.资源相关

多条指令进入流水线后在同一段时间内争用同一个功能部件所发生的冲突。



在时钟4时，I1与I4两条指令发生争用存储器资源的相关冲突

解决资源冲突的办法：

(1)冲突指令停顿若干周期，直到冲突消失；

(2)增设一个存储器，将指令和数据分别放在两个存储器中。

18

2.数据相关

在流水计算机中，由于多条指令的重叠处理，当后继指令所需的操作数，刚好是前一指令的运算结果时，便发生数据相关冲突。

如下表所示，ADD指令与SUB指令发生了数据相关冲突。

20

2.数据相关

例：两条指令发生数据相关冲突

ADD	R1,	R2,	R3		R2+R3-->R1

SUB		R4,	R1,	R5		R1-R5-->R4

AND	R6,	R1,	R7		R1^R7-->R6



2.数据相关

RAW(Read After Write)

后面指令用到前面指令所写的数据

WAW(Write After Write)

两条指令写同一个单元

WAR(Write After Read)

后面指令覆盖前面指令所读的单元

解决办法：

可以推后后继指令对相关单元的读操作

设置转发通路（Forwarding）

21

【例4】流水线中有三类数据相关冲突：写后读相关；读后写相关；写后写相关。判断以下三组指令各存在哪种类型的数据相关。



I1:ADD R1，R2，R3 ；(R2) + (R3)->R1

 I2:SUB R4，R1，R5 ； (R1) - (R5)->R4 

(2)I3:STO M(x)，R3 ；(R3)->M(x)，M(x)是存储器单元

I4:ADD R3，R4，R5 ； 　(R4)+(R5)->R3 

I5:MUL R3，R1，R2 ；(R1)×(R2)->R3

 I6:ADD R3，R4，R5 ； (R4) + (R5)->R3



写后读RAW相关

读后写WAR相关

写后写WAW相关

23

3.控制相关

由转移指令引起的。

当前指令有跳转，但流水已经开启后续指令处理过程

解决技术：

延迟转移法

由编译程序重排指令序列，让跳转的指令接在最后流水入口

转移预测法

用硬件预测将来的行为，提前让转移指令进流水。

指令调度

为了充分发挥指令流水线的效率，减小断流，降低指令间的相关性，在保证程序正确执行的前提下，需要对指令的执行顺序进行重新编排

静态调度

由编译器在编译过程中对指令进行调度

动态调度

由控制器在指令执行过程中进行调度，对程序员透明

乱序执行（Out Of Order）

记分牌算法， Tomasulo算法

25

5.6.4 Pentium CPU

1989年初0.8um工艺，310万晶体管

5V电压，功耗20W

非固定长度指令格式，9种寻址方式，191条指令，兼具有RISC和CISC特性

提供了更加灵活的存储器寻址结构，可以支持传统的4k大小的页面，也可以支持4M大小的页面（TLB）

动态转移预测技术（BTB转移目标缓存）



26

Pentium结构图

哈佛结构Cache

2路超标量

32位CPU

80位FPU

外部数据总线宽度为64位，外部地址总线宽度为36位

微程序控制器



27

Intel Haswell结构图

28

5.7 RISC CPU

三个要素：

(1) 一个有限的简单的指令集；

(2) 配备大量的通用寄存器；

(3) 对指令流水线的优化

编译技术

5.7 RISC CPU

RISC机器的特征：

(1) 使用等长指令（4B）

(2) 寻址方式少且简单

(3) 只有取数指令、存数指令访问存储器

(4) 指令数目相对较少，指令格式简单

(5) 指令功能简单，控制器多采用硬连线方式

(6) 指令的执行平均时间(CPI)为一个时钟周期。

(7) 配置大量寄存器、优化使用。

(9) 支持指令流水并强调指令流水的优化使用。

(10)RISC技术的复杂性在它的编译程序



29

RISC与CISC的主要特征对比

多周期流水线

31

32

MIPS Aptiv框图

硬布线控制器

指令缓存

数据缓存

总线接口

内存管理单元

算术与逻辑运算器

协处理器

指令译码器

通用寄存器

浮点运算器

33

ARM处理器 框图

平均微程序为1.8条微指令

本章重点内容

CPU的功能（控制器的功能、6类寄存器）

指令周期基本概念

五种基本指令的指令周期及其数据通路流程

时序产生器和控制方式基本原理

微程序控制器工作原理

微程序设计基本概念

硬连线控制器基本概念

本章容易混淆的一些概念

微命令

控制部件通过控制线向执行部件发出的各种控制命令

微操作

执行部件接受微命令以后所进行的操作

公操作

一条指令执行完毕以后，CPU所进行的操作



本章容易混淆的一些概念

微指令

在机器的一个CPU周期中，一组实现一定操作功能的微命令的组合，构成一条微指令

微程序:

一条指令均对应一段微程序，微程序固化在控制存储器中。

机器指令

本章容易混淆的一些概念

周期表示一段时间。

指令周期指机器指令从取指到执行完成所花的时间，包括取指周期和执行周期。

CPU周期=机器周期，一个CPU周期包括多个节拍脉冲。

节拍脉冲=T周期，处理操作的最基本单位

指令周期 ＞CPU/机器周期 ＞ 节拍脉冲


1

第六章总线系统

6.1 总线的概念和结构形态

6.2 总线接口

6.3 总线仲裁

6.4 总线的定时和数据传送模式

6.5 PCI总线和PCIe总线



6.1.1总线的基本概念

总线(BUS)是构成计算机系统的互连机构

是多个系统功能部件之间进行数据传送的公共通路

借助于总线

各系统功能部件之间实现地址、数据和控制信息的交换

在争用资源的基础上进行工作 

2

6.1.1总线的基本概念

一个单处理器系统中的总线大致分为： 

内部总线：CPU内连接各寄存器及运算器部件之间的总线 

系统总线：CPU和其他高速功能部件（如存储器、通道等）相互连接的总线 

I/O总线：中低速I/O设备相互连接的总线

3

物理特性：

总线的物理连接方式，包括根数、插头形状，引脚线的排列方式

功能特性：

描述总线中每一根线的功能：地址、数据、控制三类

电气特性：

定义每一根线上信号的传递方向（单/双向）及有效电平范围

时间特性：

规定了总线上各信号有效的时序关系，每根总线在什么时间有效

4

1. 总线的特性

2. 总线的标准化

对总线的四个特性定义一个广泛认可的标准

实现不同厂家的功能部件互换使用

USB、PCI-E

5

3. 总线带宽

6

常见总线带宽

8

6.1.2 总线的连接方式 

外围设备和总线的连接部件称为适配器(adapter)：

完成CPU和外设之间的数据传送和控制

实现传输速率匹配和同步；

通常称为接口(interface)

9

6.1.2 总线的连接方式 

总线影响计算机系统性能，单处理器计算机中采用的总线结构有两种基本类型：

单总线结构和多总线结构

单总线结构

CPU是主控设备（发起通信的设备）

结构简单、容易扩充

多部件共享总线，分时工作

传输效率低

处理器结构对总线有影响



10

11

2. 多总线结构



主要解决各种设备速率不匹配的问题

位于CPU内部，速度最快

连接主存

高速I/O设备

低速I/O设备

连接不同速率的总线

总线的效率和吞吐量得以提高

高速、中速、低速设备连接到不同的总线上同时进行工作

现代计算机中的多总线结构

12

6.2总线接口

6.2.1 信息的传送方式 

计算机系统中，传输信息有两种方式：

串行传送

并行传送

13

1.串行传送

按顺序传送一个数码（一个字节）的所有二进制位(bit) ，每次一位

一般先传低位，后传高位

使用一条物理传输线：单端传输

两条传输线：差分传输

数据传送前：并—串变换

数据接收后：串—并变换

14

1.串行传送

特点：成本较低、速度慢

位时间：每个比特在传输线上占用的时间长度

波特率(baud)：每秒钟传送的比特数

波特率是位时间的倒数

串行传送的数据格式编码



起始位(1b)+数据位(1B)+校验位(1b)+停止位(1b)

15

16

【例2】利用串行方式传送字符，设数据传送速率是120个字符/秒，每一个字符格式规定包含10个比特位（起始位、停止位、8个数据位）问波特率是多少?位时间是多少?

【解】：

波特率为：10位×120/秒=1200波特

位时间是波特率的倒数：

Td=1/1200=0.833×10-3s=0.833ms

2. 并行传送

同时传输多个比特，对每个数据位都需要单独一条传输线

数据传送比串行数据传送快得多（传输频率较低时）

17

发展趋势

并行传输距离受限

频率越高，线间串扰越严重，带宽无法继续提高

串行传输距离长

无串扰现象、提供更高的带宽

随着总线频率的增加，并行逐渐转向串行

SCSI  SAS

PATA  SATA

PCI  PCI-E

18

3. 分时传送

功能复用：某个传输线上既传送地址信息，又传送数据信息

分时复用：共享总线的部件分时使用总线

必须划分时间片



19

6.2.2 总线接口的基本概念 

I/O接口即I/O设备适配器

指CPU和主存、外围设备之间通过总线进行连接的标准化逻辑部件

I/O接口部件在连接的两个部件之间起着“转换器”的作用，实现彼此之间的信息传送

一个接口可连接一个设备，也可连接多个设备

20

6.2.2 总线接口的基本概念 

外部设备有自己的设备控制器

设备控制器通过I/O接口和总线连接，进而与CPU交换信息



外围设备的连接方法

6.2.2 总线接口的基本概念 

一个适配器的两个接口：

连接系统总线的接口

连接外设的接口

接口的典型功能：控制、缓冲、状态、转换、整理、程序中断 



22

6.3总线仲裁

总线上的设备有主方和从方两种形态

主方启动一个总线周期、从方响应主方请求

每次总线操作，只能有一个主方，可以有多个从方 

为了解决多个主方争用总线的问题，设置总线仲裁部件（arbitrator）

采用优先级策略或公平策略

按照总线仲裁电路的位置不同，分为

集中式和分布式

23

1. 集中式仲裁

一个中央仲裁器，连接线：

送往仲裁器的总线请求信号线BR(Bus Request)

仲裁器送出的总线授权信号线BG(Bus Grant)

表征总线是否空闲的信号BS（Bus Busy）

集中式仲裁采用三种方式

(1) 链式查询方式（菊花链查询-Daisy chain）

(2) 计数器定时查询方式

(3) 独立请求方式



24

(1)链式查询方式

接口发出总线请求信号BR（置BR为高）

仲裁器在总线空闲的时候（BS为低）开始仲裁

总线授权信号BG依次从一个I/O接口传送到下一个I/O接口（串行查询）

假如BG到达的接口无总线请求，则继续往下传递；

假如BG到达的接口有总线请求，该接口获得总线控制权（将BS置为1）， BG信号便不再往下传递

25

BS--总线忙

BR--总线请求 

BG--总线授权

查询过程

(1)链式查询方式

特点：

优先级固定：离仲裁器最近的设备具有最高优先级，离仲裁器越远，优先级越低

用线少，易扩充; 

对查询链的电路故障很敏感，单点故障



26

(2) 计数器定时查询方式

每个设备分配一个地址，设备内部有地址判别电路

仲裁器内部有个计数器，其输出和设备地址线连接

对设备地址计数

27

(2) 计数器定时查询方式

设备通过BR线发出总线请求

仲裁器在BS为低时让计数器开始计数，计数值通过设备地址线广播

设备内部的地址判别电路，判断地址线上的计数值与自身设备地址是否一致

如果一致且该设备的BR为高，获得了总线使用权，则置BS线为1

如果没有设备获得总线使用权，计数值加一，再次广播

仲裁器判断BS为高，中止计数查询

28

29

(2) 计数器定时查询方式

每次计数可以从“0”开始，也可以从中止点开发始

固定优先级：每次从“0”开始计数，优先级的顺序是固定的

公平优先级：从中止点开始计数，每个设备都有可能成为最高优先级

可变优先级：软件修改计数器初值

缺点：控制线较多、扩展性较差（与计数器的位数有关）



计数器

(3) 独立请求方式

每个设备均有独立的总线请求线BRi和总线授权线BGi

中央仲裁器中的排队电路决定首先响应哪个设备的请求，给设备以授权信号Bgi

特点：

响应速度快

控制灵活，

优先级可通过程序改变；



控制线数多、总线裁决机构较复杂



30

31

2. 分布式仲裁

每个功能设备都有自己的仲裁号以及仲裁器

仲裁过程通过协商完成

6.4.1 总线的定时

总线信息传送过程，可分为：

请求总线，总线仲裁，寻址，信息传送，状态返回

定时：事件出现在总线上的时序关系

同步定时：事件出现在总线上的时刻由总线时钟信号确定

总线信号中包含公共时钟线

异步定时：建立在应答式或互锁机制基础上

后一事件出现在总线上的时刻取决于前一事件的完成

不需要统一的公共时钟信号



32

6.5 PCI总线和PCIe总线

PCI-（Peripheral Component Interconnect）

是美国SIG 推出的32～64位总线（并行总线）

频率为33～66MHz，数据传输率为132～528MB/s 

基于PCI总线计算机结构

处理器

处理器

主存

控制器

主存

PCI设备



PCI设备



HOST桥

主设备目标设备

PCI/LAGACY总线桥

PCI/PCI桥

LAGACY

设备

LAGACY

设备

PCI设备

PCI设备



HOST总线

PCI总线

PCI总线

LAGACY总线（遗留）

现代计算机中的多总线结构

35

PCI总线特点

允许智能设备在适当的时候取得总线控制权以加速数据传输和对高度专门化任务的支持

支持猝发传输模式

与 ISA／EISA／MCA兼容

设有特别的缓存，实现外设与CPU隔离，外设或CPU的单独升级都不会带来问题

同步时序、集中式仲裁

PCI Express总线

PCI Express是一种基于串行技术、高带宽连接点、点到点连接的新型总线技术

PCI Express采用4根信号线

差分传输，全双工、可靠性高、速度快

多种连接方式，扩展性好

如×1、×4、×8、×16以及×32通道的连接器

支持热插拔和热交换

软件层与PCI兼容

37

PCI Express总线

PCI Express总线插槽

38



PCI Express总线

39

共享式

hub

独占式

switch

USB （Universal Serial Bus ）

由Compaq、Intel、Microsoft、NEC等公司于96年共同研制发布

传输速度高、使用简单、编程复杂

适合计算机中所有高、中、低速传输

外部总线

USB1.1/2.0 

4线传输、半双工



USB （Universal Serial Bus ）

USB 3.0

全双工



Type-C

物理接口

不区分正反面

USB标准演进

42

USB标准演进

43


1

第七章 外围设备

7.1 外围设备概述

7.2 磁盘存储设备

7.3 磁带存储设备

7.4 光盘和磁光盘存储设备

7.5 显示设备

7.6 输入设备和打印设备

7.1.1 外围设备的一般功能

外围设备又称外部设备：

功能:在计算机和其他设备之间，以及计算机与用户之间提供联系

每一种外围设备，都是在它自己的设备控制器控制下进行工作，而设备控制器则通过I/O接口和主机相连，并受主机控制

7.2 磁盘存储设备

磁表面存储：

将磁性材料涂在载磁体（铝或塑料）存储信息

磁盘存储器、磁带存储器

优点：

存储容量大，位价格低；可以重复使用；信息可以长期保存；

缺点：

存取速度较慢，机械结构复杂

3

1. 磁性材料物理特性

B---磁感应强度

H---外加磁场强度

I----电流

2. 磁表面存储器的读写原理

利用磁头来形成和判别磁性材料的不同磁化状态



磁性材料排列方式

磁性材料均匀排列在圆形载磁体上

水平排列

密度低、容量小



垂直排列

密度高、容量大



7.2.2 磁盘的组成和分类

目前硬磁盘主要是温彻斯特磁盘，简称温盘，是一种可移动磁头固定盘片的磁盘机

密封组合、悬浮磁头

防尘性能好，可靠性高，对使用环境要求不高

7

优点：没有摩擦、寿命长

硬盘磁头与盘片的接触方式：悬浮式

优点：没有摩擦、寿命长

温盘原理

10

1.44MB 软盘

软盘：固定磁头，可移动盘片

硬磁盘驱动器主要3个部件组成

定位驱动系统：控制磁头臂径向运动

主轴系统：控制磁盘旋转

数据转换系统：磁电互换



11

7.2.3 硬盘驱动器和控制器

7.2.4 磁盘上信息的分布

盘片的上下两面都能记录信息，称为记录面（surface）

一个记录面对应一个磁头（Head），用磁头表示记录面

记录面上一系列同心圆称为磁道（Track）

由外向内依次编号，最外侧为0磁道

每个磁道等弧度分为若干个扇区（Sector）

信息按扇区存放，每个扇区的存储信息量是相同的，为512B

12

7.2.4 磁盘上信息的分布

扇区之间有间隙(gap)，用于隔离扇区



spindle

surface



tracks



track k

sectors



gaps



磁头和盘片的运动



盘片旋转

磁头悬浮，沿半径方向运动.



 -14- 

7.2.4 磁盘上信息的分布

所有记录面上相同编号的磁道形成一个圆柱面(Cylinder)，简称柱面

柱面数等于磁道数

柱面是逻辑、虚拟概念

所有磁盘统一转动，所有磁头一起移动

磁盘访问过程：

1.OS计算出要访问的位置(C、H、S)

2.控制磁头移动到对应的柱面

3.磁盘旋转到起始扇区

4.磁盘继续旋转，磁头开始读写信息

15

硬盘上的一个扇区要用三个参数来定位（CHS模式）：柱面号、磁头号、扇区号

标准记录格式

 硬盘容量=柱面数×磁头数×扇区数×512字节 

7.2.4 磁盘上信息的分布

7.2.4 磁盘上信息的分布

如果某文件长度超过一个磁道的容量，应将它记录在同一个记录面上，还是记录在同一个柱面上?

17

磁头的移动都需要时间，而且在磁盘访问总时间中占比较大

如果某文件长度超过一个磁道的容量，应将它记录在同一个柱面上，因为不需要移动磁头，读/写速度快

7.2.4 磁盘上信息的分布

柱面号10位，磁头号8位，扇区为6位，得到CHS模式容量限制8.4G

现代磁盘采用LBA（逻辑区块地址(Logical Block Address）

18

7.2.5 磁盘存储器的技术指标

存储密度：

道密度：沿磁盘半径方向单位长度上的磁道数

位密度：磁道单位长度上能记录的二进制位数

面密度：位密度和道密度的乘积

一个磁盘存储器所能存储的字节总数，称为磁盘存储器的存储容量

格式化容量和非格式化容量

19

7.2.5 磁盘存储器的技术指标

20

21

7.2.5 磁盘存储器的技术指标

磁盘存取时间

23

【例1】磁盘有6片磁盘，每片有两个记录面，最上最下两个面不用存储区域内径22cm，外径33cm，道密度为40道/cm，内层位密度400位/cm，转速6000转/分问：

(1)共有多少柱面?

(2)总存储容量是多少?

(3)数据传输率多少?

24

解：(1) 共有多少柱面?

有效存储区域=16.5-11=5.5(cm)

因为道密度=40道/cm，共有40×5.5=220道，即220个圆柱面

(2)总存储容量是多少?

内层磁道周长为2πR=2×3.14×11=69.08(cm)

每道信息量=400位/cm×69.08cm=27632位=3454B

每面信息量=3454B×220=759880B

总容量=759880B×10=7598800B

(3)数据传输率多少?

磁盘数据传输率Dr=rN

N为每条磁道容量，N=3454B

r为磁盘转速，r=6000转/60秒=100转/秒

Dr=rN=100×3454B=345400B/s

 -25- 

硬盘发展趋势

充氦气：缩短碟片距离，增加碟片数量

4K扇区：与OS文件管理匹配，减少扇区浪费

叠瓦SMR、二维TDMR、微波辅助磁记录 (MAMR) 、热辅助磁记录 (HAMR) 

增大单碟容量

容量将到达100TB



26

 固态硬盘

固态硬盘SSD （solid state Disk）

由控制单元和ROM存储单元（FLASH芯片）组成

速度快、抗震、零噪音、重量轻等优点



28

29

7.3 磁带存储设备

磁带的记录原理与磁盘基本相同，只是它的载磁体是一种带状塑料，叫做磁带

磁带采用顺序访问方式，速度比磁盘速度慢

通常用作为数据备份的海量存储设备

30

7.4光盘和磁光盘存储设备

光盘上的信息以坑点形式分布

凹坑表示“1”，凸点表示为“0”

读出时，当激光束照射在凹坑上时反射率低；而照射在凸点上时反射率高

根据反射光的光强变化并进行光电转换，即可读出记录信息



只读型CD光盘

CD-DA

数字唱盘，记录数字化信息，74分钟数字立体声信息

CD-ROM 

容量640MB

可写CD

写一次型CD-R

利用激光改变有机染料记录面对光的反射率

可多次的重复写入

磁光盘 CD-MO(Magneto-Optical)

利用激光产生高温来改变磁场

CD-RW(Rewritable)

利用激光改变相变材料的晶态和非晶态两种状态

DVD

DVD使用较短波长的激光束，使盘片数据的密度达4.7GB，是CD产品容量的7倍，

如果采取双面双层的记录方式，容量更可高达17GB

DVD-ROM DVD-VideoDVD-Audio DVD-R DVD-RAM



 -33- 

不同盘片比较

Track Pitch:1.6μm

Minimum Pit Length：0.8 μm

Storage Density:0.41Gb/inch2

Track Pitch:0.74 μm

Minimum Pit Length：0.4 μm

Storage Density:2.77Gb/inch2

Track Pitch:0.32 μm

Minimum Pit Length：0.15 μm

Storage Density:14.73 Gb/inch2

CD 0.7GB

DVD 4.7GB

Blu_ray Disc25GB

 -34- 

光驱的速度

1倍速

CD在1小时内读完一张CD盘的速度定义为1倍速，150KB/S

DVD的1倍速则在1350KB/s左右

X倍速：指是最初光驱读取速率的多少倍的读取速率的光驱


1

第八章 输入输出系统

8.1 CPU和外设之间的信息交换方式

8.2 程序查询方式

8.3 程序中断方式

8.4 DMA方式

8.5 通道方式

8.6 通用I/O标准接口



返回

8.1 CPU与外设之间的信息交换方式

I/O设备同CPU交换数据的过程：

输入过程：

(1)CPU把一个地址放在地址总线，选择某一输入设备；

(2)CPU等候输入设备的数据有效；

(3)CPU从数据总线读入数据，并放在一个相应的寄存器中

输出过程：

(1)CPU把一个地址放在地址总线，选择输出设备；

(2)CPU把数据放在数据总线上；

(3)输出设备认为数据有效，从而把数据取走

问题的关键在于：

如何找到对应的外部设备? 编址方式

什么时候数据才有效?定时方式



2



外围设备编址方式

编址对象

I/O设备中的控制寄存器、数据寄存器、状态寄存器

3

外围设备编址方式:独立编址（Isolated I/O）

内存单元和I/O寄存器各自独立编址：两个地址空间

I/O寄存器地址称为端口号

访问I/O寄存器有专门的I/O指令

X86： out 80H, AX

4

外围设备编址方式:统一编址

也称为内存映射I/O：Memory Mapped I/O，MMIO

I/O寄存器和内存单元一起编址：一个地址空间

同一地址空间中的不同部分来区分I/O寄存器和内存单元

访存指令访问I/O设备和内存，Load/Store

ARM、RISC-V、MIPS

5

MIPS处理器内存映射I/O

6



【例1】假设有一个运行时间为100秒的基准程序，其中90秒是CPU时间，剩下的是I/O占用的时间如果在以后的5年里，CPU的速度每年提高50%但I/O时间保持不变，那么5年后运行程序要耗费多少时间？ I/O时间所占的比例是多少?

解：	耗费的时间=CPU时间+ I/O时间

目前， I/O时间=100-90=10秒

今后五年内CPU时间、I/O时间及其所占比例如下表：

外设定时

如何判断数据有效是外设定时的关键

根据外围设备的速度分为3种定时：

速度极慢或简单的外围设备(机械开关，显示二极管)

直接输入输出

慢速或中速的外围设备

异步定时

高速的外围设备

同步定时

8.1.4 CPU与I/O接口之间的数据传送

CPU管理外围设备的方式：

无条件传送方式（简单I/O方式）

程序查询方式

程序中断方式

直接内存访问(DMA)

通道方式

单片机多采用程序查询、程序中断

PC采用程序中断和DMA

通道方式用在大型计算机中

9

8.2 程序查询方式

又叫程序控制I/O方式

当需要输入/输出时，CPU暂停执行主程序，转去执行设备输入/输出的服务程序，进行数据传输

异步定时：查询设备状态，判断是否有效

10

3、程序查询方式的接口

11

设备选择电路用于判断地址总线上呼叫的设备是否为本设备

数据缓存寄存器

缓存从外设读出的数据或者CPU输出到外设的数据

设备状态标志

用于标志设备的工作状态，



4、程序查询输入/输出方式



信息交换完全由CPU执行程序实现

启动设备;

反复查询设备直至设备准备好;

传输单个数据

重复2-3步直至数据传输完毕

CPU和外设串行工作，反复查询设备状态占用较多CPU时间，系统效率低

CPU占用率取决于查询频率

用于单片机

4、程序查询输入/输出方式

有多个设备时，CPU周期性地(轮询)调用各I/O设备的子程序



13

8.2 程序查询方式

处理器速度为10MIPS，I/O设备为键盘，其操作速度为10字符/s，采用程序查询方式进行控制，那么对于每个输入操作，CPU等待的时间可以执行__ 万条指令

14

8.2 程序查询方式

特点：

数据传输完全依赖于程序控制

硬件结构简单

频繁的查询动作浪费了大量的CPU时间

实时性差，随机事件响应慢

目前只用在单片机中

16

8.3程序中断方式

8.3.1 中断的基本概念 

8.3.2 中断服务程序入口地址的获取

8.3.3 程序中断方式的基本I/O接口

8.3.4 单级中断

8.3.5 多级中断

8.3.6 Pentium中断机制

8.3.1中断的基本概念  

中断（Interrupt）是指CPU暂时中止现行程序，转去处理随机发生的事件，处理完后自动返回原程序的功能和技术

也称为异常(exception)

中断系统是计算机实现中断功能的软硬件总称

一般在CPU中设置中断机构

在外设接口中设置中断控制寄存器

在软件上设置相应的中断服务程序

17

8.3.1中断的基本概念  

中断源:产生中断的事件

与I/O设备信息交换：网络通信

故障处理：

硬件故障：掉电、校验错

软件故障：溢出、除数0

实时事件处理：键盘、鼠标

程序调度，时间片划分

软中断

18

8.3.1中断的基本概念  

中断处理过程：

某一外设的数据准备就绪后，“主动”向CPU发出中断请求信号；

当CPU响应此中断，暂停运行主程序，自动转去该设备的中断服务程序；

当中断服务程序执行完毕后，CPU又回到原来的主程序继续执行

中断适合于处理随机出现的事件

19

8.3.1中断的基本概念  

响应中断的时机

什么时候对外设的中断请求进行响应？

断点保护问题 

如何在处理完中断后正确返回主程序？

多重中断处理

中断处理过程中又有外设发出中断请求怎么办？

中断功能实现的软硬件分工

哪些功能用软件实现，哪些功能需要硬件支持？

20

8.3.1中断的基本概念  

21

单级中断处理过程流程图



(1)响应中断的时机

外设的中断请求存放在接口中的中断源锁存器里，并通过中断请求线连至CPU

外设的中断请求是随机的，CPU只有在当前指令执行完毕，转入公操作时才受理中断请求



(2)断点保护问题:正确返主程序 

断点：主程序被中断的地方（PC）

现场：当前指令执行结束后CPU的状态(包括寄存器值和一些状态标志位)

保存现场：现场保存到堆栈中

恢复现场

从堆栈中恢复PC和CPU状态，以便从断点处继续执行主程序



(3)多重中断处理

中断处理过程中又有新外设发出中断请求怎么办？

在CPU中有一个中断屏蔽寄存器

置“1”(设置屏蔽)，关中断，不受理中断请求

置“0”(取掉屏蔽)，开中断，受理中断请求

可以通过程序控制

实现中断嵌套



(4)中断功能实现的软硬件分工

中断周期的操作由硬件实现

也称为“中断处理的隐操作”，程序员看不到

响应中断、关中断、保存断点、找出中断源

顺序很重要

中断服务程序由软件实现

保存现场、对发起中断的设备服务、恢复现场、开中断、返回主程序



8.3.2中断服务程序入口地址的获取 

转移到中断服务程序：找到中断服务程序的入口地址

向量中断：

当CPU响应中断时，由硬件直接产生一个地址(即向量地址)

向量地址:设备的中断服务程序入口地址

查询中断：

硬件为所有中断安排一个公共的中断服务程序

该公共程序查询并跳转至相应中断服务程序入口

26

8.3.3 程序中断方式的基本I/O接口:向量中断

27



准备就绪的标志(RD-Ready)

允许中断寄存器(EI-Enable Interrupt)

中断请求寄存器(IR-Interrupt Request)

中断屏蔽寄存器(IM-Interrupt Mask)

8.3.3 程序中断方式数据输入的执行过程

28

①由程序启动外设，将该外设接口的BS标志置“1”，RD标志清“0”；

②接口向外设发出启动信号；

④当设备动作结束或数据缓冲寄存器填满时，设备送出控制信号，将RD置“1”；

⑧设备的中断向量逻辑讲中断向量发到数据总线，CPU将中断向量赋值给PC，跳转到中断服务程序



③外设传送数据到接口的数据缓冲寄存器；



⑤当EI为“1”时，接口向CPU发出中断请求；

⑥在一条指令执行公操作时， CPU检查IR寄存器如果标志IM为“0”，进入中断周期 ；

⑨中断服务程序把接口中数据缓冲寄存器的数据读至CPU中的寄存器；

（10）CPU发出控制信号C将接口中的BS和RD标志复位

⑦CPU受理中断请求，向外设发出中断响应信号INTA并关闭中断；

8.3.4 单级中断

所有中断源通过INTA链式查询方式连接，属于同一级

离CPU近的中断源优先权高

不允许任何中断源打断中断服务程序，即使优先权比它高也不能

CPU中有1个IM，1个IR

29



INTA： Interrupt Authorization 中断授权信号

单级中断源的识别

串行排队链法

IR1，IR2，IR3为中断请求信号

IS1，IS2，IS3为中断选中信号

30

8.3.5 多级中断

中断源分成多个级别

两级优先权

每级有一个级别优先权

每级内又有级内优先权

中断级别高的中断源可以打断级别低的中断源，称为中断嵌套

31

32

8.3.5 多级中断

一维多级中断：每级中断只有一个中断源

二维多级中断：每级中断有多个中断源

一个系统有n级中断，则CPU中有n个IR，n个IM



33

8.3.5 多级中断

某级中断被响应后，则关闭本级和低于本级的IM，开放更高级的IM

不同级别的中断可以嵌套，但同一级的中断不允许嵌套

中断服务程序中使用多级堆栈保存现场（包括IM）



中断请求的处理方法:单级中断

优先权顺序：A>B>C



中断请求到达顺序

中断请求的处理方法:多级中断

优先权顺序：A>B>C



中断请求到达顺序

多级中断源的识别

采用了独立请求方式和链式查询方式相结合的方式

级间采用独立请求方式

优先排队电路

中断向量产生电路

级内采用链式查询方式

36

开放和屏蔽中断

屏蔽中断

指CPU中的中断屏蔽寄存器IM置1

处于“关中断”

所有可屏蔽中断源的中断请求得不到响应

开放中断

指CPU中的IM置0

处于“开中断”

可以响应中断源的中断请求

37

允许和禁止中断

禁止中断

指某个中断源接口中的中断允许寄存器EI被置0

对应的中断源不能发出中断请求

处于“中断封锁”

允许中断

中断接口中的EI置1

中断源处于“中断开放”

允许中断源发出中断请求

38

【例1】参见图所示的二维中断系统请问：

(1)在中断情况下，CPU和设备的优先级如何考虑?请按降序排列各设备的中断优先级

【解】

(1)在中断情况下，CPU的优先级最低各设备的优先次序降序排列是：A→B→C→D→E→F→G→H→I→CPU



39

(2)若CPU现执行设备B的中断服务程序，IM2，IM1，IM0的状态是什么?如果CPU执行设备D的中断服务程序，IM2，IM1，IM0的状态又是什么?

【解】执行设备B的中断服务程序时IM2IM1IM0=111；

执行设备D的中断服务程序时，IM2IM1IM0=011

多级中断中，某级中断被响应后，则关闭本级和低于本级的IM，开放更高级的IM

40

(3)每一级的IM能否对某个优先级内的个别设备单独进行屏蔽?

 如果不能，采取什么办法可达到目的?

【解】

(3)每一级的IM标志不能对某个优先级内的个别设备进行单独屏蔽。

可将接口中的EI(中断允许)标志清“0”，它禁止设备发出中断请求

41

(4)假如设备C一提出中断请求，CPU立即进行响应，如何调整才能满足此要求?

【解】

(4)要让设备C的中断请求及时得到响应，可将设备C从第2级取出来，单独放在第3级上，使第3级的优先级最高即可

42

【例2】参见图8.9所示的系统，只考虑A，B，C三个设备组成的单级中断结构，它要求CPU在执行完当前指令时对中断请求进行服务假设：

(1)CPU“中断批准”机构在响应一个新的中断之前，先要让被中断的程序的一条指令一定要执行完毕；

(2)TDC为查询链中每个设备的延迟时间；

(3)TA，TB，TC分别为设备A，B，C的服务程序所需的执行时间；

(4)TS,TR为保存现场和恢复现场所需的时间；

(5)主存工作周期为TM

 试问：就这个中断请求环境来说，系统在什么情况下达到中断饱和?



43

例

假定多级中断，其中断优先级由低到高为L0→L1→L2，试设置中断屏蔽字，将中断优先级由低到高改为L1→L2→L0



原先的屏蔽字

例

假定多级中断，其中断优先级由低到高为L0→L1→L2，试设置中断屏蔽字，将中断优先级由低到高改为L1→L2→L0

 新的屏蔽字



A、B、C是与主机连接的3台设备，采用多级中断实现中断优先级处理，其各自的中断服务程序中对中断屏蔽码的设置如下表所示: 

解：从中断屏蔽字看出，其处理优先级为：

 A > C > B > CPU

 故CPU执行程序轨迹如下：



A服务

B服务

C服务



CPU

A

B



C



 2040 6080

8.3.6 Pentium中断机制

1. 中断类型

Pentium有两类中断：中断和异常

中断通常称为外部中断，由外部硬件信号引发有两种情况 ：

(1) 可屏蔽中断：可通过CPU中标志寄存器屏蔽

(2) 非屏蔽中断：这类中断不能被屏蔽

异常由指令执行引发

(1) 执行异常： 执行一条指令过程中出现错误、故障等

(2) 执行软件中断指令： 如执行INT 0，INT 3，INT n等指令

Pentium共有256种中断和异常，每一个有中断向量号(0～255)

中断优先级分为5级

48

2. 中断服务程序

中断服务程序的入口地址信息存于

实模式为中断向量表IVT

保护模式为中断描述符表IDT

Pentium取得中断向量号的途径有三种：

(1) 指令给出：INT 20H

(2) 外部提供：8259中断控制器

(3) CPU识别错误、故障现象



49

50


8.4DMA方式

8.4.1 DMA的基本概念   

8.4.2 DMA传送方式

8.4.3 基本的DMAC

8.4.4 选择型和多路型DMAC

1

21:39

8.4.1 DMA的基本概念

Direct Memory Access：直接内存访问

完全由硬件执行I/O数据交换

DMAC（DMA Controller）接管对总线的控制

数据交换不经过CPU，直接在内存和I/O设备之间进行

DMAC向内存发出地址和控制信号

用于高速传送成组数据

21:39

2

8.4.1 DMA的基本概念

优点

数据传输速度快

省去了CPU取指令、取数、送数等操作

没有保存现场、恢复现场之类的工作

主存地址的修改、传送字个数的计数用硬件实现

21:39

3

8.4.1 DMA的基本概念

基本操作：

(1)外围设备发出DMA请求； 

(2)CPU响应请求，DMAC接管总线的控制；

单总线系统中CPU具有总线仲裁功能

(3)DMAC对内存寻址，即决定数据传送的内存地址及传送个数，并执行数据传送的操作；

(4)向CPU报告DMA操作结束

数据传送前的准备，传送结束后的处理，均由程序承担，而DMAC仅负责数据传送的工作 

21:39

4

8.4.2 DMA传送方式

DMA方式进行数据传送时，CPU仍执行主程序

DMAC与CPU可能同时要访问主存，引起冲突

处理访存冲突

1. 停止CPU访问内存

2. 周期挪用

3. DMAC与CPU交替访内存

原则：I/O的数据要尽快处理，以防丢失

5

21:39

1.停止CPU访问内存

DMAC 使用总线，控制内存，CPU处于等待状态

优点：控制简单

缺点：内存的效能没有充分发挥

6



21:39

一个数据块的传送过程

2、周期挪用

CPU让出一个或多个周期（内存读/写周期）的总线控制权，由DMAC挪用，进行一次数据传送

传送结束后，CPU继续工作重复，直到数据块传送完

较好地发挥了内存和CPU的效率

21:39

7



8

3、DMAC和CPU交替访问

内存工作周期分为C1和C2两个子周期，一个供CPU访存，一个供DMAC访存总线分时控制



适合DMAC频繁访问内存的场合

硬件逻辑复杂

DMA传送效率很高，没有总线申请时间



21:39

9

8.4.3 基本的DMAC

1、DMAC的基本组成



21:39

2、DMAC数据传输过程

10

三个阶段：传送前预处理、正式传送、传送后处理

停止CPU访内方式的DMA流程图

21:39

2、DMA数据传输过程

传输前，主机向DMAC传送以下信息(软件)： 

测试设备状态

向内存地址计数器送数据块在内存中的首地址

启动设备

向字计数器送数据字个数

这些工作做完之后，CPU继续原来的工作

11

21:39

2、DMA数据传输过程

数据传送阶段（硬件）：

外设准备好收发数据，由DMAC向主机发DMA请求

CPU响应该请求，让出总线使用权

DMAC接管总线控制权，发送内存地址、读/写命令

每传送一个字，内存地址计数器加1，字计数器加1

若字计数器为0时，进入传送后处理阶段

传送后处理阶段（软件）：

DMAC向CPU发出中断请求，报告数据传送结束

12

21:39

8.4.4选择型和多路型DMAC

1. 选择型(selector DMAC)

	物理上可以连接多个设备：物理多个

	同时只能为一个设备服务：逻辑一个



21:39

13

2. 多路型DMAC

Multiplexer DMAC

物理上连接多个外围设备：物理多个

允许外围设备同时工作：逻辑多个

适合于同时为多个慢速外围设备服务

每个DMA通路都有独立的寄存器组保存各自的传送参数



21:39

14

DMA方式与中断方式比较

数据传送方式不同

中断方式通过程序实现数据传送，而DMA直接用硬件来实现

响应时机不同

执行完一条指令后响应中断，而在一个机器周期结束后响应DMA请求

功能不同

中断方式不仅能传送数据，还能处理异常事件；而DMA只能进行数据传送

DMA利用了中断技术

响应时间不同

中断方式需要切换程序、保护现场和恢复现场；DMA不改变CPU现场

DMA请求比中断请求优先级高，为防止丢失DMA高速传送的数据

15

21:39

16

8.5 通道方式(Channel )

通道是一个特殊功能的处理器

设有专用通道指令

专门负责数据输入输出的传输控制

CPU只负责“数据处理”,进一步提高了CPU的效率

21:39

通道结构

17

8.5.2 通道的类型

选择通道-the selector channels

在物理上可以连接多个设备，

设备不能同时工作，只能选择一个设备工作

多路通道- the multiplexor channels

在同一时间能处理多个I/O设备的数据传输

分为数组多路通道和字节多路通道

21:39

21:39

18

21:39

19

20

本 章 小 结

在计算机系统中，CPU对外围设备的管理方式有：①程序查询方式；②程序中断方式；③DMA方式；④通道方式

程序中断方式使用广泛它“主动”向CPU发出请求信号CPU响应中断请求后，暂停运行主程序，自动转移到该设备的中断服务子程序，为该设备进行服务，结束时返回主程序中断处理过程可以嵌套进行，优先级高的设备可以中断优先级低的中断服务程序

DMA技术使得外围设备可以直接访问内存，CPU可以继续程序

DMA采用以下三种方法：①停止CPU访内；②周期挪用；③DMA与CPU交替访问

21:39


计算机组成原理

教师：闫江毓

办公室：主楼E705

邮箱：yabjy@ncepu.edu.cn

微信:		 

1

计算机组成原理

课程目的：

掌握计算机的工作原理, 深刻理解程序在计算机硬件上执行的过程

课程任务：

掌握计算机硬件系统各组成部件的工作功能、原理和逻辑实现

理解各部件联结成整机并协调运转的方法

了解当代计算机系统的新技术和新成果

2

计算机组成原理

3

课程依赖关系

主要内容

编译技术

操作系统

组成原理

数字电路

数理逻辑

布尔逻辑

掌握逻辑描述的方法

编译器

操作系统

计算机软件



计算机组成原理

课时安排：

56学时（54讲课+2复习）

1-14周

最后成绩：

到课情况(5%-课堂派考勤) 

作业情况(5%-课堂派习题)

实验(20%) 

期末考试(70%-闭卷)

4

白中英主编(第六版)

主要教材

5

电子版

图书馆网址-》电子图书-》科学文库

http://reading.sciencepress.cn/

搜索“计算机组成原理”



只能在校园网内使用

北京大学计算机组成慕课

https://www.icourse163.org/course/preview/PKU-1205809805?tid=1206107207

华中科技大学计算机组成原理慕课

https://www.icourse163.org/course/HUST-1003159001

6

慕课资源

目录

第一章 计算机系统概论

第二章 运算方法和运算器

第三章 多层次的存储器

第四章 指令系统 

第五章 中央处理器 

第六章 总线系统 

第七章 外存与I/O设备

第八章 输入输出系统

7

课程安排（56学时）

8

2024/6/5

第一章计算机系统概论

1.1 计算机的分类

1.2 计算机的发展简史

1.3 计算机的硬件

1.4 计算机的软件

1.5 计算机系统的层次结构

9

1.1计算机的分类

电子计算机从总体上来说分为两大类：

电子模拟计算机

特点是数值由连续量来表示，运算过程也是连续的。

电子数字计算机

主要特点是按位运算，并且不连续地跳动计算。

10

11

1958年完成的我国自行研制的模拟计算机红旗-551，慈云桂

12

1960年，我国自行设计的第一台电子数字计算机107机

中科院计算机夏培肃领导研制

她也是我国计算机事业的奠基者

现在计算机中的一些术语和专业名词都是她翻译的。

中国计算机之母

13

1.1.1计算机的分类

根据性能、经济性和适应性，可以划分为两类：

专用计算机：专用机是最有效、最经济和最快速的计算机，但是它的适应性很差。

通用计算机：通用计算机适应性很大，但是牺牲了效率、速度和经济性。

通用计算机分类

可以分为：

超级计算机

大型机

服务器

工作站

微型机

单片机



区别在于：体积、简易性、功耗、性能指标、数据存储容量、指令系统规模和机器价格等



14

1.2 计算机发展简史

计算机的五代变化

1946—1957年，电子管计算机：数据处理

1958—1964年，晶体管计算机：工业控制

1965—1971年，中小规模集成电路计算机：小型计算机

1972—1990年，大规模和超大规模集成电路计算机：微型计算机

1991年至今，甚大规模集成电路计算机：单片机

15

1.2.2 半导体存储器的发展

20世纪50～60年代，所有计算机存储器都是由微小的铁磁体环构成

1970年，仙童半导体公司生产出了第一个较大容量半导体存储器

从1970年起，半导体存储器经历了若干代：单个芯片1KB~1MB~1GB。

其中1K=103 1M=103K=106,1G=103M=109

1bit表示1个二进制位，1B=8bit

规范的二进制位计数：1Ki=210,1Mi=220,1Gi=230

16

1.2.3 微处理器的发展

1971年Intel公司开发出4004。 

1972年出现的8008，这是第一个8位微处理器

1974年出现了8080，这是第一个通用微处理器。

17



1.2.3 微处理器的发展

20世纪70年代末出现通用16位微处理器8086 

Intel于1985年推出了32位微处理器80386。 

到现在的64位处理器和多核处理器

18

我国计算机技术的发展

1953年起步，

1958年第一台103型通用计算机

50年来相继研究出了第二代，第三代计算机。

80年代研究出每秒１亿次的巨型机，银河I,II, 曙光等。

85年6月，第一台实现中文化系统、并量产的国产微机长城0520CH正式研发成功。

在高性能计算，并行计算上已紧跟国际先进水平，但计算机的核心部件CPU技术还远远落后。

19

1.2.3 微处理器的发展

微处理器一般称为CPU：Central Process Unit

目前CPU芯片主要设计/生产商

Intel：酷睿、奔腾、赛扬、至强！ 

AMD：速龙、闪龙、皓龙、APU-天津海光 

VIA ： C3、C7-上海兆芯 

IBM：-苏州国芯

龙芯：嵌入式、桌面、专用计算机

ARM：三星、高通、华为海思、华为鲲鹏

20

1.2.3 微处理器的发展

龙芯属于MIPS架构（LoongArch）

上海兆芯属于X86架构

华为麒麟/鲲鹏属于ARM架构

阿里平头哥属于RISC-V架构

中国有着全球数量最多的芯片设计公司

展讯、寒武纪等

小米，百度、VIVO、OPPO都在布局芯片

还未形成规模效益、人才缺口非常大

通用计算机分类

可以分为：

超级计算机

大型机

服务器

工作站

微型机

单片机



区别在于：体积、简易性、功耗、性能指标、数据存储容量、指令系统规模和机器价格等



22

超级计算机-Top500（2023.5）

1、Frontier (美) , 处理器核：8,730,112；峰值1102PFlop/s；AMD 处理器

2、Fugaku(日) , 处理器核：7,630,848；峰值442PFlop/s；ARM 处理器

2、LUMI(芬兰), 处理器核：1,110,144；峰值151.9PFlop/s； AMD 处理器+ NVIDIA Tesla V100

7、神威 太湖之光, 处理器核：10,649,600；峰值93.01PFlop/s；神威处理器

10、天河2A, 处理器核：4,981,760；峰值61.4PFlop/s；Intel+国产Matrix-2000加速卡

23

超级计算机-Top500（2024.5）

1、Frontier (美) , 处理器核：8,699,904；峰值1.206EFlop/s；AMD 处理器

2、Aurora(美) , 处理器核：9,264,128；峰值1.012EFlop/s；Intel 处理器

3、Eagle(美), 处理器核：2,073,600；峰值561.2PFlop/s； Intel 处理器+ NVIDIA H100

4、Fugaku(日) , 处理器核：7,630,848；峰值442PFlop/s；ARM 处理器

5、LUMI(芬兰), 处理器核：2,752,704；峰值379.7PFlop/s； AMD 处理器+ NVIDIA Tesla V100

Top500组织在最新发布的报告中指出，中国已决定不再参加Top500的HPL基准测试。

24

日本Fugaku-富岳

富士通和日本理化学研究所共同研制

拥有超过7,630,848个核心，内存4752TB

富士通A64FX处理器， ARM v8.2-A，配备32GB HBM 2内存，带宽1TB/s，浮点性能2.7TFLOPS，使用台积电7nm工艺生产，晶体管数量 878.6 亿

A64FX 包含 48 个计算核心和 2 ~ 4 个辅助核心，没有 GPU 加速器，封装 HBM2 内存。



25

2024/6/5

神威-太湖之光

2017年TOP500第一， 2020年第四

拥有40960个计算节点，内存1.31PB

使用了国产众核芯片申威26010

采用28nm制程工艺，主频1.45GHz

拥有260个核心，浮点峰值达到3.06TFlops

64位

26

1.2.4 计算机的性能指标

27

2024/6/5

1.2.4 计算机的性能指标

CPU执行时间：

表示一段程序执行过程中所占用的CPU时间。

CPU时间=执行某段程序所使用的CPU周期数×CPU时钟周期

CPI：Cycle Per Instruction

执行一条指令所需的平均周期数

执行某段程序所使用的CPU周期数÷程序总指令数

MIPS：Million Instructions Per Second

每秒百万指令数

MIPS=程序总指令数÷(程序执行时间×106)

2024/6/5

28

1.2.4 计算机的性能指标

2024/6/5

29

CPU性能公式

30

CPU性能公式

31

CPU性能公式

32

2024/6/5

33

[例2]用一台50MHz处理机执行标准测试程序，它包含的混合指令数和相应所需的平均时钟周期如下表所示：

解

34

1.3 计算机的硬件

1.3.1 硬件组成要素

控制器

运算器

存储器

输入设备

输出设备

冯·诺依曼型计算机

Von Neumann 

1.3 计算机的硬件

冯·诺依曼型计算机 

五大组成部分

二进制表示

存储程序

程序控制

35

冯诺依曼架构

36

1.3.2 运算器

37

ALU- Arithmetic Logic Unit （算术逻辑运算单元）

算术运算和逻辑运算

在计算机中参与运算的数是二进制

运算器的长度一般是8、16、32或64位

计算机的字长

38

1.3.3 存储器

存储数据和程序

运算开始前，必须先将程序和数据存入存储器（存储程序思想）

一个存储单元中存入一个二进制数据串。

存储器按存储单元组织，存储器中有大量的存储单元。

为了方便查找，每个存储单元都被分配一个地址。

通常，存储器都是按地址查找，线性编址。

39

1.3.3. 存储器

存储器的容量一般都按字节计算

存储器单位：

210 Byte＝1KiB

210 KiB＝1MiB

210 MiB＝1GiB

210 GiB＝1TiB

分类：内存、外存

1.3.3. 存储器

内存有两种操作：

写入：数据存入存储器

写入新数据后，会“覆盖”旧数据

读出：从存储器取出数据

读出并不破坏存取器中的数据

可以从同一存储单元中反复的读出同一数据



40

1.3.4 控制器

控制器是计算机中发号施令的部件

控制计算机的各部件有条不紊地工作

任务：从内存中取出指令加以分析,然后执行某种操作（指令控制）

一条指令（instruction）完成一种操作

算术运算或者逻辑运算、传输数据等

将复杂的问题简化为一系列简单操作

每个简单操作用一条指令完成，

一系列指令的有序集合叫做程序（program）

41

1.3.4 控制器

(2)指令的形式 

指令的内容由两部分组成，即操作的性质和操作数的地址。



每条指令应当明确告诉控制器，从存储器的哪个单元取数，并进行何种操作。

指令系统：计算机的全部指令集合。

42

范例-模型计算机



43



存储器



运算器和控制器

存储单元

44



模型计算机

存储器



运算器和控制器

范例

45

范例

46

47

存储器中的机器语言程序



10

11

12

13

9

8

7

6

5

4

3

2

1

指令集

构造机器指令

将汉语表达转为二进制表示

汇编源程序

同一个问题在不同实现的计算机上解决，步骤是不同的。

编译器



48



要考虑两个问题：

数据存储

数据处理

模型计算机

存储器



49

表1.4 计算 y=ax+b-c 的程序

表1.5 指令的操作码定义 

51



(2)指令的形式 

数码化的指令和数据都放入存储器，两种方式：

冯诺依曼结构（Von Neumann Architecture）：存储器的任何位置既可以存放数据也可以存放指令

哈佛结构（Harvard Architecture ）：指令和数据存储器物理上独立

52

冯诺依曼结构

哈佛结构

(2)指令的形式 

存储程序：将程序（指令序列）和数据存放到存储器中

程序控制：控制器依据存储的程序来全机协调地计算任务

53

控制器执行程序的过程

2024/6/5

54

取指令

101 1001

执行

（9）→A 

取指令

011 1100

执行

(12)→B ;

(A)*(B)→A 



取指令

001 1010

执行

(10)→B ;

(A)+(B)→A 

 

取指令

0101011 

执行

(11)→B ;

(A)-(B)→A 



取指令

1101101

执行

A → (13) 

 

取指令

1110000 

执行

Stop 



STO 13

LAD 9

MUL 12

ADD 10

SUB 11

SLT

1.3.4 (3)控制器的基本任务

按照特定的顺序一条接着一条取指令、执行指令。

55

取指令

101 1001

执行

（9）→A 

取指令

011 1100

执行

(12)→B ;

(A)*(B)→A 



取指令

001 1010

执行

(10)→B ;

(A)+(B)→A 

 

取指令

0101011 

执行

(11)→B ;

(A)-(B)→A 



取指令

1101101

执行

A → (13) 

 

取指令

1110000 

执行

Stop 



1.3.4 (3)控制器的基本任务

每取出一条指令，控制器中的指令计数器就加1，下一条指令做好准备

指令计数器(Program counter:PC)

保存指令的地址

指令要顺序存放

每条指令在存储器都有地址

56

存储器中的机器语言程序

7

6

5

4

3

2

1



指令地址

1.3.4 (3)控制器的基本任务

时间因素

取指周期：从存储器中取指令到控制器的时间

执行周期：在控制器中执行指令的时间

57

时间t

1.3.4 （4）指令流和数据流

如何区分内存输出的是指令流？还是数据流？

根据不同的时间

取指周期中从内存读出的信息流是指令流，它流向控制器

执行周期中从内存读出的信息流是数据流，它由内存流向运算器。

58

1.3.4 控制器

其他任务：

保证指令按规定序列自动连续地执行。

对各种异常情况及时响应和处理。

控制器向计算机各功能部件提供每一时刻协同运行所需要的控制信号



59

1.3.5 适配器与输入输出设备

输入设备：把人们所熟悉的信息形式变换为二进制信息形式

输出设备：把计算机处理结果变换为人或其他机器设备所能接收和识别的信息形式

总线：构成计算机系统的骨架，是多个系统部件之间进行数据传送的公共通路。

60

1.4 计算机的软件

1.4.1 软件的组成与分类

61

1.4.2 软件的发展演变

编程语言的发展

手编程序：机器语言程序，手工编译二进制码



汇编程序：符号语言程序，汇编程序汇编



62

可执行程序

目的程序

机器语言

可执行程序

目的程序

汇编语言

手工编写

汇编源程序

汇编程序

翻译

1.4.2 软件的发展演变

编程语言的发展

高级程序：算法语言/高级语言



编译系统：把源程序全部翻译成目的程序，然后机器执行目的程序

解释系统：逐一翻译源程序语句并立即执行该语句。

63

源程序

可执行程序

目标程序



编辑程序

汇编或编译程序



联接程序

高级语言

1.4.2 软件的发展演变

系统软件的发展

操作系统：用来管理计算机软硬件资源和自动用户作业调度，而使多个用户能有效地共用一套计算机系统。

数据库管理系统：数据库和数据库管理软件

分布式系统软件



64

1.5 计算机系统的层次结构

计算机是一个硬、软件结合而成的整体。它通常由五级组成。

不同的计算机使用者看到的计算机的形式是不同的

65

1.5 计算机系统的层次结构

高级语言级：方便用户编写应用程序，由各种高级语言编译程序支持和执行。

汇编语言级：提供一种符号形式语言，以便能够精确地操作控制硬件。

操作系统级：它由操作系统程序实现，管理所有的硬件资源



66

1.5 计算机系统的层次结构

一般机器级：由微程序解释机器指令系统。

微程序设计级：实际执行指令、处理数据的数字电路。



67

1.5.2 软件与硬件逻辑等价性

随着大规模集成电路技术的发展

任何操作可以由软件来实现，也可以由硬件来实现；

采用哪种方案？

应综合考虑各个因素：价格、速度、可靠性、存储容量、变更周期

固件：介于传统的软件和硬件间的实体。

功能------软件

形态------硬件

实现------软件写入ROM------固化

68

第一章小结

计算机的分类

冯·诺依曼型计算机特点

计算机硬件的基本组成部分

五大部件

运算器、控制器、存储器

计算机软件

计算机的性能指标

计算机层次结构



69

返回

作业

P15：4、5、6、7、8、14

70

一段C程序

		int main()

		{

		int a = 2, b = 3;

		int c, d;

		c = a + b;

		d = a * b;

		}

在线编程网站

https://gcc.godbolt.org/



X86架构的指令序列



X86架构的指令序列

8051单片机架构的指令序列

SPARC V8架构的指令序列

人工智能四层架构

76

2024/6/5

AI不同计算任务需要不同芯片

77

GPU与AI模型训练

78

FPGA：分布式+可定制

79

ASIC：实现性能和功耗均衡

80

国产服务器CPU

81

自动驾驶芯片指标AI算力TOPS

根据地平线数据，L2级自动驾驶的算力需求为2-2.5TOPS，

L3级自动驾驶算力需求为20-30TOPS,L4级自动驾驶算力需求为200TOPS以上，L5级自动驾驶算力需求为2000TOPS以上。



82

算力单位TOPS

TOPS (Tera Operations Per Second)，表示每秒执行1万亿次(10^12)运算，用于衡量自动驾驶芯片的AI算力。

TOPS描述芯片MAC(Multiply Accumulate，乘积累加运算)的运算能力，并没有指定数据类型，具体算力评估需要结合数据类型及精度。

MAC运算包括相乘和相加(a←a+b*c)。对于卷积、点积、矩阵等运算而言，MAC指令可以大幅提高运算效率。

TOPS计算公式：理论峰值 = MAC矩阵行 * MAC矩阵列 * 主频 * 2

83



84



现代GPU集群极度耗电。GPT 4在训练过程中使用了约50 GWh的能量。相当于30辆普通汽车环绕地球300次。谷歌表示一次搜索使用0.28瓦时，而与谷歌搜索相比，Google GPT 4使用的能量大约是谷歌搜索的四倍。



85



86



SM（Streaming Multiprocessors）

称为流式多处理器，是NVIDIA GPU的基本构建模块。每个SM包含CUDA核心（用于通用计算的处理单元）、张量核心（专门用于AI工作负载）以及其他用于图形和计算操作的组件。

SM具有高度并行性，使GPU能够同时执行许多操作。

主芯片上共有144个SM。但它们的参数产量约为90％，这意味着我们可以使用大约130个。在生产过程中发生故障的部分会被关闭。此外，如果看一下主芯片的尺寸，那是一个相当大的芯片，非常接近现代工厂机器的限制。。

87



HBM（高带宽内存）

HBM是一种具有高带宽接口的堆叠内存类型。与传统的GDDR内存相比，HBM提供了显著更多的带宽，可以实现GPU和内存之间的数据传输速率更快，这对于对带宽需求高的任务（如深度学习和大数据分析）特别有益。如果查看内存控制器，您会看到有6个，但NVIDIA只启用了其中的5个。



88



89


第二章 运算方法和运算器

2.1 数据与文字的表示方法

2.2 定点加法、减法运算

2.3 定点乘法运算

2.4 定点除法运算

2.5 定点运算器的组成

2.6 浮点运算方法与浮点运算器

1

返回

2

2.1 数据与文字的表示方法

2.1.1 数据格式

2.1.2 数的机器码表示

2.1.3 字符与字符串的表示方法

2.1.4 汉字的表示方法

2.1.5 校验码

3

2.1数据与文字的表示方法

两大类数据：

符号数据：非数字符号的表示（字符、汉字、图形等）

数值数据：数字数据的表示方式（定点、浮点）

编码：用少量、简单的基本符号，选择合适的规则表示尽量多的信息，同时利于信息处理（速度、方便）

ASCII、GB、Unicode

MP3、FLAC、JPG、H.264、H.265等

二进制与易经

系统的提出二进制观点的是德国的数学家和哲学家莱布尼茨

据说他根据易经发明了二进制

太极生两仪，两仪生四象，四象生八卦

两仪：阴和阳

2024/6/5

4

易经八卦

2024/6/5

5

2024/6/5

6

2.1.1 数据格式

计算机数据的表示方式，考虑几个因素：

数的类型（小数、整数、实数、复数）

数值范围

数值精度

存储、处理、传送的硬件代价

软件兼容性



7

2.1.1 数据格式

8

十进制转二进制

整数部分除2取余 小数部分乘2取整

5

2

1

0



0.625 * 2

1

0.25 * 2

0

0.5* 2

1

 0.0 

除尽为止 1011



低

高



求得位数满足要求为止

进制转换的简单运算方法

－17/128的二进制表示?

大数的转换方法，记住几个常用的2的幂

9

25＝3226＝6427＝12828＝25629＝512 

210＝1024(1Kilo)211＝2048212＝4096

213＝8182 214＝16364 215＝32728

216＝65536 220＝1Mega 

230＝ 1Giga(吉)240＝1Tera(太)

更大的单位是多少？

250＝1 Peta260＝1 Exa270＝1 Zetta 280＝1 Yotta

千、兆、吉、太、拍、艾、泽、尧

分、厘、毫、微、纳

进制转换的简单运算方法

10

15 = 24-1＝16-1=10000-1= 1111

31 = 25-1＝32-1 =100000-1= 11111

127 = 27-1＝128-1=10000000-1 =111_1111 

255 =28-1＝256-1=1111_1111 

1023 =210-1＝1024-1=11_1111_1111 

65535=216-1＝65536-1 = 1111_1111_1111_1111



几个简化运算的例子

130=?

=128+2=27+2=10000000+10=10000010

65539=?

=65536+3=216+3=1_0000_0000_0000_0011



2010=?

=2047-37=2048-1-32-4-1=211-1-25-22-1

=111_1111_1111-25-22-1=111_1101_1010

111111110111＝?

=212-1-8

17/128=10001/27=0.0010001



 -11- 

计算机中使用的计量单位

12

我国传统文化中的数量单位

13

2.1.1数据格式

计算机中数值数据表示格式：

定点表示：小数点位置固定

浮点表示：小数点位置不固定

定点格式容许的数值范围有限（字长一定），硬件简单。

浮点格式容许的数值范围很大，硬件复杂。

2024/6/5

14

1. 定点数的表示方法

约定数据的小数点位置固定

小数点不使用记号”.”表示

将数据表示成纯小数或纯整数

定点数表示：

带符号数

不带符号数

运算器利用寄存器存储数据

寄存器中每个位称bit (Binary Digit)

最高有效位 (MSB)、最低有效位 (LSB)

2024/6/5

15

2024/6/5

16

1. 定点数的表示方法



xn xn-1 xn-2… x1 x0



数的表示范围:



符号：

0代表正号

1代表负号

量值

小数点位于符号位之后，不需专门存放位置

带符号定点纯小数

2024/6/5

17

 定点纯整数



xn xn-1 xn-2… x1 x0



MSB为符号

量值

小数点固定于LSB之后

例：字长8位

 X=+1010110.



纯整数：X = 01010110



正数，符号位取0

Y= - 1101001.



纯整数：Y = 11101001 （原码）



负数，符号位取1

X=+0.11011

Y=-0.10101



符号位取0

纯小数：X = 01101100



符号位取1

纯小数：X = 11010100 （原码）

2024/6/5

19

1. 定点数的表示方法

纯整数的表示范围(n+1位)



1. 定点数的表示方法

受字长限制，表示数的范围有限;

定点小数表示的精度有限

目前计算机中采用定点数表示纯整数，因此将定点数表示的运算简称为整数运算。

2024/6/5

20

2.浮点数的表示方法

2024/6/5

21

2024/6/5

22

2.浮点数的表示方法

指数e

基数R

尾数M

2.浮点数的表示方法

一个浮点数由阶码和尾数及其符号位组成

尾数M：用定点小数表示，表明有效数字的位数，决定了浮点数的表示精度

阶码E：用定点整数表示，指明小数点的位置，决定了浮点数的表示范围

2024/6/5

23

IEEE754 标准

2024/6/5

24

IEEE 754 32位单精度浮点数标准

2024/6/5

25

浮点数的规格化

例：156.78	=15.678×101	

	= 1.5678×102

	= 0.15678×103=RE×M

对于二进制数

1011.1101	=0.10111101 ×2+4

	= 0.0010111101 ×2+6 

	= 1.0111101 ×2+3 

那么，计算机中究竟采用哪种数据形式？



多种数据形式



规格化表示法

2024/6/5

27

IEEE754 标准

规格化： 同一真值浮点数具有唯一的表示形式

规格化尾数应为如下形式：

		1.xxxxxxxxx

整数位的1属于隐藏位，在实际存储时，尾数域只存储小数点后面的数值。

规格化表示：当尾数不为 0，

尾数左移1位（小数点右移1位），同时阶码减1（左规）

尾数右移1位（小数点左移1位），同时阶码加1（右规）



IEEE754 标准

一个规格化的32位浮点数x的真值表示为

 x=(-1)S×(1.M)×2E-127 



64位的浮点数（双精度浮点数）

符号位1位，阶码域11位，尾数域52位，指数偏移值是1023。

规格化的64位浮点数x的真值为：

 x=(-1)S×(1.M)×2E-1023 



2024/6/5

28

2024/6/5

29

2.浮点数的表示方法

【例1】若浮点数x的754标准存储格式为(41360000)16，求其浮点数的十进制数值。

解：将16进制数展开后，可得二制数格式为



指数e=阶码-127=10000010-01111111=00000011=(3)10

包括隐藏位1的尾数

1.M=1.011_0110_0000_0000_0000_0000=1.011011

于是x=(-1)S×1.M×2e

=+(1.011011)×23=+1011.011=(11.375)10

2024/6/5

30

2.浮点数的表示方法

【例2】将数(20.59375)10转换成754标准的32位浮点数的二进制存储格式（16进制表示）。

解:首先分别将整数和分数部分转换成二进制数：

 20.59375=10100.10011

 规格化，尾数右移4位 10100.10011=1.010010011×24

 e=4，于是得到：

 S=0, E=4+127=131, M=010010011

最后得到32位浮点数的二进制存储格式为：

 0100_0001_1010_0100_1100_0000_0000_0000=(41A4C000)16

真值0的机器数（机器零）

阶码E＝0，尾数M＝0

正0：S＝0，负0：S＝1

非规格化浮点数：阶码E＝0，尾数M≠0

规格化浮点数：阶码E＝1～254（11111110）

无穷大的机器数

阶码E＝全1（11111111） ，尾数M＝0

＋∞：S＝0，－∞：S＝1

NaN（not a number，不是一个数）

阶码E＝全1（11111111） ，尾数M≠0

用来通知异常情况

IEEE 754标准

32位单精度浮点数

单精度IEEE浮点数区间

2024/6/5

32

1≦E≦254

E=255

E=0

M=0

M≠0

M=0

M≠0

规格化浮点数的范围

正0或负0

正/负无穷大

NaN

非规格化数

2024/6/5

33

2.浮点数的表示范围

浮点数所表示的范围远比定点数大

一般计算机中同时采用定点、浮点表示。

单片机中多采用定点表示。

IEEE 754单精度在线转换

https://www.h-schmidt.net/FloatConverter/IEEE754.html

2024/6/5

34

3.十进制数串的表示方法

有时十进制数在计算机中需要以十进制的方式进行运算，需要对十进制进行编码

二-十进制编码（BCD码）

每个十进制符号由4位二进制数表示

8421有权码

名称表示每一位的位权（8、4、2、1）

每位的数码与相应的位权相乘，再求和，得到它所代表的十进制数码

74.56表示：0111 0100 0101 0110

2024/6/5

35


2024/6/5

1

2.1.2 数的机器码表示

一般书写表示的数，称为真值

计算机中表示的数，称为机器数

在计算机中，为了妥善的处理好符号位问题，主要是负数的运算问题，引入4种表示方法：

原码、补码、反码、移码。

1. 原码表示法

定点整数的原码形式为xnxn-1… x1x0

字长8位：

X＝+105，则 [X]原 ＝01101001

X＝-105， 则 [X]原 ＝10000000+1101001

				＝11101001

0使用原码有两种表达形式

　　　 [+0]原 =00000000

　　 [-0]原 =10000000

2024/6/5

3

1. 原码表示法

特点：

表示简单，易于同真值之间进行转换，

实现乘除运算简单。

进行减法运算麻烦。

要比较绝对值的大小，然后绝对值大的数减去绝对值小数，最后给结果选择符号。

为了解决这些矛盾，找到了补码表示法。

2024/6/5

4

2. 补码表示法

2024/6/5

5

2. 补码表示法

2024/6/5

6

3. 反码表示法

定义：

正数的反码表示与原码相同

负数的反码符号位不变，数值位是将原码的数值位按位取反。



电路很容易实现，

触发器的输出正负两值。

2024/6/5

7

3. 反码表示法

反码表示有正0和负0之分

　 	 [+0]反 =00000000 [-0] 反 =11111111

负整数补码：反码加1

解决了求补码还要减法的问题

	[-105]补＝10010110＋1＝10010111

负数求补

负数原码“符号位不变，数值位取反加1”得对应补码

负数补码再求补得到负数原码

补码：11100000

原码：1[1100000]求反＋1

			＝10011111+1

		＝10100000

2024/6/5

9

4. 移码表示法

传统定义和754标准浮点数阶码的定义不同

2024/6/5

10

移码和补码尾数相同，符号位相反

[例8]设机器字长16位,定点表示,尾数15位,数符1位,问：定点原码整数表示时，最大正数是多少?最小负数是多少? 

[解:]　 定点原码整数表示



　 　最大正数值＝(215－1)10＝(＋32767)10 　



最小负数值＝－(215－1)10＝(－32767)10

 

数的机器码表示

正数的原码、反码、补码等于真值，只有负数才分别有不同的表示方法

采用补码，减法运算可以用加法运算实现，节省硬件，目前机器中广泛采用补码表示法

有些机器用原码进行存储和传送，运算时改用补码

移码表示法主要用于表示浮点数的阶码，可以直接比较大小。表示范围和补码相同，只有最高位相反

同一代码的不同含义

一个代码，采用不同编码，其数值不一样

计算机内一个二进制数：	1000 0001

不同的含义

无符号二进制数：	129

8421 BCD码：	81

有符号整数的原码：	-1

有符号整数的反码：	-126

有符号整数的补码：	-127

2.1.3字符和字符串的表示方法

非数值数据

通常指的是字符、字符串、图形符号、汉字等数据

必须按照一定的规则用一组二进制编码来表示

ASCII

美国国家标准局（ANSI）制定的ASCII（American Standard Code for Information Interchange，美国信息交换标准码）是现今最为通用的单字节编码系统

主要用于显示现代英文字母和符号

15

16

ASCII码用7位二进制编码表示一个字符，总共可以表示128个字符

计算机用一个字节来存放一个ASCII字符，最高位固定为0

2024/6/5

17

IBM PC 104 键盘keyboard (Windows格式)

18

2.1.4 汉字的表示方法

1. 汉字的输入编码 

用西文标准键盘上对汉字进行编码： 

数字编码：是用数字串代表一个汉字的输入, 如区位码等。最大优点是无重码, 但难记. 

字音编码：以汉语拼音作为编码基础。简单易学, 但重码很高, 有微软拼音、智能ABC输入法等。 

字形编码法：将汉字的字形信息分解归类而给出的编码。具有重码少的优点。常用的有表五笔字型、郑码等。

音形编码法：音形编码吸取了音码和形码的优点，使编码规则简化,重码少。常用的有全息码等。 

2.1.4 汉字的表示方法

2.汉字内码

汉字内码是汉字的机内代码。

一般采用两个字节表示。

为了与ASCII区别，汉字内码中两个字节的MSB规定为“1”。

汉字字符集编码查询https://www.qqxiuzi.cn/bianma/zifuji.php

2024/6/5

19



2024/6/5

20

汉字内码

1981年，国标码字符集GB2312

每个编码2个字节，共收集常用简体汉字6763个

1984年，BIG5 字符集

称大五码，共收录13053个中文字，港台地区使用

1995年，GBK字符集

共收录汉字21003个，支持繁体中文、日韩汉字

2000年，GB18030 字符集

收录了27484个汉字，覆盖中、日、朝鲜语和中国少数民族文字

向下兼容GBK、GB2312

2024/6/5

21

2024年6月5日星期三

22

Unicode码

容纳全世界所有语言中任意一种符号

为每种语言中的每个字符设定惟一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求

UCS-2

2-byte Universal Character Set，每个字符占用2个字节，实际使用比较多

UCS-4

每个字符占用4个字节，理论上可以表示231=2 147 483 648个字符

Unicode码

为了解决Unicode的传输、存储问题，主要是网络传输，对Unicode进行二次编码

UTF：Unicode Transformation Format

UTF-8

可变长格式

对英文使用1个字节，中文使用3 个字节来编码

UTF-16

拿2个字节来表示字符

字符编码查询https://www.qqxiuzi.cn/bianma/zifuji.php

2024/6/5

23

2024/6/5

24

Chrome浏览器中打开的web页面，点击右键，选择“查看网页源代码”

华电主页www.ncepu.edu.cn的编码

记事本编码区别？

 -25- 

2.1.4 汉字的表示方法

3. 汉字输出码

为了能显示和打印汉字，必须先存储汉字的字形，这就是汉字字形码

两类字形码：点阵字形和矢量字形

2024/6/5

26

3. 汉字输出码

点阵字形又称字模码

每个字由m×n个像素的位图表示，称m×n点阵

点阵中的每个点都只有两种状态

1表示有笔画，对应像素应置为字符颜色；

0表示无笔画，对应像素应置为背景颜色或不改变



27

2.1.4 汉字的表示方法

一个16 点阵字形（左图），一行用 2 个字节描述，总供有 16 行，它的信息量是 2*16=32 个字节。

一个 48 点阵字形用 6 个字节乘 48 行组成，它的信息量是 6*48=288 个字节。

复原字形速度快，但缩放后的字形质量难以保证



2.1.4 汉字的表示方法

矢量字形

通过数学方程来描述

包含了字形边界上的关键点、连线的导数信息等

在显示、打印时，要经过一系列的数学运算输出结果

字体可以无限放大而不产生变形

目前主流的矢量字体格式有3种：

Type1，TrueType和OpenType

29

2.1.5校验码

数据在存取和传送的过程中可能会发生错误

产生错误的原因可能有很多种

设备的临界工作状态

外界高频干扰

收发设备中的间歇性故障等

为减少和避免错误

提高硬件本身的可靠性

对数据采用专门的逻辑电路进行编码，以检测错误，甚至校正错误

30

2.1.5校验码

方法

在每个字上添加一些校验位，用来确定字中出现错误的位置

计算机中常用的检错或纠错技术

奇偶校验Parity Check 

CRC循环冗余校验(Cyclic Redundancy Check) 

Hamming码，ECC校验



2024/6/5

31

若干位有效信息（如1个字节）加上1位校验位组成校验码

奇校验：校验码中1的个数为奇数

偶校验：校验码中1的个数为偶数

奇偶校验码

32

奇校验码

设8位信息码组为D7D6D5D4D3D2D1D0 ：

若D7~D0中有奇数个“1”，则奇校验位=0

奇校验位 D奇=D7⊕D6⊕D5⊕D4⊕D3⊕D2⊕D1⊕D0

读出数据时，将9位校验码送入校验电路

G= D7⊕D6⊕D5⊕D4⊕D3⊕D2⊕D1⊕D0⊕D奇

若G=0，则无错误

若G=1，则传输出现错误

33



34

【例10】 已知下表中左面一栏有5个字节的数据。请分别用奇校验和偶校验进行编码,填在右面2栏。

【解】 假定最低一位为校验位，高8位为数据位，列表如下：



	校验位的值取0还是取1，是由数据位中1的个数决定的

奇偶校验码

奇偶校验码是一种最简单且应用广泛

硬件成本很低

可以检测出一位或奇数位错误，但不能确定出错位置，

也不能检测出偶数位错误

一位出错的概率比多位同时出错的概率要高得多

常用于存储器读写检查或ASCII字符传送过程检查

2024/6/5

35


2024/6/5

1

2.2定点加法、减法运算

2.2.1 补码加法

2.2.2 补码减法

2.2.3 溢出概念与检测方法

2.2.4 基本的二进制加法/减法器

2024/6/5

2

2.2.1补码加法

2024/6/5

3

[ｘ]补＋[ｙ]补＝[ｘ＋ｙ]补证明

2024/6/5

4

[ｘ]补＋[ｙ]补＝[ｘ＋ｙ]补证明

(3)ｘ<0,ｙ>0,则ｘ＋ｙ>0或 ｘ＋ｙ<0 

 这种情况和第2种情况一样,把ｘ和ｙ的位置对调即得证。 

(4)ｘ<0,ｙ<0,则ｘ＋ｙ<0 

　相加两数都是负数,则其和也一定是负数。

　∵[ｘ]补＝2n+1＋ｘ,　　　[ｙ]补＝2n+1＋ｙ

　∴[ｘ]补＋[ｙ]补＝2n+1＋ｘ＋2n+1＋ｙ

			 ＝2n+1＋(2n+1＋ｘ＋ｙ)= [ｘ＋ｙ]补

　　在模2n+1意义下,任意两数的补码之和等于该两数之和的补码。 

[例11] 设字长5位,ｘ＝+1001,ｙ＝+0101, 用补码求ｘ＋ｙ

[解:] [ｘ]补＝01001, [ｙ]补＝00101



 [ｘ]补　　　01001

 	 ＋[ｙ]补　　　00101　

 [ｘ＋ｙ]补　　01110　 



所以ｘ＋ｙ＝＋1110 



[例11] 设字长6位,ｘ＝+1001,ｙ＝+0101, 用补码求ｘ＋ｙ

[解:] [ｘ]补＝001001, [ｙ]补＝000101



 [ｘ]补　　　001001

 	 ＋[ｙ]补　　　000101　

 [ｘ＋ｙ]补　　001110　 



所以ｘ＋ｙ＝＋1110 



[例12]设字长5位,ｘ＝＋1011,ｙ＝－0101, 用补码求ｘ＋ｙ。

[解:][ｘ]补＝01011,　　[ｙ]补＝11011 



[ｘ]补　　　01011

＋[ｙ]补　　　11011　

 [ｘ＋ｙ]补　 100110　

 

 所以　ｘ＋ｙ＝+0110 

　　补码加法的特点，

一是符号位要作为数的一部分参加运算

二是符号位的进位要丢掉 

2024/6/5

8

2.2.2 补码减法

数用补码表示时，减法运算的公式为

[ｘ－ｙ]补＝[ｘ]补－[ｙ]补

 ＝[ｘ]补＋[-ｙ]补

只要证明[－ｙ]补＝－[ｙ]补,上式即得证。



现证明如下：

　∵　[ｘ＋ｙ]补＝[ｘ]补＋[ｙ]补　　　(模 2n+1)

　∴　[ｙ]补　＝[ｘ＋ｙ]补－[ｘ]补　　　(2.15)

又∵　[ｘ－ｙ]补＝[ｘ＋(－ｙ)]补＝[ｘ]补＋[－ｙ]补

　∴　[－ｙ]补 ＝[ｘ－ｙ]补－[ｘ]补　 (2.16)

将式(2.15)与(2.16)相加,得

[－ｙ]补＋[ｙ]补＝[ｘ＋ｙ]补＋[ｘ－ｙ]补－[ｘ]补－[ｘ]补

　　　　　　＝[ｘ＋ｙ＋ｘ－ｙ]补－[ｘ]补－[ｘ]补

　　　　　　＝[ｘ＋ｘ]补－[ｘ]补－[ｘ]补＝0

　故[－ｙ]补＝－[ｙ]补(模 2n+1)

从[ｙ]补求[－ｙ]补的法则：对[ｙ]补包括符号位“按位求反且加1”，即可得到[－ｙ]补。

写成运算表达式，则为

　　其中符号﹁表示对[ｙ]补作包括符号位在内的求反操作

[例13] 设字长5位，已知ｘ1＝－1110,ｘ2＝＋1101,

 求：[ｘ1]补,[－ｘ1]补,[ｘ2]补,[－ｘ2]补。

[解:]

　　　[ｘ1]补 ＝ 10010

　[－ｘ1]补 ＝ ﹁[ｘ1]补＋1

 ＝ 01101＋00001＝01110



　　　[ｘ2]补 ＝ 01101

　　[－ｘ2]补 ＝ ﹁[ｘ2]补＋1

 ＝ 10010＋00001＝10011



[例14] 设字长5位，ｘ＝＋1101,ｙ＝＋0110,求ｘ－ｙ。

[解:]

　　　　[ｘ]补＝01101

　　　　[ｙ]补＝00110　

[－ｙ]补＝11010

[ｘ]补　　　 　01101

＋[－ｙ]补　　 　11010　

 [ｘ－ｙ]补 　 100111



所以　ｘ－ｙ＝＋0111



[练习]设字长5位，ｘ＝-1001,ｙ＝-0110,求ｘ－ｙ。

[解:]

　　　　[ｘ]补＝10111

　　　　[ｙ]补＝11010　

[－ｙ]补＝00110

[ｘ]补　　　 　10111

＋[－ｙ]补　　 　00110　

 [ｘ－ｙ]补 　11101



所以　ｘ－ｙ＝-0011



[例15] ｘ＝＋1011,ｙ＝＋1001,求ｘ＋ｙ。

[解:]　　　[ｘ]补＝01011 [ｙ]补＝01001

[ｘ]补　　　01011

 ＋ [ｙ]补　　　01001 

[ｘ＋ｙ]补　　10100 

两个正数相加的结果成为负数,这显然是错误的。

[例16] ｘ＝－1101,ｙ＝－1011,求ｘ＋ｙ。

[解:]　　　[ｘ]补＝10011 [ｙ]补＝10101

[ｘ]补　　10011

＋　 [ｙ]补　　　10101 

 [ｘ＋ｙ]补　　01000

两个负数相加的结果成为正数,这同样是错误的。

2.2.3 溢出的概念与检测方法

2024/6/5

15

2.2.3 溢出的概念与检测方法

溢出的检测方法

单符号位法和双符号位法

双符号位法：用两个符号位表示一个数据，也称为“变形补码”

两个符号位一样参与运算

最高符号位产生的进位要丢弃

2024/6/5

16

2024/6/5

17

2.2.3 溢出的概念与检测方法

用双符号位法检测溢出



结果的两个符号位一致则没有溢出

如果两个符号位不一致则发生溢出

判断溢出的逻辑表达式为V=Sf1 ⊕ Sf2,可以用异或门来实现

2024/6/5

18

2.2.3 溢出的概念与检测方法

二、检验举例：

ｘ＝＋1100, ｙ＝＋1000,求ｘ＋ｙ 

ｘ＝－1100, ｙ＝－1000,求ｘ＋ｙ 

结果出现了01或10的情况就为溢出



[例] 设字长5位ｘ＝＋1100,ｙ＝＋1000,求ｘ+ｙ。

[解:]

　　　　[ｘ]补＝001101

　　　　[ｙ]补＝001000　

[ｘ]补　　　 　001101

＋[ｙ]补　　 　001000　

 [ｘ+ｙ]补 　010101



结果两个符号不同，表示溢出



2024/6/5

20

2.2.3 溢出的概念与检测方法

2、单符号位法

其中Cf为符号位产生的进位,C0为最高有效位产生

溢出检测V=Cf ⊕ C0 

2.2.4 基本的二进制加法/减法器

2024/6/5

21

 [X]补＝Xn Xn-1………X0

 [Y]补＝Yn Yn-1…….…Y0



+

?n ? n-1…….…?0

多位加法运算依赖于各位逐位相加的运算，

所以先讨论一位全加器

2.2.4 基本的二进制加法/减法器

半加器

两个二进制位相加



2024/6/5

22

Si＝Ai⊕Bi

Ci+1＝AiBi

全加器的真值表与表达式

23

Si ＝Ai⊕Bi⊕Ci

Ci＋1＝ AiBi＋BiCi＋CiAi

= AiBi ＋(Ai⊕Bi) Ci



输入: 加数Ai 、Bi、低位进位输入Ci

输出: 和Si ，进位输出Ci+1

2024/6/5

24

FA逻辑电路和框图



FA（全加器）逻辑电路图

延迟分析：

设异或门延迟为3T，与非门延迟为T

对一位全加器(FA)来说，Si的时间延迟为6T，Ci＋1的时间延迟为5T。

FA框图

4位补码加法器

2024/6/5

25

FA

FA

FA

FA

B0

B1

B2

B3

A0

A1

A2

A3

C0=0

S0

C1

S1

S2

S3

C2

C3

C4

溢出

符 号 位

单符号法检测溢出

只能完成补码加法

加法器的改造

2024/6/5

26

FA

FA

FA

FA

A3

M

S0

C1

S1

S2

S3

C2

C3

C4

溢出

符 号 位

B3

A2

B2

A1

B1

A0

B0

能完成补码加法和补码减法

[ｘ]补＋[ｙ]补＝[ｘ＋ｙ]补

[ｘ]补＋[-ｙ]补＝[ｘ-ｙ]补

4位补码加法器

2024/6/5

27

进位依次从地位传递高位，称为行波进位

当M＝0，加法[A]补＋[B]补运算；

当M＝1，减法[A]补- [B]补转化成[A]补＋[－B]补运算，异或。

4位补码加法器

2024/6/5

28

延迟分析：

找出时延最长的路径

B0->C1为3T+3T+2T=8T

C1->C2为10T

C2->C3为12T

C3->C4为14T

溢出为17T

2024/6/5

29

n位行波进位补码加法器

总延迟：从C0到溢出产生的延迟为(2n+9)T

8T(B0->C1)+2(n-1)T(C1->Cn)+3T(溢出)

	=(8+2n-2+3)T=(2n+9)T

加法器是算术运算电路的核心

所有算术运算都基于加法器实现

加法器不区分符号数与无符号数



2024/6/5

30


2.3定点乘法运算

采用软件实现乘法运算

利用加法运算指令，编写实现乘法的循环子程序

所需的硬件最少，但速度最慢

采用硬件实现乘法运算

串行乘法器

被乘数每次和一位乘数相乘

并行乘法器

被乘数同时和乘数所有二进制位相乘

硬件乘法器，需要乘法指令



1



硬件增加新的功能需要提供必要的指令

2



当前CPU支持的新指令

2.3.1原码并行乘法



3

1. 人工算法步骤



4



设ｘ＝1101,ｙ＝1011

　　　　　　　1101(ｘ) 　×　　　1011　(ｙ)

　　　　　1　1　0　1 

　　　 1　1　0　1

 0　0　0　0

＋ 1　1　0　1　 　

　　1　0　0　0　1　1　1　1　(ｚ)



1. 人工算法步骤



5



设ｘ＝1101,ｙ＝1011

　　　　　　　1101(ｘ) 　×　　　1011　(ｙ)

　　　　　1　1　0　1

　　　 1　1　0　1

 0　0　0　0

＋ 1　1　0　1　 　

　　1　0　0　0　1　1　1　1　(ｚ)



求部分积：从乘数 y 的最低位开始

逐位与被乘数相乘（与运算）

根据权重移位：每个部分积根据乘数的权相应左移

部分积相加：部分积统统加起来得到乘积z（z的位数扩大一倍）。

1. 人工算法步骤

求部分积：从乘数 y 的最低位开始

逐位与被乘数相乘（与运算）

根据权重移位：每个部分积根据乘数的权相应左移

部分积相加：将移位后的部分积统统加起来便得到最后乘积z（z的位数扩大一倍）。



6

计算机乘法的困难

两大困难

其一：两个n位数相乘，乘积为2n位。部分积、乘积如何存储?

其二：只有两个操作数相加的加法器如何将n个部分积相加？

设计高速并行乘法器的基本问题

就在于缩短部分积的加法时间

7



a4

a3

a2

a1

a0



两个5位的二进制无符号数相乘

乘数a和被乘数b都为5位，

乘积P为10位

阵列乘法器

b0

b1

b2

b3

b4

×

8



a3b2

a2b2

a1b2

a0b2

a4b2

a3b3

a2b3

a1b3

a0b3

a4b3

a4b0

a3b0

a2b0

a1b0

a0b0

a4b1



a3b4

a2b4

a0b4

a4b4

a1b4



两个5位的二进制无符号数相乘

乘数a和被乘数b都为5位，

乘积P为10位

生成所有部分积

9

 p1

p0



a3b2

a2b2

a1b2

a0b2

a4b2

a3b3

a2b3

a1b3

a0b3

a4b3

a4b0

a3b0

a2b0

a1b0

a0b0

a4b1



a3b4

a2b4

a0b4

a4b4

a1b4



表示全加器

斜线表示进位，竖线表示和

10

 p2

 p1

p0



a3b2

a2b2

a1b2

a0b2

a4b2

a3b3

a2b3

a1b3

a0b3

a4b3

a4b0

a3b0

a2b0

a1b0

a0b0

a4b1



a3b4

a2b4

a0b4

a4b4

a1b4



表示全加器

斜线表示进位，竖线表示和



11

 p2

 p1

p0



a3b2

a2b2

a1b2

a0b2

a4b2

a3b3

a2b3

a1b3

a0b3

a4b3

a4b0

a3b0

a2b0

a1b0

a0b0

a4b1



p3

a3b4

a2b4

a0b4

a4b4

a1b4



表示全加器

斜线表示进位，竖线表示和



12

 p2

 p1

p0



a3b2

a2b2

a1b2

a0b2

a4b2

a3b3

a2b3

a1b3

a0b3

a4b3

a4b0

a3b0

a2b0

a1b0

a0b0

a4b1



p3

p4

a3b4

a2b4

a0b4

a4b4

a1b4



表示全加器

斜线表示进位，竖线表示和



13

 p2

 p1

p0



a3b2

a2b2

a1b2

a0b2

a4b2

a3b3

a2b3

a1b3

a0b3

a4b3

a4b0

a3b0

a2b0

a1b0

a0b0

a4b1



p3

p4

p5

a3b4

a2b4

a0b4

a4b4

a1b4



表示全加器

斜线表示进位，竖线表示和



0



14

 p2

 p1

p0



a3b2

a2b2

a1b2

a0b2

a4b2

a3b3

a2b3

a1b3

a0b3

a4b3

a4b0

a3b0

a2b0

a1b0

a0b0

a4b1

p6



p3

p4

p5

a3b4

a2b4

a0b4

a4b4

a1b4



表示全加器

斜线表示进位，竖线表示和



0



15

 p2

 p1

p0



a3b2

a2b2

a1b2

a0b2

a4b2

a3b3

a2b3

a1b3

a0b3

a4b3

a4b0

a3b0

a2b0

a1b0

a0b0

a4b1

p6



 p7

p3

p4

p5

a3b4

a2b4

a0b4

a4b4

a1b4



表示全加器

斜线表示进位，竖线表示和



0



16

p8

 p2

 p1

p0



a3b2

a2b2

a1b2

a0b2

a4b2

a3b3

a2b3

a1b3

a0b3

a4b3

a4b0

a3b0

a2b0

a1b0

a0b0

a4b1

p6



 p7

p3

p4

p5

p9

a3b4

a2b4

a0b4

a4b4

a1b4



表示全加器

斜线表示进位，竖线表示和



0



17



p8

 p2

 p1

p0



a3b2

a2b2

a1b2

a0b2

a4b2

a3b3

a2b3

a1b3

a0b3

a4b3

a4b0

a3b0

a2b0

a1b0

a0b0

a4b1

p6



 p7

p3



p4

p5

p9

0

a3b4

a2b4

a0b4

a4b4

a1b4



4*5个全加器

斜线表示进位，竖线表示和



表示全加器



进位保留加法器

行波进位加法器

18



19

2、不带符号的阵列乘法器



不带符号阵列乘法器逻辑图

2、不带符号的阵列乘法器

20

3、带符号的阵列乘法器

对于补码表示的乘数和被乘数在使用阵列乘法器前，需先将补码转换为原码

求补电路

21

E=1，求补

E=0，直通输出

求补电路

22

3、带符号的阵列乘法器

求补器与原码阵列乘法器结合组成带符号的阵列乘法器

共使用三个求补器。

两个算前求补器：将操作数A和B变成正整数。

算后求补器：输出结果的补码。



23



24

3、带符号的阵列乘法器 



原码／补码

2.4 定点除法运算



25



26



0.

1

1

0

1

商q

2.4.1 原码除法运算原理

设被除数ｘ＝0.1001，除数ｙ＝0.1011，模仿十进制除法运算，以手算方法求ｘ÷ｙ的过程如下：　　　

 

　　　

 　

1 0 1 11 0 0 1 　 r0　被除数小于除数，不够减，商0

 －1 0 1 1　　 被除数低位补零，够减除数,商1

　　 1 1 1 　　　r1　　　得余数r1低位补零

　 －1 0 1 1　　 　够减除数,商1

　　　 1 1 　　r2　　　得余数r2低位补零

　　　 1 0 1 1　　 不够减除数,商0

　　　 1 1 0　r3　　　余数r3低位补零

　－ 1 0 1 1　 够减除数,商1

　　　 1　r4　　　得余数r4 



27



0.

1

1

0

1

商q

2.4.1 原码除法运算原理

设被除数ｘ＝0.1001，除数ｙ＝0.1011，模仿十进制除法运算，以手算方法求ｘ÷ｙ的过程如下：　　　

0

0

0

0

2.4.1 原码除法运算原理

二进制除法实质:“被除数（余数）减除数，求新余数”

人工算法：

求商时从高位向低位逐位求，商符单独处理 

每次上商都是由心算来比较余数和除数的大小，确定商1还是0

每做一次减法，总是保持余数不动，低位补0，再减去右移后的除数。

重复上一步骤，直到余数为0，或商的位数满足要求



28

2.4.1 原码除法运算原理



29

2.4.1 原码除法运算原理

补充：编码的移位

机器数为正时，不论左移或右移，添补代码均为0。

负数原码在移位时符号位不变，其空位均添0。

负数反码在移位时符号位不变，其空位均添1。 

负数补码在移位时，符号位不变，左移添0，右移添1.

30

补充：编码的移位

实例：A=-26，用8位二进制表示，写出三种机器数左移一位、右移一位、左移两位和右移两位后的表示形式及其真值。



10110100

10001101

11101000

10000110

11001011

11110010

10010111

11111001

11001100

11110011

10011000

11111001

-52

-13

-104

-6

-52

-13

-104

-6

-52

-13

-104

-7

31

[例23] ｘ＝0.101001, ｙ＝0.111, 求ｘ÷ｙ。（恢复余数法计算）

[解:]　　[ｙ]补＝0.111[-ｙ]补＝1.001

　　　　　　　　被除数ｘ　0.1 0 1 0 0 1　　　　　　　　　　减ｙ　1.0 0 1　               　

　　　　　　　　余数为负　1.1 1 0 0 0 1＜0　　　q4＝0

不够减，恢复余数加ｙ　0.1 1 1　

0.1 0 1 0 0 1

 　　　　y右移1位 减　1.1 0 0 1　 　     　　 

　　　　　　　　余数为正　0.0 0 1 1 0 1＞0　 　 q3＝1

　　　　　　右移2位减　1.1 1 0 0 1　     　　　 

　　　　　　　　余数为负　1.1 1 1 1 1 1＜0　　q2＝0

不够减，恢复余数加ｙ　0.0 0 1 1 1

0.0 0 1 1 0 1

　　　　　　ｙ右移3位减　1.1 1 1 0 0 1 　　　     　 

　　　　　　　　余数为正　0.0 0 0 1 1 0　＞0 　 　q1＝1

故得　　　　 　商 q ＝ q4.q3q2q1 ＝ 0.101　　　



32

2.4.1 原码除法运算原理

33

恢复余数法

34

不恢复余数法（加减交替法）

35

36

Y

N

结束

Y

N

Y

N



37



38

2、不恢复余数的除法


2024/6/5

1

2.5定点运算器的组成

2.5.1逻辑运算

2.5.2多功能算术/逻辑运算单元ALU

2.5.3内部总线

2.5.4定点运算器的基本结构

2024/6/5

2

2.5.1 逻辑运算

计算机中的逻辑运算，主要是指逻辑非、逻辑加、逻辑乘、逻辑异或四种基本运算。

非运算：按位反

逻辑加：按位或

逻辑乘：按位与

异或运算：又称“按位加”

移位运算

左移n位等于乘2n

右移n位等于除2n

移位和加法结合，实现乘（除）运算

有符号数的移位称算术移位

空出位补0或1

无符号数的移位称逻辑移位

空出位补0

移位运算-算术移位

有符号数的移位叫算术移位 

机器数为正时，不论左移或右移，添补代码均为0。

负数原码在移位时符号位不变，其空位均添0。

负数反码在移位时符号位不变，其空位均添1。 

负数补码在移位时，符号位不变，左移添0，右移添1.

补充：编码的移位

实例：A=-26，用8位二进制表示，写出三种机器数左移一位、右移一位、左移两位和右移两位后的表示形式及其真值。



10110100

10001101

11101000

10000110

11001011

11110010

10010111

11111001

11001100

11110011

10011000

11111001

-52

-13

-104

-6

-52

-13

-104

-6

-52

-13

-104

-7

2024/6/5

6

2.5.2多功能算术/逻辑运算单元ALU

由全加器构成的加法器，可以实现补码的加法/减法运算。问题：

由于串行进位它的运算时间很长

不能完成逻辑运算

以加法器为核心的算术/逻辑运算单元(ALU- Arithmetic Logic Unit)

具有算术和逻辑运算的功能

先行进位逻辑，能实现高速加法运算

2024/6/5

7

2.5.2多功能算术/逻辑运算单元ALU

改变FA的输入端Ai和Bi来实现算术运算和逻辑运算功能。

一位全加器FA



将Ai和Bi输入一个函数发生器得到输出Xi和Yi，作为一位全加器的输入。

2024/6/5

8

1位ALU的逻辑图与逻辑表达式

控制参数

2024/6/5

9

2.5.2多功能算术/逻辑运算单元ALU

可以处理16种算术\逻辑运算，

每种运算只针对1位二进制

10

2.5.2多功能算术/逻辑运算单元ALU

进一步化简得到下式

代入全加器的求和与进位表达式，可得如下逻辑表达式

2.5.2多功能算术/逻辑运算单元ALU

2024/6/5

11

2.5.2多功能算术/逻辑运算单元ALU

2024/6/5

12

2024/6/5

13

2.5.2多功能算术/逻辑运算单元ALU

4位ALU:4个1位ALU串行连接



能进行4位算术和逻辑运算

进位信号太慢

2024/6/5

14

2.5.2多功能算术/逻辑运算单元ALU



  串行进位，速度慢

Cn＋1

Cn＋2

Cn＋3

Cn＋4

15

对串行进位的改进

串行改并行



先行进位

（CLA- Carry Look Ahead ）

2.5.2多功能算术/逻辑运算单元ALU

Cn＋4＝Y3＋Y2X3＋Y1X2X3＋Y0X1X2X3＋X0X1X2X3Cn

令G＝Y3＋Y2X3＋Y1X2X3＋Y0X1X2X3P＝X0X1X2X3

G(Generation)为进位发生函数

P(Propagation)为进位传递函数

增加P和G的目的在于实现多片ALU之间的先行进位

Cn＋4＝G＋PCn

16

逻辑电路图

2024/6/5

17

G＝Y3＋Y2X3＋Y1X2X3＋Y0X1X2X3P＝X0X1X2X3

2024/6/5

18

74181 4位ALU逻辑图



函数发生器



先行进位



运算方式

控制



A=B？

2024/6/5

19

74181功能

20

2.5.2多功能算术/逻辑运算单元ALU

4片74181组成16位ALU



片内先行进位，片间串行进位



21

2.5.2多功能算术/逻辑运算单元ALU

4片74181组成16位ALU



C4=G0+P0C0C8=G1+P1C4

 C12=G2+P2C8 C16=G3+P3C12



Cn＋ｘ＝G0＋P0Cn

Cn＋ｙ＝G1＋P1Cn＋ｘ＝G1＋G0P1＋P0P1Cn

Cn＋ｚ＝G2＋P2Cn＋ｙ＝G2＋G1P2＋G0P1P2＋P0P1P2Cn

Cn＋4 ＝G3＋P3Cn＋ｚ

＝G3＋G2P3＋G1P1P2＋G0P1P2P3＋P0P1P2P3Cn

＝G*＋P*Cn

P*＝P0P1P2P3

G*＝G3＋G2P3＋G1P1P2＋G0P1P2P3 

根据以上表达式实现的部件称为74182（组间先行进位产生器），与4个74181配合使用

74182的逻辑电路图　

23

2024/6/5

24

16位先行进位ALU



片内先行进位，片间先行进位



2024/6/5

25

32位ALU 

2片741828片74181



64位先行进位系统

 16片74181 ，5片74182芯片组成多级先行进位



2.5.3 内部总线

将计算机各个部件之间的数据传送通路加以归并，组成总线结构

任何一个时刻，总线上只能有一个来源的数据，数据源独占总线

不同来源的信息在总线上分时传送

只要数据源不撤销数据，该数据在总线上一直存在

根据所在位置分类：

内部总线：CPU内各部件的连线

外部总线：CPU与存储器、I/O系统之间的连线

2024/6/5

27

2.5.3 内部总线

按总线的逻辑结构分：

单向总线：信息只能向一个方向传送。

传送地址信息或控制信息的总线

双向总线：信息可以两个方向传送

数据总线既可以发送数据，也可以接收数据。

总线的基本电路是三态门

逻辑1、逻辑0、高阻



2024/6/5

28

29

2.5.4 定点运算器的基本结构

基本组成包括：

ALU：核心部件

乘除法器，组合逻辑电路

数据存储部件：存放参与计算的数据及运算结果

暂存器：只对硬件设计者可见

通用寄存器：可以被软件设计者所访问 

内部总线：连接各个部件的通道 

30

2.5.4 定点运算器的基本结构

一个二元运算需要两个操作数，产生一个结果

操作数 op 操作数 = 操作结果

按照数据从存储部件传输到ALU的方式将ALU分为三种结构

单总线，双总线，三总线



1、单总线结构的运算器

两个操作数要分两次输入到ALU

需要A、B两个暂存器临时保存操作数

操作速度慢、控制简单

2024/6/5

31

一次运算要三步完成：

通用寄存器->A

通用寄存器->B

A+B,ALU->通用寄存器

2、双总线结构的运算器

两个操作数通过两条总线同时输入到ALU进行运算

ALU的输出经过缓冲器送入通用寄存器

因为ALU的输入数据没有暂存器，计算过程中，两条总线都被输入数据占据，必须在ALU输出端设置缓冲器。

2024/6/5

32

一次运算要两步完成：

通用寄存器->总线1 ，通用寄存器->总线2， 总线1+总线2>缓冲器

缓冲器->通用寄存器

3、三总线结构的运算器

总线旁路器：总线之间的数据传送

一次运算一步完成：

通用寄存器->总线1 ，通用寄存器->总线2， 总线1+总线2>总线3，总线3->通用寄存器

速度快，硬件复杂，成本高

33

Intel 8086运算器结构

34

通用寄存器

暂存器

标志寄存器

16位ALU

单总线结构

ARM的ALU

35

三总线结构

通用寄存器

Intel pentuim的ALU



36

三总线结构

通用寄存器

CPU和GPU

37

GPU中有海量的ALU，因而其计算能力很强大

GPU的ALU



38

GTX 1080的核心GP104 

每个SM 有128个 CUDA内核（绿色方块）

CUDA内部

39




2024/6/5

1

2.6浮点运算方法和浮点运算器

2.6.1 浮点加法、减法运算

2.6.2 浮点乘法、除法运算

2.6.3 浮点运算流水线

2.6.4 浮点运算器实例



2.6.1 浮点加法、减法运算

2

2024/6/5

3

2.6.1 浮点加法、减法运算

浮点加减运算步骤如下：

1. 0操作数检查；

2. 比较阶码大小并完成对阶；

3. 尾数求和/差运算；

4. 结果规格化

5. 舍入处理

6. 溢出处理



2024/6/5

4

2.6.1 浮点加法、减法运算

0 操作数检查

能否简化操作、节省运算时间

比较阶码大小并完成对阶

对阶：使得小数部分可以按位权值相加

变为定点数

定点加法器运算

小数点位置是否对齐

对阶:小阶向大阶看齐

2.6.1 浮点加法、减法运算

两个浮点数相加：

1.11011×23 1.11011×25

浮点格式中，尾数为定点小数

如果向小阶对齐，尾数左移

易导致高位数据丢失

如果向大阶对齐，尾数右移

丢失的是低位数据

5

2024/6/5

6

2.6.1 浮点加法、减法运算

2024/6/5

7

2.6.1 浮点加法、减法运算

2024/6/5

8

IEEE 754的四种舍入方法

就近舍入：类似于四舍五入，

多余位：最低有效位之后的若干位，用于舍入判断

多余位中间值位： 100…0

多余位比100…0大，进位；比100…0小，舍去

对于100……0的情况：

有效位末尾是1：进1

有效位末尾是0：舍弃

例：保留有效位到0.001

 0.10111-0.00101

 0.11110-0.01010

IEEE754的四种舍入方法

朝0舍入：截尾

保留有效位到0.001：

 0.10111-0.00101

 0.11110-0.01010



9

2024/6/5

10

IEEE754的四种舍入方法

IEEE754的四种舍入方法

11

M＝10011001100110011001100110011

例题：真值0.2，求32位单精度浮点数

② 移动小数点，使其在第1、2位之间

S＝0

e＝-3，E＝-3+127＝124＝01111100

③ 得到32位浮点数的二进制存储格式为：

0011 1110 0100 1100 1100 1100 1100 1101

＝(3E4CCCCD)16



23位

就近舍入



2024/6/5

13

2.6.1 浮点加法、减法运算

真值0的机器数（机器零）

阶码E＝0，尾数M＝0

正0：S＝0，负0：S＝1

非规格化浮点数：阶码E＝0，尾数M≠0

规格化浮点数：阶码E＝1～254（11111110）

无穷大的机器数

阶码E＝全1（11111111） ，尾数M＝0

＋∞：S＝0，－∞：S＝1

NaN（not a number，不是一个数）

阶码E＝全1（11111111） ，尾数M≠0

用来通知异常情况

IEEE 754标准

32位单精度浮点数



2024/6/5

15

2.6.1 浮点加法、减法运算

2.6.2 浮点乘法、除法运算 

22

2.6.2 浮点乘法、除法运算 　

23

2.浮点乘、除法运算步骤

浮点数的乘除运算大体分为六步：

　　 ①0 操作数检查；

②阶码加/减操作；

③尾数乘/除操作；

④结果规格化；

⑤舍入处理；

⑥确定积的符号；

2.6.2 浮点乘法、除法运算 　

(1) 浮点数的阶码运算

乘法：两阶码求和，减偏移量

除法：两阶码求差，加偏移量

(2)尾数处理

规格化与舍入

与浮点加减法相同

24

现代处理中的浮点运算单元

浮点运算单元FPU，floating-point Unit

27

华为海思麒麟990

4个ALU、2个FPU

ARM A77中的FPU

28

RISC-V中的FPU

用于物联网的一种处理器架构

平头哥玄铁910

3个ALU、1个FPU

29

龙芯3A4000

30

FP32浮点性能比较

31

以 CNN 为例，用于输入图像大小为224× 224 的分类任务的典型 CNN 模型需要高达 390 亿次(39G)FLOP和500 MB 以上的模型参数。 

第二章小结

一个定点有符号数由符号位和数值域两部分组成。按小数点位置不同，定点数有纯小数和纯整数两种表示方法。

按 IEEE754 标准，一个单精度浮点数由符号位S、阶码E、尾数M三个域组成。阶码E等于指数的真值e加上固定偏移值127

32

第二章小结

数的真值变成机器码时四种表示方法：原码，反码、补码和移码

移码主要用于表示浮点数的阶码

字符信息属于符号数据，国际上采用的字符系统是7位的ASCII码。

汉字有输入码、汉字内码和输出码三种不同用途的编码。

为运算器构造的简单性，运算方法中算术运算通常采用补码加、减法，原码乘除法。

33

第2章教学要求-1

掌握定点整数（有符号数和无符号数）的表示范围

掌握IEEE754 单精度浮点格式的表示，规格化，与真值的相互转换

理解真值和机器数，掌握定点整数的补码、反码、原码，理解移码表示法

了解汉字输入编码、机内码、输出码

理解检验码的作用，掌握奇偶校验

第2章教学要求-2

掌握补码加减法运算

掌握溢出的概念及检测方法

理解运算器的三种组成方式

掌握浮点加减法运算步骤

理解IEEE754标准的4种舍入处理方法，掌握就近舍入


C语言数据表示

非数值数据 char(8位)

数值数据

定点整数 

signed / unsigned

char(8位)/short（16位）/int（32位）/long（64位） 

浮点数

Float（32位）/double（64位）



 -1- 

C语言中的整数（定点数）

无符号整数

unsigned char/unsigned short/unsigned int 

一般用于地址运算

有符号整数

char/short/int/long

采用补码表示

无符号整数/带符号整数的最大值

8位无符号整数最大是255（1111 1111）

8位带符号整数最大为+127（0111 1111）



 -2- 

编程实践

在线编程网站

https://c.runoob.com/compile/9

c、c++、python等

https://gcc.godbolt.org/

离线

python：anaconda

c：ubuntu、gcc

数据的真值、机器码、存储值间的关系

3

C语言中的机器码？ ex2_1.c

 -4- 

int main()

{

char a=127,b=128,c=129,d=257; 

printf("%d\n",a);

printf("%d\n",b);

printf("%d\n",c);

printf("%d\n",d);

}

127

-127

-128

？？？？

无符号数赋值

补码真值输出

变量a,b,c,d机器码实际存储值是多少？

1

变量的内存值 ex2_2.c 

 -5- 

main()

{

char a=127,b=128,c=129,d=257; 

printf("a = %d =%X\n",a,a);

printf("b = %d =%X\n",b,b);

printf("c = %d =%X\n",c,c);

printf("d = %d =%X\n",d,d);

}

a = 127 = 7F

b = -128 = FFFFFF80

c = -127 = FFFFFF81

d = 1 = 1

补码输出

机器码输出

32位补码表示范围

[-231，231-1]

 -6- 

0000 0000 0000 0000 0000 0000 0000 0000two = 0100000 0000 0000 0000 0000 0000 0000 0001two = + 1100000 0000 0000 0000 0000 0000 0000 0010two = + 210...0111 1111 1111 1111 1111 1111 1111 1110two = + 2,147,483,646ten0111 1111 1111 1111 1111 1111 1111 1111two = + 2,147,483,647ten1000 0000 0000 0000 0000 0000 0000 0000two = – 2,147,483,648ten1000 0000 0000 0000 0000 0000 0000 0001two = – 2,147,483,647ten1000 0000 0000 0000 0000 0000 0000 0010two = – 2,147,483,646ten...1111 1111 1111 1111 1111 1111 1111 1101two = – 3ten1111 1111 1111 1111 1111 1111 1111 1110two = – 2ten1111 1111 1111 1111 1111 1111 1111 1111two = – 1ten	

程序 ex2_3.c

 -7- 

main()

{

int x=-1;

unsigned u = 2147483648;

printf ("x = %u = %X = %d\n",x,x,x);

printf ("u = %u = %X = %d\n",u,u,u);

}

机器码输出

真值赋值

 x = 4294967295 = FFFFFFFF = -1

 u = 2147483648 = 80000000 = -2147483648

无符号数输出

一个奇怪的程序ex2_4.c

8

main()

{

	double a,b,c; 

	int d;

	b = 3.3; c = 1.1;

	a = b/c;

	d = b/c;

	printf("%f,%d\n",a,d);

	if (3.0!=a)

 		printf("Really? 3.0!=a\n");

}

3.000000,2

??????????

Really?3.0!=a

二进制存储

浮点数不是精确数

浮点转整数只保留浮点数的整数部分

Double 3.3/1.1 ex2_5.c

main()

{

double a,b,c;

b = 3.3; c = 1.1;

a = b/c;

printf("a = %.60f \n",a);

printf("b = %.60f \n",b);

printf("c = %.60f \n",c);

printf("a = %f,n",a);

}

 -9- 

a = 2.999999999999999555910790149937383830547332763671875000000000

b = 3.299999999999999822364316059974953532218933105468750000000000

c = 1.100000000000000088817841970012523233890533447265625000000000 

a = 3.000000 

一个奇怪的程序 ex2_6.c

10

main()

{

float a,b,c; 

int d;

b = 3.3; c = 1.1;

a = b/c;

d = b/c;

printf("%f,%d\n",a,d);

if (3.0!=a)

printf("Yeah!\n");

}

3.000000,3

Float 3.3/1.1 ex2_7.c

main()

{

float a,b,c;

b=3.3; c=1.1;

a=b/c;

printf(" = %.60f \n",a);

printf("b = %.60f \n",b);

printf("c = %.60f \n",c);

}

 -11- 

a = 3.000000000000000000000000000000000000000000000000000000000000

b = 3.299999952316284179687500000000000000000000000000000000000000

c = 1.100000023841857910156250000000000000000000000000000000000000

a = 3.000000

舍入的影响

例题

假定变量i、f和d的数据类型分别为int、float和double（int用补码表示，float和double分别用IEEE 754单精度和双精度浮点数格式表示），已知i=785，f=1.5678e3，d=1.5e100。若在32位机器中执行下列关系表达式，则结果为“真”的是I．i == (int)(float)i     II．f == (float)(int)fIII．f == (float)(double) f    IV．(d+f)-d == fA．仅I和II 			B．仅I和III

C．仅II和III 		D．仅III和IV 

解答

float到double的转换完全相等

double到float转换可能会发生舍入

float/double到int，小数部分会丢弃

int到float，当int有效数字超过24位，转换时需要舍入

int到double，double尾数53位，能精确表示int型

13

I．i == (int)(float)i

float是单精度，尾数24位

int型有效数字有31位

i=785,能实现精确转换，条件成立

若i = 16777217=224-1 

14

II．f == (float)(int)f

f= 1.5678e3

浮点转换整数，只保留整数部分，小数部分舍去

条件不成立

15

III．f == (float)(double) f

双精度尾数53位

f = 1.5678e3,单精度

float转double有效数字不变,条件成立

若double f = 1.5678e3

f ==(double)(float)f则不成立

16

IV．(d+f)-d == f

浮点运算不满足交换律、结合律

(d+f)-d 不等于 (d-d)+f

(d+f)-d 不等于 d+(f-d)

C语言中单双精度混合运算，都按照双精度处理

大数吃小数，两个差别巨大的浮点数相加，较小的数由于有效数字位数不够，会被舍去



17

浮点处理精度造成的事故

1990年2月25日，海湾战争期间，在沙特的爱国者导弹防御系统未能拦截一枚伊拉克飞毛腿导弹，造成28名美军死亡。

原因是浮点数舍入误差导致

爱国者反导系统的计算机精度仅有24位，存在0.0001%的计时误差，所以有效时间阙值是20个小时。当系统运行100个小时以后，已经积累了0.3422秒的误差。这个误差导致导弹系统不能正确地瞄准目标。



浮点处理精度造成的事故

19

失之毫厘，谬以千里

浮点处理精度问题解决办法

制度：每隔二十小时重启一次

硬件：修改24位为32位或64位

软件：升级软件

20

其他案例

1996年6月4日，在阿丽亚娜五号运载火箭发射后37秒，偏离预定轨道炸毁。原因是软件系统将64位浮点数转换为16位浮点数，造成计算错误。

温哥华证券交易所在1982年推出一项股票指数，指数的值是1000.000。后来，重新计算时多次运用舍入到小数点后三位的操作。22个月以后，指数的值是524.881，然而事实上应该是1009.811

21

浮点处理精度问题

树立计算机系统的思想，理解软硬件的相互影响

小概率事件常会导致大损失，在工程实践中要精益求精

22


1

第三章 多层次存储器

3.1 存储器概述

3.2 SRAM存储器

3.3 DRAM存储器

3.4 只读存储器和闪速存储器

3.5 并行存储器

3.6 Cache存储器

3.7 虚拟存储器

3.8 奔腾系列机的虚存组织



3.1 存储器概述

存储器是计算机系统中的记忆设备，用来存放程序和数据

存储器中最小的存储单位叫存储元，可存储1bit

若干个存储元组成一个存储单元

许多存储单元组成一个存储器

2

3.1.1 存储器的分类

按存储介质

满足两个基本要求：

有两个明显区别的状态，分别表示0和1

两个状态的改变速度要快，影响存储器的读写速度

半导体存储器：内存，闪存

速度快、容量小，成本高

磁表面存储器：磁带、磁盘

容量大，速度慢、成本低

光盘存储器：DVD、蓝光

容量大，速度慢，成本低

按存取方式　　

随机存储器RAM（Random Access Memory）

任何存储单元的内容都能被随机存取，且存取时间和存储单元的物理位置无关

内存

顺序存储器

按顺序存取，存取时间和存储单元的物理位置有关

磁带、磁盘

3

3.1.1 存储器的分类

按信息掉电易失性　

非易失性存储器Non-Volatile Memory

断电后仍能保存信息

磁表面存储器、光盘存储器、闪存

易失性存储器Volatile Memory

断电后信息立即消失

内存(SRAM、DRAM)

半导体存储器按其存储内容可变性

只读存储器(ROM-Read Only Memory)

存储的内容一般是固定不变的，只能读出而不能写入

随机读写存储器(RAM)：

既能读出又能写入



4

3.1.1 存储器的分类

按在计算机系统中的作用 　　

主存储器：和CPU直接交换信息

辅助存储器：主存的后援存储器

高速缓冲存储器Cache：用于两个速度不同的部件之间，起到缓冲作用

控制存储器等

5

3.1.2 存储器的层次结构

CPU对存储器的要求

容量大、速度快、价格低（每位价格）

目前技术下，存储器的特点是：

速度快的存储器价格贵，容量小；

价格低的存储器速度慢，容量大

不可能三角:既要。。。又要。。。。还要。。。。

从在容量，速度和价格作折中考虑，建立存储器层次结构

6

存储系统层次结构



存储速度

访问频率

单位成本



存储容量



外存/辅存

内存

 -7- 

8

3.1.2存储器分级结构

三级存储系统

3.1.3 存储器的编址和端模式

存放一个字节的单元称为字节存储单元，其地址称为字节地址

一个字由多个字节组成，存放一个字的单元称为字存储单元，其地址称为字地址

存储器编址

编址的最小单位是字单元，称为按字编址

编址的最小单位是字节单元，称为按字节编址

既可以按字编址，也可以按字节编址

存储器访问

按地址访问：按字节地址访问、按字地址访问。

9

字的概念

字：word

a word is the natural unit of data used by a particular processor design. 

一串固定长度的二进制数，对应部件处理数据的固定长度。

不同的部件其字长不同

计算机字长、机器字长、运算器字长

存储器字长、存储芯片字长

指令字长



10

存储器的编址

11



字节地址

机器字长32位

16个字节存储单元组成存储器

按字节编址

存储器的编址

12

机器字长32位

16个字节存储单元组成存储器

按字编址

存储器的编址

13



字节地址

机器字长32位，16个字节存储单元

字节编址下按字访问

存储该字的第一个字节的字节单元地址为该字的字地址

存储器的编址

14



字节地址

机器字长16位，

16个字节存储单元

存储器的编址

设有一个1MB容量的存储器，字长32位，问：按字节编址，按字编址各自的寻址范围? 

按字节编址：

20位字节地址，0x0~0xFFFFF

按字编址：

18位字地址，0x0~0x3FFFF

15

数据的存储和排列顺序

上世纪80年代开始，几乎所有计算机都以字节编址

存储系统和指令设计时要考虑的问题（按字节编址，按字访问）：

一个字如何在字节单元存放？

- 字的存放顺序问题(端模式\字节序\端序\尾序)

字地址与字节地址关系

- 字的边界对齐问题



存储器的端模式：存储字为多个字节时，在存储器中存放顺序

大端(big-endian)：大尾端优先存储，高字节在低地址

MIPS，IBM 360/370, Sparc, 网络传输

小端(little-endian)：小尾端优先存储，低字节在低地址。

X86(高高低低)

ARM的端模式可通过寄存器改变

 -16- 

3F

27



LSB



MSB



A8

31

D0

D31

3F

27



LSB



MSB



A8

31

D0

D31

数据在内存中的存放顺序

将0x12345678写入到以0x0000开始的内存中



 -19- 

内存地址对齐

20

内存按字节编址

16位访问对齐

32位访问对齐

字节编址下的按字访问：

以一个字中最低字节的字节地址作为该字的字地址

对齐：

字地址能被字节数整除。

字长为16位，包含2个字节，其字地址能被2整除，地址最低位为0；

字长为32位，包含4个字节，其字地址能被4整除，最低两位为0.

Alignment(对齐)

 -21- 

 如：int i, short k, double x, char c, short j,……

 则：&i=0; &k=4; &x=8; &c=16; &j=18;……

x：2个周期

j：1个周期

目前来看，浪费一点存储空间没有关系！ 

 则： &i=0; &k=4; &x=6; &c=14; &j=15;……

x：3个周期

j：2个周期

存储器按字节编址，CPU按字对齐访问，字长32位

变量地址没有对齐

变量地址对齐

虽节省了空间，但增加了访存次数！

22

#include <stdio.h>

//内存对齐测试

int memory_display(long unsigned int addr)

//以16进制输出 addr开始的16个内存字节单元

{

int i,j;

for(i=0;i<4;i++)

{

printf("0x%lX:\t",addr + i*4);

for(j=0;j<4;j++)

{

printf("0x%X \t ", *(unsigned char*)(addr + i*4 +j));

}

printf("\n");

 }

 return 0;

}

int main()

{

int i = 13457;

short j = 345;

char c='A';

int k=123;



printf("i=0x%X\n",i);

printf("j=0x%X\n",j);

printf("c=0x%X\n",c);

printf("k=0x%X\n",k);

printf("int I memory address is 0x%lX\n",(long unsigned int)&i);

printf("short j memory address is 0x%lX\n",(long unsigned int)&j);

printf("char c memory address is 0x%lX\n",(long unsigned int)&c);

printf("int k memory address is 0x%lX\n",(long unsigned int)&k);

memory_display((long unsigned int)&i-16);

memory_display((long unsigned int)&i);

}

23

内存对齐是一种软硬件协同提高性能的一种方式

3.1.4 主存储器的技术指标

3.2 SRAM存储器

内部存储器是半导体存储器

根据信息存储的机理不同可以分为两类：

静态读写存储器(SRAM- Static)：

速度快、成本高、容量小、功耗低，一般用作Cache

动态读写存储器(DRAM-Dynamic)：

容量大、成本低、速度慢、功耗高、用作主存



25

26

3.2.1 基本的静态存储元阵列

存储位元

SRAM的存储位元是由两个MOS反相器交叉耦合而成的触发器，一个存储位元存储一位二进制代码

六管SRAM存储元的电路结构示意图

3.2.1 基本的静态存储元阵列

三组信号线

地址线

字数

数据线

字长

控制线

27

单译码结构：1个译码器N位地址，寻址2n个存储单元

存储元阵列又称存储芯片

63

芯片容量=字数X字长

=存储单元数量X存储单元字长

3.2.2 基本的SRAM逻辑结构

大容量SRAM芯片采用双译码方式：将地址分成行、列两部分，降低译码电路的规模

CS：Chip Select 片选

3.2.3 读/写周期波形图

先给地址，再给片选和读信号

3.2.3 读/写周期波形图

先给地址，再给片选和是写信号



3.3.1 DRAM存储位元的记忆原理

DRAM存储器的存储位元是由一个MOS晶体管和电容器组成的记忆电路 



31

电容用于存储电荷，有电荷代表1，否则代表0

MOS管

电容器



读放



读出1是破坏性读出

由于(c)中读出1是破坏性读出，必须恢复存储位元中原存的1

输入缓冲器关闭，刷新缓冲器打开，输出缓冲器读放打开，

DOUT=1经刷新缓冲器送到位线上，再经MOS管写到电容上



3.2.2 DRAM芯片的逻辑结构

两个电源Vcc

两个地线脚

一个空管教NC

11个地址线A0~A11

4个数据线D1~D4



36

方法：复用地址线A0-A9

存储器需要地址20位，但芯片物理地址引脚只有11位，如何处理？

1M×4位DRAM芯片的管脚图

37

3.2.2 DRAM芯片的逻辑结构



与SRAM芯片不同之处

增加了行地址锁存器和列地址锁存器

增加了刷新控制电路

DRAM读出后必须刷新，而未读写的存储元也要定期刷新（电容自放电），

按行刷新，刷新计数器的长度等于行地址锁存器

刷新操作与读/写操作交替进行

通过2选1开关来选择刷新行地址或正常读/写的行地址

38

3.3.3 读/写周期、刷新周期

39

先给行地址和行选通，再给列地址和列选通

40

3.3.3 读/写周期、刷新周期

3.3.3 刷新周期

刷新：DRAM存储元基于电容器上的电荷存储信息，电荷量随着时间和温度而减少，因此必须定期地刷新，以保持原来记忆的正确信息

刷新过程：将原有信息读出，再由刷新放大器形成原信息并重新写入的过程

刷新按行进行

刷新周期：从上次对整个存储器刷新结束到下次对整个存储器全部刷新一遍为止的时间间隔称为刷新周期

集中式刷新 

分散式刷新

41

集中刷新方式



例:1024行, 工作周期=500ns, 刷新周期=8ms

8ms内集中安排所有刷新周期

总工作周期数= 8ms/500ns = 16000个

用在实时要求不高的场合

集中式刷新：DRAM的所有行在每一个刷新周期中都被刷新刷新期间停止正常读写

分散刷新方式



各刷新周期分散安排在8ms内

每隔一段时间刷新一行

每隔15.5微秒提一次刷新请求，刷新一行；8毫秒内刷新完所有行

用在大多数计算机中

8ms



1024行

≈7.8 微秒=7800ns

主存储器特点

由半导体存储器组成

存储单元：字存储单元，字节存储单元

编址：按字节编址

按地址进行访问：字节地址访问字，访问字节

属于随机访问存储器RAM

DRAM需要刷新

 -44- 

3.3.5 高级的DRAM结构

FPM DRAM：快速页模式动态存储器

SDRAM同步动态存储器

读写操作与CPU时钟同步,

猝发式读取：输入一个行地址，一个列地址，连续读出后续几个列地址数据



45

输入一个行地址，连续输入多个列地址，该行中的对应列的存储单元数据就连续输出 

DDR SDRAM

DDR：Double Date Rate

DDR在相同时钟频率下的数据传输速率比SDRAM提高一倍

上下沿都传输数据



DDR2、DDR3：时钟频率比上一代提高一倍，速率提高一倍



46



DDR SDRAM



47

全球DRAM产业

三星技术最先进，产量最大

2021 年 10 月开始大规模生产基于 EUV 的 14nm DDR5 

48



49

中国DRAM产业发展

1975年，中国第一块1K DRAM诞生，但总体技术力量薄弱，和国外差距比较大，没有竞争力。

21世纪后，通过政府扶持、自主研发、技术引进、收购等方式逐步建立起国产DRAM产业。

2015年的紫光收购德国奇梦达、收购美国ISSI。

目前，国产DRAM市场的主要厂家紫光国芯、福建晋华、合肥长鑫、长江存储等。

2019年 9 月，合肥长鑫宣布正式量产 DDR4 

2023年预计将试产17nm DDR5,产能大约能占到全球内存产能的 3%，目前最被看好

50

困难和阻力

全球半导体需求将近1/3来自中国

2016年开始，美光开始对福建晋华发起诉讼

2018年10月30日，美国商务部将福建晋华添加进实体清单，导致整个企业进度不理想

2017年，美光曾对从台湾华亚科跳槽到合肥长鑫的上百名员工发存证信函

51

砥砺前行

从DRAM内存的角度来说，中国企业在技术、产业链方面，距离全球顶尖的厂商都有较大的差距，产品自给率方面更是不容乐观。

我们需要进一步加大企业自主创新+国家意志支持的力度，坚定IDM的发展模式，进行产业全链路的布局，高度重视技术、专利的原创性，避开巨头们的干扰、阻挠。

只有做到这些，才能在机遇和风险并存的产业环境中不断前行，实现我们在半导体产业独立自主的目标。

52


1

3.4只读存储器

3.4.1 只读存储器概述

3.4.2 Flash 存储器

3.4.3 存储器容量扩展

2

3.4.1 只读存储器概述

只读存储器ROM：Read-Only Memory

在正常工作状态下只能读取数据，不能写入数据

掉电不易失

ROM和RAM都属于内部存储器，属于同一个内存空间

用于保存计算机运行所需的最基础、最核心的程序。

BIOS：基本输入输出系统

引导程序等

8086内存空间

3

总容量1MB

RAM

ROM

RAM

ROM



4

3.4.1 只读存储器概述

ROM中写数据称为编程(program)，包括擦除和写入

根据是否可编程，分为：

掩模ROM：制造中写入信息，用户无法更改 

可编程ROM：用户可写入内容

PROM：可编程一次

EPROM和E2PROM：可多次编程

EPROM：紫外线擦除，专用设备写入

E2PROM：电擦除，联机写入

EPROM-Erase PROM

紫外线擦除，编程器写入

EPROM上方有一个石英窗口。将芯片置于紫外灯下，以擦除其中的内容，相当于存储器又存了全“1”。然后用专用的设备将信息重新写入

6

E2PROM

E2PROM 为Electric Erase PROM

电擦除，擦除时间较快

联机写入

无需把器件从电路板取下

E2PROM允许改写上千次，编程大约需20ms，数据可存储20年以上

7

3.4.2Flash存储器

在E2PROM基础上发展而来

高密度、非失易失性

有很高的读取速度，易于擦除和重写，功耗小



FLASH 存储器的逻辑结构

8

(重点)存储器容量扩充

一、存储芯片简介

二、存储器容量扩展的三种方法

位扩展

字扩展

字位扩展

一、背景知识——存储芯片简介

存储芯片的引脚



芯片容量：字数×字长

	(存储单元数量×存储单元的位数)

9

二、存储器容量扩展的三种方法

1、位扩展

给定芯片的字长较短，不满足存储器字长要求，要用多片来扩展字长

2、字扩展

给定的芯片字数少，用多片给来扩展字数

3、字位扩展

从字长和字数两个方向扩展

10

1、位扩展

11



1、位扩展

12

存储器一个存储单元分为高4位和低4位分别位于两个芯片中

两个芯片并行工作

1、位扩展

总容量= 210×8位

13

1、位扩展

14

2、字扩展

15

2、字扩展

16

2、字扩展

分析地址：

存储器地址线A10~A0



A10用于选择芯片

A9~A0用于选择芯片内的某一存储单元

17

2、字扩展

18

2、字扩展

19

2、字扩展

20

3、字位扩展

需扩展的存储器容量为M× N位 , 已有芯片的容量为L× K位 (L<M,K<N)

21

用M/L 组 芯片进行字扩展

每组内有N/K 个 芯片进行位扩展

22

23

24

每4片一组进行位扩展

25



8组进行字扩展

26

存器容量与地址范围的关系

高3位通过3：8译码器产生每组的片选信号

27



8组进行字扩展

28



字位扩展一起画

29

例：设CPU有16根地址线，8根数据线，并用MREQ#作访存控制信号，用R/W#作读/写控制信号。

现有下列存储芯片：

SRAM：1K×4、4K×8、8K×8；

ROM：2K×8、4K×8、8K×8；

及3：8译码器和各种门电路

主存的地址空间满足下述条件：

最小8KB地址为系统程序区(ROM区)，

与其相邻的16KB地址为用户程序区(RAM区)，

最大4KB地址空间为系统程序区(ROM区)。



请画出CPU与存储器的连接图。



三、主存储器与CPU的连接

确定各区域地址范围；

根据存储器容量，确定存储芯片的数目和扩展方法；

分配地址线

地址线低位直接连接存储芯片的地址线；

高位地址线参与形成存储芯片的片选信号；

连接数据线、读写控制等其他信号线

MREQ#可用作地址译码器的使能信号

30

31

解：1）根据题目的地址范围写出相应的二进制地址码。



存器容量与地址范围的关系

32



33



3.5并行存储器

加速CPU与存储器之间的数据传输的方式：

采用更高速性能的存储器，加大字长

采用并行操作的双端口存储器

在CPU和主存之间使用高速缓存Cache

在每个存储周期中存取多个字

多模块交叉存储器

DDR



34

35

3.5.1 双端口存储器

结构特点：具有左右两个端口，每一个端口都有独立的读写控制电路

读写冲突：若左、右端口同时对相同的存储单元进行读写操作

左读右写、右读左写、左写右写

解决方法：判断逻辑决定对哪个端口优先进行读写操作，而暂时关闭另一个被延迟的端口，即置其忙信号BUSY#=0。

36

双端口存储器IDT7133逻辑框图



R

37

双端口存储器读写时序

CE判断：如果地址匹配且在CE之前有效，片上的控制逻辑在CEL和CER之间进行判断来选择端口。

38

3.5.2 多模块交叉存储器

设存储器由M个的独立的存储模块组成，

每个模块有相同的容量和存取速度

存储模块就是存储芯片

存储器地址的编排方式：顺序方式和交叉方式。

顺序方式：地址按顺序分配给一个模块后，又按顺序为下个模块分配

39



内存地址

模块2bit

字3bit

M0

M1

M2

M3



数据总线

 顺序方式

5位地址： 高2位选模块，低3位选块内地址

故障隔离

扩充容量比较方便

连续地址单元在同一个模块，各模块串行工作

带宽没有提升

40

3.5.2 多模块交叉存储器

交叉方式：

两个相邻地址的物理单元不属于同一个存储模块，一般在相邻的存储模块中；

同一个存储模块内的地址都不连续。



41



内存地址

模块2bit

字3bit

M0

M1

M2

M3



数据总线

交叉方式

5位地址：高3位选块内地址，低2位选模块

连续地址单元在不同同模块，各模块并行工作

存储对齐（软件）+交叉编址（硬件）可以系统运行速度

3.5并行存储器

42



地址总线ABUS

M0

M1

M2

M3

单字长 数据总线DBUS

交叉编址

AR

AR

AR

AR

CPU

每个模块独立工作

各模块分时使用数据总线进行信息传递。

流水线方式

数据总线是瓶颈

43



多体交叉存储器

流水线方式存取示意图

连续读取m 个字所需的时间为

模块内访问一个存储单元（字）的存储周期是T

多体并行存储器

44



地址总线ABUS

M0

M1

M2

M3

多字长 数据总线DBUS

交叉编址

AR

AR

AR

AR

CPU

也称为多通道

优化瓶颈



多模块应用

两条4G内存条 单条8G内存条性能差异？

 -45- 

双通道内存实例128bit

 -46- 

双通道内存性能评测

SiSoftware Sandra Pro Business 2011 

 HP DL120 G7Intel SandyBridge



 -47- 

新型存储器: PCRAM相变储存器

又称 PCM和 CRAM，它利用相变材料作为储存介质。

相变材料在非晶相态时具有较高的电阻值；在结晶相态时具有较低的电阻值

非易失性存储器

对相变材料施加不同时长的电脉冲，使相变材料呈现出不同的结晶状态，并在两种状态之间快速切换

储存密度较 DRAM 更高

48

新型存储器: ReRAM电阻式存储器

也称 RRAM，是以非导性材料（金属氧化物）为存储介质的非易失性存储器

施加电压，材料的电阻在高阻态和低阻态间发生相应变化，并利用这种性质储存各种信息。

RRAM 不仅高读写速度和高存储密度，同时延迟更低

49

新型存储器: MRAM和FRAM

MRAM是一种利用磁性工作的非易失性随机存储器。

基于两个铁磁层磁化状态来存储信息，当电流流过时会表现出不同的阻值。

FRAM，采用铅锆钛形成结晶体存储数据。

通过判断晶体内的电荷高低来读取数据。

50


3.6 Cache存储器



1

3.6 Cache存储器

为什么要引入Cache？

解决CPU和主存之间的速度不匹配问题

延迟（ns）和带宽（GB/s）

2

CPU带宽简单测算

个人电脑的DDR4-3200 内存单通道带宽25600MB/s

CPU默认频率位1500MHz，4核心64位处理器，每次运算需要2个数据

CPU所需带宽：1500x4x(8+8)=96000MB/s

内存墙（memory wall）



3



4

3.6 Cache存储器

在CPU和内存之间设置一个小容量的存储器Cache，保存的内容是主存内容的一个子集

Cache存取速度要比主存快，用SRAM实现

Cache功能全由硬件调度，对所有用户透明

运行过程无需软件参与

5

2. Cache基本原理

程序的局部性原理

在一段时间内，程序的执行仅限于程序中的某一部分。相应地，执行所访问的存储空间也局限于某个内存区域

时间局部性：被访问过一次的内存区域在未来会被多次访问

空间局部性：如果一个内存区域被访问，那么将来它附近的单元也会被访问

6

sum = 0;

for (i = 0; i < n; i++)

	sum += a[i].x + a[i].y;

return sum;

程序局部性举例

数据

数组元素访问 (空间)

结构体、数据库记录访问(空间)

局部变量，计数器，指针等被重复使用 (时间)

指令

顺序访问的指令 (空间)

重复使用的循环体 (时间)

子函数 (时间)

 -7- 

程序局部性举例

程序1：

int a[M][N];

for (i = 0; i < M; i++)

 for (j = 0; j < N; j++)

 sum += a[i][j];

程序2：

int a[M][N];

for (j = 0; j < N; j++)

for (i = 0; i < M; i++)

sum += a[i][j];

哪个程序具有更好的局部性

 -8- 

9

3.Cache的命中率

10

Cache的平均访问时间

11

Cache的访问效率

12

例3.4 CPU执行一段程序时，Cache完成存取的次数为1900次，主存完成存取的次数为100次，已知Cache存取周期为50ns，主存存取周期为250ns，求Cache/主存系统的效率和平均访问时间。 

解：

13

背景：相联存储器（CAM）

普通存储器都是按地址访问

相联存储器是按内容访问

Content Addressable Memory

相联存储器的基本原理

存放在相联存储器中的内容：标记+数据

查找的主要操作是比较

按地址访问存储器

按地址访问：

存储器只保存数据，数据的地址不保存

寻址时译码器根据地址直接选中对应数据

14

按地址访问：

存储器只保存数据，数据的地址不保存

寻址时译码器根据地址选中对应存储单元

15

按地址访问存储器

按内容访问：

增加标记(标识、Tag)，一般用地址的部分或全部

查找时，将访问地址和表中的所有标记比较，相同的一行就是要访问的存储单元

16

CAM存储器

按内容访问：

增加标记(标识、Tag)存储，

一般用地址的部分或全部作为标记

查找时，将访问地址和标记存储中的所有标记比较，相同的一行就是要访问的存储单元

17

CAM存储器

相联存储器

在计算机系统中，CAM主要用于需要快速查找的领域：

虚拟存储器中存放段表、页表和快表；

Cache

网络设备中路由的查找

18

19

3.6.2 主存与Cache的地址映射



20

3.6.2 主存与Cache的地址映射

Cache分为若干行（Line），每行的容量和主存块相同

Cache与主存的数据交换是以块为单位

Cache按内容访问，主存按地址访问

必须应用某种方法，把主存的地址定位到Cache中的确切位置——地址映射



例题

主存地址空间大小为256MB，按字节编址。主存块大小为64B。数据Cache有8行

假定int型数据为32位补码，数组a按行优先方式存放，首地址为320（十进制）



1）数据Cache的总容量是多少？

2）数组元素a[0][31],a[1][1]所在主存块分别是多少?

int a[256][256];

Cache原理图

22

主存分块

Cache替换管理



Cache与主存之间的数据交换是以块为单位

CPU与Cache/主存之间的数据交换是以字为单位

标记存储

Cache数据存储

Cache的基本工作原理示意图 

23

CPU将内存地址同时发往Cache和主存。

Cache的四个问题

当把一块调入Cache时，放在哪行?（映射方式）

全相联、直接映射、组相联 

如何判断当所要访问的地址在Cache中?（地址变换）

当发生失效时，应替换哪一行？（替换算法）

当进行写操作时，应进行哪些操作?（写策略）

保证数据的一致性

24

1. 全相联

多对多：主存一个块可以放到Cache任一行

将整个块地址作为Cache行的标记

25

XXXXXXXX

XX

主存地址：

块号（s位） 块内偏移（w位）

2r=8行

2s=256块

2w=4字



B0

B1

B2

B3

B124

B124

B3

B1

B0

B2



1. 全相联

26

主存256块，每块4个字，Cache有8行



1. 全相联

地址变换

CPU将内存地址同时发往Cache和主存

发往Cache的访存地址会分为块地址和块内偏移

块地址同时和Cache中所有行的Tag进行比较

相同表示命中，再根据块内偏移从该行中读取一个字，同时撤销内存寻址过程

若没有命中，则等待访存过程结束，然后将被访问内存的相对应块调入Cache

27

00000000

00000001

00000010

00000011

01011000

01011001

00000010

0101100101

0000001010

00000010

00000001

01011001

块地址（块号）

1. 全相联地址变换

内存地址

11111111

28

1. 全相联

特点：

优点：冲突概率小，Cache的利用高。

冲突：所选择的Cache行包含近期要使用的信息

缺点：比较电路实现成本高

适用于小容量的Cache



29

2. 直接映射

30

31

2. 直接映射

Cache将s位块地址分为两部分：

低r位作为Cache的行号（index）:r = log2m

高s-r位作为该行tag

直接映射的Cache组织



32

33

2. 直接映射-地址变换

第一步：用访存地址中的块号的r位行号找到Cache中对应的一行

第二步：用块号的s-r位与该行的tag比较。

若命中，而后用低w位读取所要求的字

若不命中，访问主存

二、直接映射

映射检索过程

00000000

00000001

00000010

00000011

01011000

01011001

01011011

01011010

0101111101

0000001011

01011

11001

01011

块号

蓝色：行号；绿色：字地址

Cache地址000

Cache地址010

Cache地址111

34

2. 直接映射

优点：硬件简单，成本低

缺点：每个块只有一个固定的行可存放，容易产生冲突

频繁置换会导致Cache抖动，效率下降

适合大容量Cache采用

更多行减小冲突

35

3. 组相联

将Cache分成u组，每组v行

组间采用直接映射，组内采用全相联映射

主存中的每一块可以被放置到Cache中唯一的组的任何一行

组相联是全相联和直接映射的折中方案

q组号，j主存块地址、m为Cache总行数

m＝u×v 　　　组号　q＝j mod u

设u ＝ 2d，q = log2 d: 



36

3. 组相联映射方式

低d位表示组号(组索引，组index)

高s-d位作为tag

37

Cache分为4组，每组2行



38

3. 组相联映-地址变换

第一步：用块号的低d位找到对应组

第二步：将块号的高s-d位与该组中所有行的标记同时进行比较

命中，选中该行，用内存地址的低w位选择相应的字

不命中，则访问内存

39

三、组相联映射地址变换



00000000

00000001

00000010

00000011

01011000

01011001

11111111

01011010

010110 00 11

000000 10 01

00

10

11

000000

010110

000000

010110

块号

蓝色：组号；绿色：字地址

40

3. 组相联映射方式

特点：比全相联容易实现，冲突低

u=1，则为全相联映射方式

v表示每组的行数，称之为v路组相联Cache。v=1，则为直接映射方式

得到普遍采用



41

全相联映射载入过程



22

101102

26

110102



22

101102



26

16

4

16

18

载入

载入

命中

命中

载入

载入

命中

载入



t

22

26

16

4

18

主存32块，Cache8行

42

直接相联映射载入过程



22

（10110）

22

26

16

4

16

18

载入

载入

命中

命中

载入

载入

命中

替换



t

22

26

16

4

16

18

26

（11010）

主存32块，Cache8行

43

2路组相联映射载入过程



22

26

22

26

16

4

16

18

载入

载入

命中

命中

载入

载入

命中

载入



t

22

26

16

4

18

主存32块，Cache8行

44


Cache基本概念

Cache的作用：

解决CPU和主存之间的速度不匹配问题

小容量存储器，用SRAM实现

对用户透明

Cache的原理

程序局部性：时间和空间

Cache性能

命中率、平均访问时间、效率

1

Cache基本概念

CAM

按内容访问、比较器

主存地址：块地址和块内偏移



Cache分为若干行（Line），每行的容量和主存块相同

Cache与主存的数据交换是以块为单位



2

1. 全相联

多对多：主存一个块可以放到Cache任一行

将全部块地址作为Cache行的标记

3

1. 全相联

地址变换

CPU发出的访存地址中的块地址同时和Cache中所有的Tag进行比较。

特点

冲突概率小，成本高

适用于小容量的Cache

4

2. 直接映射

多对一：一个主存块只能映射到Cache的一个特定行上



5

6

2. 直接映射-地址变换

地址变换

用访存地址中的块号的r位行索引找到Cache中对应的行

然后用块号的s-r位与该行的tag比较。

特点

硬件简单，成本低，容易产生冲突

频繁置换会导致Cache抖动，效率下降

适合大容量Cache采用

3. 组相联

将Cache分成u组，每组v行

V路组相联

组间采用直接映射，组内采用全相联映射

7

3. 组相联映-地址变换

地址变换

首先访存地址的块地址的低d位找到对应组，

然后将块地址的高s-d位与该组v行中的所有tag同时进行比较。

特点

比全相联容易实现，冲突低

全相联映射和直接映射的折衷

得到普遍采用

8

9

10

一个4路组相联Cache由64行组成，主存储器包含4K个块，每块128字。请表示主存地址的格式？

典型题

组相联映射下的主存地址格式如下：



每块128字

块内的字地址需要7位

Cache由64个行组成，每组4行

Cache共包含16组，需4位组号

主存包含4K个块

主存块号为12位

标记位12－4=8位



7位

4位

8位

解：主存容量1M=220，主存地址共20位

		块大小=24字节，字号(块内偏移) w=4

		块地址：20-4=16位

		全相联映射 ，标记位数等于块地址位数，为16位

主存格式



主存地址(F0010)16 =(1111 0000 0000 0001 0000)2

对应的标记=1111 0000 0000 0001 字号=0000

11

 有一个存储体系，主存容量1MB，字长1B，块大小16B，Cache容量64KB。若Cache采用全相联映射，对内存地址（F0010H ）给出相应的标记和字号。

例：

某PC主存容量为128KB,Cache容量4KB,每块32B。

主存多少块？块地址多少位？Cache多少行？

主存块：128K/32=4K，块地址占12位

Cache行：4K/32=128=27

用直接映射时，Cache标记几位？

12位块地址中，低7位定位Cache行，高5位为标记

用全相联映射，Cache标记几位？

12位

12

例：

某计算机的Cache有16行，采用二路组相联映射方式，每个主存块大小为32字节，按字节编址。则主存129号单元的主存块装如Cache的组号是：

A、0       B、2       C、4       D、6

解：二路组相联，共有16/2=8组，组号占3位。      每块32字节，所以块内地址占5位。    129转化为二进制：100_00001：前3位为组号，组号为4。

	129/32 = 4 ，4 mod 8 = 4



13



块地址=块号

块内偏移 =块内地址 =字地址 = 字号

14

3.6.3 替换策略

当从主存向Cache传送一个新块，而Cache中可用位置已被占满时，就会产生替换问题

直接映射：替换Cache中指定的一行

全相联和组相联： 从所有行或组内所有行中选取一行换出

Cache的常用替换算法：

最不经常使用LFU算法

近期最少使用LRU算法

随机

15

3.6.3 替换策略

最不经常使用LFU(Least Frequently Used)算法

每行设置一个计数器，0开始计数

每访问一次， 被访行的计数器增1。

当需要替换时，将计数值最小的行换出，同时将该行的计数器都清零。

不能严格反映近期访问情况。

刚调入Cache的新行很容易被换出

16

17

3.6.3替换策略

例子：设Cache有1、2、3、4共4行(全相联映射)，a、b、c、d、e等为主存中的块,访问顺序一次如下：a、b、c、d、c、b、c、e、d、d、a ,e。1）采用LFU算法替换 

 



18

 



 



计数器从0开始计数

每访问一次，该行的计数器增1。

将计数值最小的行换出，该行计数器清零。

3.6.3 替换策略

近期最少使用(LRU-Least Recently Used的)算法

将近期内长久未被访问过的行换出

每行设置一个计数器

访问时，命中行的计数器清零，其它各行的计数器增1

替换时，将计数值最大的行换出

保护了刚拷贝到Cache中的新行，提高了命中率

随机替换

随机地选取一行换出

19

 



 



20

命中行的计数器清零，其它各行的计数器增1

将计数值最大的行换出。

3.6.4 Cache的写操作策略

Cache的内容只是主存部分内容的副本

对Cache的写入导致与主存内容的不一致

三种写策略

写回法（Write-Back）

全写法（Write-Through、写穿透、写直达）

写一次法（Write-Once）

考虑写命中和写不命中两种情况



21

(1) 写回法

写命中：

修改Cache的内容，而不立即写入主存

只有当此行被替换时才写回主

写未命中：

首先将内存中对应块调入Cache，然后对其修改

当此行换出时，写回主存

特点

减少了访问主存的次数

存在不一致的隐患

每行配置一个修改位，以反映此行是否被CPU修改过。 被修改过的行称为脏行（dirty）



22

例题

(2) 全写法 

写命中时：

同时写入Cache与主存

写未命中时：直接向主存进行写入

特点：

无需增加修改位

写Cache和写主存同步进行，不存在数据不一致的情况

一定程度上降低了Cache的性能 

24

(3) 写一次法 

写回法+全写法

写命中时：

第一次：采取全写法

不是第一次：采取写回法

写未命中时：

与写回法相同

主要用于多处理器系统

25

Intel i7 Cache 结构

26



27



28



例题

主存地址空间大小为256MB，按字节编址。指令数据Cache，均有8行，Cache行大小为64B，数据Cache直接相联。现有两功能相同的程序A，B，其伪代码如下所示：

假定int型数据为32位补码，程序编译时i,j,sum均分配在寄存器中，数组a按行优先方式存放，首地址为320（十进制）。



1）数组元素a[0][31],a[1][1]所在主存块对应的Cache行分别是多少，行号从零开始。

2)程序A，B的数据访问命中率各是多少？那个程序的执行时间更短?



int a[256][256];

for (i = 0; i < 256; i++)

 for (j = 0; j < 256; j++)

 sum += a[i][j];

int a[256][256];

for (j = 0; j < 256; j++)

for (i = 0; i < 256; i++)

sum += a[i][j];

程序A

程序B


3.7虚拟存储器

原因？

多用户、多任务的出现，要求每个程序有自己独立的内存空间

用户编程时希望不考虑实际程序的运行空间？

虚拟存储器只是一个容量非常大的存储器的逻辑模型，它借助于磁盘等辅助存储器来扩大主存容量，使之为更大或更多的程序所使用。



3.7虚拟存储器

1. 实地址与虚地址

用户编制程序时使用的地址称为虚地址或逻辑地址，其对应的存储空间称为虚存空间或逻辑地址空间；

计算机物理内存的访问地址则称为实地址或物理地址，其对应的存储空间称为物理存储空间或主存空间。程序进行虚地址到实地址转换的过程称为程序的再定位。

注意：

　　物理地址由CPU地址引脚送出，用于访问主存的地址。

　　虚拟地址由编译程序生成的，是程序的逻辑地址。

主存～外存层次所用的地址变换映射方法和替换策略与cache～主存层次所用的方法和策略是相同的，即都基于程序局部性原理。它们遵循的原则是：



3.7虚拟存储器

2. 虚存访问过程：

虚存空间用户程序按照虚地址编程并存放于辅存之中

运行时，操作系统将程序的部分调入内存。

每次访存时，判断：虚地址对应部分是否在内存？

若在：虚实地址转换

不在：从辅存中调入



3.7虚拟存储器

虚存是概念模型，不是实物

对系统程序不透明、对应用程序透明

虚存能有效提高存储体系性能

Cache

主存

辅存

Cache-主存访问机制

主存-辅存 访问机制



3.7虚拟存储器

3. Cache与虚存的异同：

出发点相同：提高存储系统性能

原理相同：局部性原理

侧重点不同：

Cache：解决速度差异，提高访存速度；

虚存：容量、分配、保护等

数据通路不同：

CPU与主存和Cache有直接通路；

CPU不能直接访问辅存

3.7虚拟存储器

3. Cache与虚存的异同：

透明性不同：

Cache：完全由硬件完成，透明；

虚存：硬件软件完成，仅对用户程序透明

未命中损失不同：

Cache：未命中时间损失小

虚存：未命中时间损失大



3.7虚拟存储器

4.虚存机制要解决的关键问题

调度问题：哪些程序、数据调入主存？

地址映射问题：虚实地址变换

替换问题：决定哪些程序和数据应被调出主存

更新问题：主存、辅存内容一致性

3.7虚拟存储器

不同的虚拟存储器机制

页式虚拟存储器

段式虚拟存储器和段页式虚拟存储器

不同的替换算法：

FIFO、LRU、LFU

3.7.2页式虚拟存储器

 页式虚拟存储系统中，虚拟空间分成页，称为逻辑页；主存空间也分成同样大小的页，称为物理页。

　虚存地址分为两个字段：逻辑页号+页内行地址。

　实存地址也分两个字段：物理页号+页内行地址。

　页表中每一个虚存逻辑页号有一个表目，表目内容包含该逻辑页所在的主存页面地址(物理页号)，用它作为实存地址的高字段，与虚存地址的页内行地址字段相拼接，产生完整的实主存地址，据此来访问主存

页式虚拟存储器结构



　页表通常在主存中，也至少要访问两次物理存储器才能实现一次访存，这将使虚拟存储器的存取时间加倍。为了避免对主存访问次数的增多，把页表中的最活跃的部分存放在高速存储器中，这个专用于页表缓存的高速存储部件通常称为转换后援缓冲器(TLB)。保存在主存中的完整页表则称为慢表。        

　　

3.6.2页式虚拟存储器

TLB的地址映射过程

3.7.3 段式虚拟存储器和段页式虚拟存储器

1、段式虚拟存储器

段是按照程序的自然分界划分的长度可以动态改变的区域。

子程序、操作数和常数等划分到不同的段中，并且每个程序可以有多个相同类型的段。

虚地址由段号和段内地址（偏移量）组成。虚地址到实主存地址的变换通过段表实现。

14

段式虚拟存储器地址变换



段页式虚拟存储器是段式虚拟存储器和页式虚拟存储器的结合。

　　它把程序按逻辑单位分段以后，再把每段分成固定大小的页。

　　程序对主存的调入调出是按页面进行的，但它又可以按段实现共享和保护，兼备页式和段式的优点。

　　缺点是在映象过程中需要多次查表。



段页式虚拟存储器

在段页式虚拟存储系统中，每道程序是通过一个段表和一组页表来进行定位的。段表中的每个表目对应一个段，每个表目有一个指向该段的页表起始地址及该段的控制保护信息。 如果有多个用户在机器上运行，多道程序的每一道需要一个基号，由它指明该道程序的段表起始地址。

虚拟地址格式如下：

段页式虚拟存储器

【例10】 假设有三道程序(用户标志号为A，B，C)，其基址寄存器内容分别为SA，SB，SC ，逻辑地址到物理地址的变换过程如下图所示。在主存中，每道程序都有一张段表，A程序有4段，C程序有3段。每段应有一张页表，段表的每行就表示相应页表的起始位置，而页表内的每行即为相应的物理页号。请说明虚实地址变换过程。

3.7.4 替换算法

虚拟存储器中的页面替换策略和cache中的行替换策略有很多相似之处，但有三点显著不同：

　(1) 缺页至少要涉及一次磁盘存取，读取所缺的页，缺页使系统蒙受的损失要比cache未命中大得多。

　(2) 页面替换是由操作系统软件实现的。

　(3) 页面替换的选择余地很大，属于一个进程的页面都可替换。

虚拟存储器中的替换策略一般采用LRU算法、LFU算法、FIFO算法，或将两种算法结合起来使用。

　　对于将被替换出去的页面，假如该页调入主存后没有被修改，就不必进行处理，否则就把该页重新写入外存，以保证外存中数据的正确性。为此，在页表的每一行应设置一修改位。

21

【例7】假设主存只有a,b,c三个页框，组成a进c出的FIFO队列，进程访问页面的序列是0，1，2，4，2，3，0，2，1，3，2号。若采用①FIFO算法，②FIFO算法+LRU算法，用列表法分别求两种替换策略情况下的命中率。

3.8 虚拟存储器实例

1. 奔腾PC机的虚地址模式

奔腾PC的存储管理部件MMU包括分段部件SU和分页部件PU两部份，可允许SU，PU单独工作或同时工作。

分段不分页模式： 虚拟地址由一个16位的段参照和一个32位的偏移组成。分段部件SU将二维的分段虚拟地址转换成一维的32位线性地址。优点是无需访问页目录和页表，地址转换速度快。对段提供的一些保护定义可以一直贯通到段的单个字节级。

分段分页模式：在分段基础上增加分页存储管理的模式。即将SU部件转换后的32位线性地址看成由页目录、页表、页内偏移三个字段组成，再由PU部件完成两级页表的查找，将其转换成32位物理地址。兼顾了分段和分页两种方式的优点。

不分段分页模式：这种模式下SU不工作，只是分页部件PU工作。程序也不提供段参照，寄存器提供的32位地址被看成是由页目录、页表、页内偏移三个字段组成。由PU完成虚拟地址到物理地址的转换。这种模式减少了虚拟空间，但能提供保护机制，比分段模式具有更大的灵活性。

2. 保护模式的分页地址转换

奔腾页面大小为4MB

使用单级页表。

32位线性地址分为高10位的页面和低22位的页内偏移两个字段 。

页表项的I位指示页面大小，P位为出现位，A位为访问过位，D位为修改过位。RW位用于读/写控制，US位用于用户/监督控制，PCD位用于页cache禁止的控制，PWT位用于页全写法的控制。 

奔腾4MB分页方式地址变换

3.9存储保护 



 当多个用户共享主存时，就有多个用户和系统软件存于主存中，为使系统能正常工作，应防止由于一个用户程序出错而破坏其他用户的程序和系统软件，还要防止一个用户程序不合法地访问不是分配给它的主存区域。为此，系统应提供存储保护。通常采用的方式是：

1存储区域保护

2访问方式保护

3.9.1 存储区域保护

非虚拟存储器的主存系统可采用界限寄存器方式。

由系统软件经特权指令设置上、下界寄存器，为每个程序划定存储区域，禁止越界访问。

界限寄存器方式只适用于每个用户占用一个或几个连续的主存区域。

在虚拟存储系统中，通常采用页表保护、段表保护和键式保护方法。

1. 页表保护和段表保护

每个程序的段表和页表本身都有自己的保护功能。每个程序的虚页号是固定的，经过虚地址向实地址变换后的实存页号也就固定了。那么不论虚地址如何出错，也只能影响到相对的几个主存页面。不会侵犯其他程序空间。段表和页表的保护功能相同，但段表中除包括段表起点外，还包括段长。

2. 键保护方式

为主存的每一页配一个键，称为存储键

每个用户的实存页面的键都相同。为了打开这个锁,必须有钥匙，称为访问键。

访问键赋予每道程序，并保存在该道程序的状态寄存器中。

当数据要写入主存的某一页时，访问键要与存储键相比较。若两键相符，则允许访问该页，否则拒绝访问。 

3. 环保护方式

对正在执行的程序本身的核心部分或关键部分进行保护。

它是按程序的重要性及对整个系统的正常运行的影响程度进行分层，每一层叫做一个环。

在现行程序运行前由操作系统定好程序各页的环号，并置入页表中。然后把该道程序的开始环号送入CPU的现行环号寄存器。

程序可以访问任何外层空间；访问内层空间则需由操作系统的环控例行程序判断这个向内访问是否合法。

3.9.2 访问方式保护

　对主存信息的使用可以有三种方式：读、写和执行。相应的访问方式保护就有R、W、E三种方式形成的逻辑组合。这些访问方式保护通常作为程序状态寄存器的保护位，并且和区域保护结合起来实现。

表3.11　访问方式保护的逻辑组合 



35

本 章 小 结

对存储器的要求是容量大、速度快、成本低。为了解决了这三方面的矛盾，计算机采用多级存储体系结构，即cache、主存和外存。

存储器的技术指标有存储容量、存取时间、存储周期、存储器带宽。

SRAM、DRAM和ROM各自的特性


第四章指令系统

4.1 指令系统的发展与性能要求

4.2 指令格式

4.3 操作数类型

4.4 指令和数据的寻址方式

4.5 典型指令

1

4.1 指令系统的发展与性能要求

冯诺依曼结构主要思想

五大部件

存储程序

程序控制

计算机程序由一系列的机器指令组成

指令是计算机执行某种操作的命令

每个指令的执行过程依靠硬件实现



2

4.1 指令系统的发展与性能要求

指令是软件和硬件分界面(Interface)

硬件设计人员采用各种手段实现它；

软件设计人员则利用它编制系统软件和应用软件



指令系统：一台计算机中所有机器指令的集合

表征一台计算机性能的重要因素 

影响计算机的硬件结构、系统软件，机器的适用范围

指令集架构(Instruction Set Architecture, ISA)



3

指令系统

4

4.1.1指令系统的发展 

系列计算机

基本指令系统相同、基本体系结构相同的一系列计算机

同一系列的各机种有共同的指令集

指令集向下兼容

X86系列、ARM系列

5

4.1.1指令系统的发展 

复杂指令系统计算机

CISC-Complex Instruction Set Computer

单条指令功能复杂，整个指令系统数量庞大

控制器研制开发周期变长，正确性难以保证，调试维护困难

X86、IA32\IA64、

IBM System/360 

Intel MCS-51



精简指令系统计算机

RISC-Reduced Instruction Set Computer

克服CISC缺点，便于VLSI技术实现

单条指令功能简单

2/8规则：80%的指令完成20%的功能

控制器设计难度降低

ARM: Advanced RISC Machine

RISC-V、MIPS

AVR: Alf and Vegard's RISC processor



6

4.2 指令格式

表示一条指令的二进制串称为指令字，指令

指令格式：用二进制代码表示的结构形式



操作码（OP-Operation Code）

该指令执行的操作，编码表示

地址码（AC-Address Code）

描述指令的操作对象，可以是操作数本身，也可以是操作数的位置

存储器单元----存储器地址

寄存器----寄存器编号

I/O设备中的缓冲-----端口号



7

4.2.2 地址码

操作数有被操作数、操作数及操作结果这三种数

形成了三种指令格式

8

三地址指令

二地址指令

一地址指令

零地址指令

4.2.2 地址码

零地址指令  

指令字中只有操作码，而没有地址码

一种是无需操作数

如NOP、HLT停机指令等

另一种是操作数为默认的（或称隐含的）

如操作数在累加器或者堆栈中



9

零地址指令

4.2.2 地址码

一地址指令

常称为单操作数指令，指令中只有一个地址码

可能是单操作数运算

给出的地址既作为操作数的地址，也作为结果的地址

OP (A) -> A

也可能是二元运算

指令中提供一个操作数，另一个操作数则是隐含的

(A) OP (AC) -> A　　　

10

一地址指令

4.2.2 地址码

二地址指令

最常见的指令格式，又称为双操作数指令

运算结果保存在其中一个地址码中，原来的数据被覆盖

		（A1）OP（A2）→ A1

地址码A1兼做存放操作结果

11

4.2.2 地址码

三地址指令

	 (A1)　OP　(A2)　->　A3

A1和A2为源操作数

A3为目的操作数

	

12

4.2.2 地址码

在二地址和三地址指令格式中，从操作数的物理位置划分为三种类型

存储器-存储器 (Storage-Storage, SS) 型指令：

从内存单元中取操作数，操作结果存放至内存单元

需要多次访问内存

寄存器-寄存器 (Register-Register, RR) 型指令：

从寄存器中取操作数，把操作结果放到另一寄存器

这类指令的速度很快，因为不需要访问内存

寄存器-存储器 (Register-Storage, RS) 型指令：

此类指令既要访问内存单元，又要访问寄存器

13

4.2.3 指令字长度

指令字长度：一条指令的二进制位数

为了取指方便，一般为机器字长倍数

半字长、单字长、双字长

多字长指令

指令字长度等于两个或多个机器字长

优点：地址码更多，解决内存的寻址问题；

缺点：多次访存才能取得一条指令，降低了速度，占用存储空间大



14

4.2.3 指令字长度

指令集中所有指令长度是否相等

等长指令：所有指令长度相等

结构简单，控制线路简单

MIPS、ARM

变长指令：指令字长度随功能而异

结构灵活，控制较复杂

X86

现在指令字长一般为32位固定长度

15

4.2.4 指令助记符

为了便于书写和阅读，指令通常用3个或4个英文缩写字母来表示，叫做指令助记符

16

指令格式举例：ARM指令格式 

指令长度为32位，定长指令

单字长指令

RR型指令、三地址指令

17

指令格式举例 X86指令格式 

变长指令，1~15字节，典型的CISC指令系统 

多字长指令

18

X86指令格式 

JE20H

Call

PUSH ESI

MOV EBX,[EDI+45]



[例1]　机器字长16位，指令格式如下所示，其中OP为操作码，试分析指令格式的特点。 

15　 9　7　 4 3　0

[解]： 

(1)单字长二地址指令

(2)操作码字段OP可以指定27=128条指令

(3)源寄存器和目标寄存器都是通用寄存器（总共16个），所以是RR型指令，两个操作数均在寄存器中

[例2]机器字长16位，指令格式如下所示，OP为操作码字段，试分析指令格式特点。

15　　10　　7　43　　 　0 

(1)双字长二地址指令

(2)操作码字段OP为6位，可以指定64种操作

(3)一个操作数在源寄存器，另一个操作数在存储器中,所以是RS型指令。 通用寄存器（总共16个)

H&P 和RISC

John Hennessy

MIPS是在是其在Stanford的研究成果

Hennessy于1984年在硅谷创立了MIPS公司

后任Stanford大学校长

David Patterson

加州大学伯克利分校教授，研究成果发展出SUN公司SPARC处理器

是谷歌的杰出工程师

RISC-V Foundation 董事会副主席



H&P 和RISC

两人出版了两本著名的教科书：

Computer Organization and Design : The Hardware/Software Interface(计算机组成与设计：硬件/软件接口)

Computer Architecture : A Quantitative Approach(计算机体系结构：量化方法)

2017 ACM图灵奖

MIPS架构历史

MIPS（Microprocessor without Interlocked Pipelined Stages）ISA 是经典的RISC架构之一

1981 年由斯坦福大学的Hennessy 团队研制

1984 年被 MIPS Technologies公司商业化,1992 年SGI收购

2013 年Imagination Technologies 公司收购

2017 年卖给Tallwood,2018 年Wave Computing收购（命运多舛）

2019 年成为MIPS Open，正式开源（2020年闭源）

MIPS ISA版本

MIPS32/MIPS64 多个版本

基于MIPS ISA的处理器

龙芯系列，君正系列

MIPS 指令集特点

单字长指令

指令长度为4 字节=32位

定长指令

大部分为三地址指令，RR型

32个32位的通用寄存器

$0, $1, $2, … $30, $31

内存按字节编址，内存严格4字节对齐访问

MIPS里没有状态码，没有标志寄存器

MIPS指令格式

OP

RS

Rt

shamt

Rd

6bits

funct

5bits

5bits

5bits

5bits

6bits

OP

RS

Rt

6bits

偏移量

5bits

5bits

16bits

OP

6bits

地址

26bits

R 型指令

I 型指令

J 型指令

Register format

Immediate format

Jump format

MIPS指令格式（R型指令）

OP

RS

Rt

shamt

Rd

6bits

funct

5bits

5bits

5bits

5bits

6bits

例：add $s1, $s2, $s3

000000100101001110001 00000 100000

MIPS指令格式 (R型指令)

0x02538820

$s2 + $s3 = $s1

MIPS指令格式（I型指令）

OP：操作码

Rs：第1个源操作数寄存器

Rt：目的操作寄存器

偏移量：第二个原操作数

OP

RS

Rt

6bits

偏移量

5bits

5bits

16bits

MIPS指令格式（J型指令）

OP：操作码

跳转指令，用一个26位的立即数作为跳转的目标地址

OP

6bits

立即数

26bits

31

4.3 操作数类型

操作数类型

地址数据：地址是无符号整数。

数值数据：定点数、浮点数

字符数据：字符或字符串，使用ASCII码

逻辑数据：一个单元中有几位二进制bit项组成，每个bit的值可以是1或0。当数据以这种方式看待时，称为逻辑性数据

RISC-V

完全开放

大道至简

包含一个最小的核心ISA 

适合硬件实现

轻装上阵的后发优势

模块化的可扩展指令集

方便简化硬件实现，提升性能

更规整的指令编码、更简洁的运算指令和访存模式

高效分支跳转指令（减少指令数目）、简洁的子程序调用

无条件码执行、无分支延迟槽、无零开销硬件循环（支持for循环的硬件支撑）

MIPS 32 & RISC-V

指令助记符及语法格式大同小异

RISC-V 分支预测，MIPS延迟槽

RISC-V支持变长指令扩展

RISC-V 将源寄存器rs1，rs2和目标寄存器（rd）固定在同样位置，以简化指令译码

立即数分散在不同位置，但符号位固定在第31位，可加速符号扩展电路

RISC-V （2022年）

34

三大事件：

第一，发布首台RISC-V的便携式计算机

第二，Intel设立创新基金，支持RISC-V生态；

第三，SiFive估值超25亿美元

RISC-V全球会员超过3100家，超过160个核开源；

SPECint首次超过10分，进入高性能计算行列

在IoT领域的应用规模超过100亿颗

中国公司的出货量占据50%

RISC-V （2022年）

阿里平头哥发布了高性能RISC-V芯片平台“无剑600”及SoC原型“曳影1520”，兼容龙蜥操作系统,并成功运行LibreOffice

无剑600平台是当前全球性能最高的可量产RISC-V平台：支持4核RISC-V处理器，主频可达2.5GHz，CPU+XPU异构架构；支持64位LPDDR4X，最高吞吐率4266MT；整合4TOPs的Int8 AI算力

35

RISC发展

1964年Seymour Cray设计的CDC 6600采用了load/store设计，被认为是RISC架构的先驱

70年代，RISC的概念由IBM的约翰·科克（John Cocke）和斯坦福大学的约翰·亨尼（John Hennessy）等人提出

1981年，斯坦福大学的Hennessy发布了首款MIPS芯片

1981年，加州大学伯克利分校的David Patterson 推出了RISC-I

1983年RISC-II；1984年发布了RISC-III；1988年发布了RISC-IV

2010年，发布了RISC-V

1987年，SUN公司在RISC-II基础上开发了SPARC处理器

36



RISC架构在1980年代末至1990年代得到了广泛的应用和普及。许多公司开始推出基于RISC架构的处理器，如IBM的POWER架构、DEC的Alpha架构和HP的PA-RISC架构等。

RISC-V是一种开源的RISC架构，在2010开始兴起，并得到了全球范围内的关注和采用。RISC-V的开放性和灵活性使得它成为教育、研究和嵌入式系统等领域的理想选择。

37


1

4.4 指令和数据的寻址方式

存储器中既存放指令，也存放数据

在存储器中，操作数或指令字写入或读出的方式，有地址指定方式、相联存储方式和堆栈存取方式

几乎所有计算机在内存中都采用地址指定方式

当采用地址指定方式时，形成操作数或指令地址的方式，称为寻址方式

2

4.4 指令和数据的寻址方式

寻址方式问题

确定本条指令中各操作数的地址

下一条指令的地址

寻址方式分为两类

顺序寻址方式

(1) 指令寻址方式 跳跃寻址方式

 

(2) 数据寻址方式

1.顺序寻址方式

指令地址在内存中按序排放

执行程序时，通常是顺序执行

称为指令的顺序寻址方式

使用程序计数器PC（program counter）保存指令的顺序号

顺序号就是指令在内存中的地址

新指令地址：PC = PC +常量

常量就是当前指令的长度

MIPS：PC+4

3

图4.1 指令的寻址方式

2.跳跃寻址方式

当程序转移执行顺序时，指令寻址采取跳跃寻址方式

所谓跳跃，是指下条指令的地址码不是由PC给出，而是由本条指令直接给出

程序跳跃后，按新的指令地址开始顺序执行

PC的内容也必须相应改变，以便及时跟踪新的指令地址

2.跳跃寻址方式

6

跳跃寻址方式功能

实现程序转移或构成循环程序

或将某些程序作为公共程序引用（子程序调用）

各种条件转移或无条件转移指令，属于跳跃寻址

4.4.2 操作数寻址方式

形成操作数的有效地址（EA-Effective Address）的方法，称为操作数的寻址方式

地址码由形式地址（偏移量）和寻址方式特征位组合形成

例如，一种单地址指令中用X，I，A各字段组成该指令的地址码



寻址方式特征位指明如何对形式地址进行变换

7

8

4.4.2 操作数基本寻址方式

计算机中操作数的存放位置有

操作数包含在指令中；

操作数包含在CPU的某一个内部寄存器中；

操作数包含在主存中；

操作数包含在I/O设备的端口中

根据操作数放在不同的地方，从而派生各种不同的寻址方式

4.4.2 操作数寻址方式

9

1、隐含寻址

在指令中不明显的给出而是隐含着操作数的地址

例如，单地址指令、双地址指令

10

2、立即寻址

地址码中不是操作数的地址，而是操作数本身

也叫立即数

特点：

操作码和操作数被同时取出，提高了指令的执行速度

操作数是指令的一部分，不能修改

操作数的大小将受到指令长度的限制，寻址方式灵活性差

例如： ADD BX, 33H	;33H为立即数（X86）

	 addi $3, $0, 3 ;3为立即数（MIPS）



11

3.直接寻址

直接寻址：形式地址A就是操作数的有效地址EA

EA＝A

直接寻址方式由寻址方式特征位给予指示



12

X86：MOV AX , [200]



EA = A

Imm为寻址方式特征位

3.直接寻址



77



200

200

内存

4、间接寻址

间接寻址：形式地址A是操作数内存地址的指示，A单元的内容才是操作数的有效地址。

结合直接寻址和间接寻址，定义指令格式如下：



I＝0，表示直接寻址，有效地址EA＝A

I＝1，表示间接寻址，有效地址EA＝(A)　



14

4、间接寻址

间接寻址要比直接寻址灵活

至少需要两次访问主存储器才能取出操作数



400



788



300

300

400

间接寻址方式示意图

5、寄存器寻址 

操作数在通用寄存器中

地址码为通用寄存器编号，即EA=R

从寄存器中取操作数比访问主存快



X86：MOV AX,BX

MIPS: add $4, $15, $17

16

6、寄存器间接寻址 

寄存器中存放的不是操作数，而是操作数的内存地址

地址码给出通用寄存器的编号，有EA=(R)

17



300

R

7. 偏移寻址

偏移寻址是直接寻址和寄存器间接寻址的结合

有效地址EA = A +（R）。

寻址特征位指明某个专用寄存器

常用的三种偏移寻址是相对寻址、基址寻址、变址寻址。

18

7.偏移寻址

7.1相对寻址方式

专用寄存器是程序计数器PC

即有效地址EA = A + (PC)。

“相对”寻址，就是相对于PC的地址

形式地址A可正可负

一种指令寻址方式

20

7.1相对寻址方式



2000



 PC

2100

 程序指令计数器

7.2基址寻址方式

专用寄存器是基址寄存器

形式地址A是通常是无符号整数

可以扩大寻址能力，基址寄存器的位数长，可以访问较大的地址范围



MIPS:LW $18, 8($15) #EA = $15 +8 

22

7.3 变址寻址方式

专用寄存器是变址寄存器

目的而在于实现程序块的规律性变化

例如，一个数组在内存的首地址为X，将首地址X作为指令中的形式地址A，并在变址寄存器中指出元素的序号，便可访问任一元素

X86：MOV AX, 200[SI] 

SI,DI 都称为变址寄存器



23

7.3 变址寻址方式

X86：MOV AX, 200[SI] 

SI,DI 都称为变址寄存器



24

3000



操作数



 R

 3200

内存

8.段寻址

Intel 8086/8088微机中，ALU16位运算，但其内存容量可到1M，即地址有20位

将整个1M空间存储器以64K为单位

划分成若干段。

在形成20位物理地址时，段寄存器

中的16位数会自动左移4位，

 然后以16位偏移量相加

9.堆栈寻址方式 

堆栈有寄存器堆栈和存储器堆栈两种形式，都以先进后出的方式存取数据

不论哪种堆栈，需要一个隐式或显式的堆栈寄存器来指明栈顶（栈指针）的位置（地址）

X86中，SP(Stack Point,栈顶指针)

BP(Base Point,栈底)

26

9.堆栈寻址方式 

根据栈顶状态不同，堆栈分为：

满栈：栈指针指向栈顶元素位置

空栈：栈指针指向下一个空位置

根据增长方向不同，堆栈分为：

递减栈：堆栈向内存地址减小的方向生长，即向下生长。

递增栈：堆栈向内存地址增加的方向生长，即向上生长。

X86:满栈、递减栈

27

栈指针指向最后压入堆栈的有效数据项，称为满栈（先改变SP，再放数据）；

栈指针指向下一个待压入数据的空位置，称为空栈（先放数据，再改变SP）。 

0x12345678



栈底

栈区

0x12345678

0x12345678

递增栈： 

递减栈：

30

寻址方式举例： Pentium

EA = 段寄存器 + 描述符寄存器 + 基址寄存器 + 变址寄存器*比例因子 + 偏移量 

寻址方式举例：MIPS

31

寻址方式举例：RISC-V

32

[例]一种二地址RS型指令的结构如下所示：

　　6位　 　4位　　 1位 2位　 16位

其中I为间接寻址标志位，X为寻址模式字段，A为偏移量字段。通过I，X，A的组合，可构成下表所示的寻址方式。 请写出六种寻址方式的名称。



200

500

1100

200

100



500



800



100



200



2100

OP

X

A=100

PC=1000

R基=2000 

寻址方式

X

操作数

立即

0

100

直接

1

200

间接

2

500

相对

3

100

基址

4

200

有效地址EA



EA=A=100

EA=(A)=200

EA=PC+A=1100

EA=(R)+A=2100

例设某机的指令格式、有关寄存器和主存内容如下，X为寻址方式，A为形式地址，请在下表中填入有效地址EA及操作数的值。？



指令格式设计举例

例. 某机字长32位，采用三地址指令，支持8种寻址操作，完成60种操作，各寻址方式均可在2K主存范围内取得操作数，并可在1K范围内保存运算结果。问应采用什么样的指令格式？指令字长最少应为多少位？执行一条直接寻址模式指令最多要访问多少次主存？



47位指令字需占用2个存储字

取指需访存2次，取源操作数访存2次，写结果1次，共5次

4.5.1指令的分类

按指令的功能：

数据传送

实现主存和寄存器之间，或寄存器和寄存器之间的数据传送

数据处理

定点或浮点算术运算，向量运算、逻辑运算与移位等

程序控制

用于控制程序的执行方向

分支、转移、调用子程序

其他指令

系统控制，特权，安全等

36

37

设存储字长和指令字长均为24位，若指令系统可完成108种操作，且具有直接、间接、变址、基址、相对和立即6种寻址方式。

在保证最大范围内直接寻址的前提下，指令字中操作码占几位？寻址特征位占几位？可直接寻址的范围是多少？间接寻址的范围是多少？

38

某计算机的字长为16位，数据用补码表示，存储器按字编址，访存指令格式为16位，其中5位操作码，3位寻址方式字段，分别表示立即寻址、直接寻址、间接寻址、变址寻址和相对寻址这5种，8位地址码字段。设PC和Rx分别为程序计数器和变址寄存器(其中Rx的位数为16位)

问：立即寻址的数据范围多大？

 各种寻址方式的寻址范围大小是多少？



下列关于各种寻址方式获取操作数快慢的说法中，正确的是

I . 立即寻址快于堆栈寻址

II. 堆栈寻址快于寄存器寻址

III. 寄存器间接寻址快于变址寻址

IV. 变址寻址快于间接寻址

11:21

39


MIPS指令系统



MIPS 指令集特点

定长指令，指令长度固定 4 字节

简单的load/store结构，内存中的数据访问严格4字节对齐

load/store结构：只有load/store类指令可以访问存储器

寻址方式简单，每条指令的操作也简单

易于流水线设计

易于编译器开发

MIPS寄存器

字长32位

32个通用寄存器

$0, $1, $2, … $30, $31

3个特殊寄存器

PC（程序计数器）

HI和 LO

HI乘积高32位(余数)，LO：乘积低32位（商）；

除了用在乘除法之外，也不能有做其他用途

硬件没有强制性的指定寄存器使用规则，但是在实际使用中，这些寄存器的用法都遵循一系列约定

MIPS里没有状态码，没有标志寄存器

32个通用寄存器



IA-32的寄存器组织

8个通用寄存器

两个专用寄存器

6个段寄存器

MIPS寻址方式

数据寻址方式

立即寻址

寄存器寻址

基址寻址

基址寄存器+偏移量

任一通用寄存器都可以作为基址寄存器

MIPS寻址方式

指令寻址

顺序寻址：PC=PC+4

PC相对寻址

PC = 偏移量左移两位+PC

伪直接寻址（跳跃寻址）

26位偏移量

PC = {PC[31..28],偏移量, 00 }

MIPS指令格式

OP

RS

Rt

shamt

Rd

6bits

funct

5bits

5bits

5bits

5bits

6bits

OP

RS

Rt

6bits

偏移量

5bits

5bits

16bits

OP

6bits

偏移量

26bits

R 型指令

I 型指令

J 型指令

Register format

Immediate format

Jump format

MIPS指令格式（R型指令）

主要是运算类指令

OP：操作码，所有R型指令OP为全0

Rs：第1个源操作数寄存器

Rt：第2个源操作数寄存器

Rd：存放结果的目的操作数寄存器

shamt：用于移位指令，指明移位次数

funct：功能码，对操作码进行补充

OP

RS

Rt

shamt

Rd

6bits

funct

5bits

5bits

5bits

5bits

6bits

R 型指令

MIPS指令格式 (R型指令)

寄存器寻址

汇编格式：op Rd, Rs, Rt

例：add$s1, $s2, $s3

指令编码：000000100101001110001 00000 100000

MIPS指令格式 (R型指令)

0x02538820



$s2 + $s3 = $s1

MIPS指令格式（I型指令）

L/S指令和分支指令

Rt：目的操作数寄存器

Rs 和 偏移量：源操作数

OP

RS

Rt

6bits

偏移量

5bits

5bits

16bits

I 型指令

汇编格式：op Rt, (偏移量)Rs

MIPS指令格式（I型指令）

三地址，RR型，立即数运算指令

Rs：第1个源操作数寄存器

Rt：目的操作寄存器

偏移量：第2个源操作数(立即数)

OP

RS

Rt

6bits

偏移量

5bits

5bits

16bits

I 型指令

汇编格式：op Rt, Rs, 偏移量

MIPS指令格式 (I型指令)

立即寻址

基址寻址

相对寻址

MIPS指令格式 (I型指令)

addi $21,$22,-50

op = 810

rs = 2210 (原操作数寄存器)

rt = 2110 (目的寄存器)

偏移量 = -5010 ,负数用补码表示

请写出指令的机器码

十进制指令格式:



二进制指令代码:

0x22D5 FFCE

十六进制指令代码:

MIPS指令格式（J型指令）

单地址指令

跳转指令，用一个26位的偏移量作为跳转的目标地址

OP

6bits

偏移量

26bits

J 型指令

汇编格式：op 偏移量

MIPS指令格式（J型指令）

伪直接寻址——跳转地址为指令中的26位偏移量与PC中的高4位拼接得到

	新的PC = {PC[31..28], 目标地址, 00 }

例：	j 10000

0x08002710

0000 1000 0000 0000 0010 0111 0001 0000

指令编码：

新PC

MIPS指令系统

（1）数据传送类：

（2）算术/逻辑运算类：

（3）控制类：

1、数据传送类：内存数据访问指令

读内存指令：lw lb lh （I型指令）

w:word	b:byte	h:half word

访问元素A[8]，A[0]保存在$t3		

lw$t0,32($t3) # 基址寻址

写内存指令：sw sb sh （I型指令）

$t0的数据保存到A[12]；			

sw$t0,48($t3)

2、算术/逻辑运算类：加减指令 

加法add （R型指令）

add $s4,$s1,$s2 #$s1+$s2=$s4	

减法sub （R型指令）

sub $s3,$s4,$s5 #$s4-$s5=$s3 		

 -20- 

2、算术/逻辑运算类：加减指令

如何编译下面的C语言表达式?

a = b + c + d - e;

编译成多行汇编指令

add $t0, $s1, $s2# temp = b + c

add $t0, $t0, $s3# temp = temp + d

sub $s0, $t0, $s4# a = temp - e

2、算术/逻辑运算类：加立即数

立即数相加指令 addi （I型指令）

addi $s3,$s3,4# $s3=$s3+4	

立即数传送

addi $s3,$zero,1# $s3=1 

寄存器间数据传送

add$s3,$s2,$0 # $s3=$s2

利用$zero($0)实现寄存器之间的数据传输



2、算术/逻辑运算类：逻辑运算

逻辑移位指令 sll、srl、sra （R型指令）

sll$s1,$s2,2 # $s2左移两位 

srl$s1,$s2,2 # $s2右移两位

逻辑运算 and/or/xor/addi/ori/xori （R型和I型指令）

and$t0,$t1,$t2 # t0=t1&t2

or $t0,$t1,$t2 # t0=t1|t2

andi $t0,$t1,100 # t0=t1&100

ori$t0,$t1,100 # t0=t1|100

3、控制类指令: 跳转指令

3、控制类指令

C语言条件判断指令

If(a==b)

 {i=1; } 

else 

 { i=2; }



等效C指令

If (a==b) goto L1;

 i=2;

 goto L2;

L1:i=1;

L2:



等效MIPS指令

 beq$s0,$s1,L1 

 addi $s3,$zero,2

 j L2; 

L1:addi $s3,$zero,1

L2:



 -25- 

等效MIPS指令

$s0 = a

$s1 = b 

$s3 = i

3、控制类指令:比较指令 sltslti

比较指令(slt:Set on Less Than)

slt reg1,reg2,reg3

如果reg2 < reg3, 则reg1 = 1

先比较，再分支

If ($s1<$s2) goto Less; 

slt $t0,$s1,$s2# $t0 = 1 if $s1<$s2

bne $t0,$0, Less # if $t0!=0 goto Less



 

 -26- 

循环结构

C语言简单循环结构，A为int数组

	do {

 g = g + A[i]; i = i + j;} while (i != h);

重写代码

	Loop:	g = g + A[i];		i = i + j;		if (i != h) goto Loop;

编译后的变量映射:

循环结构

最后编译的MIPS代码:

Loop: sll$t1,$s3,2# $t1= 4*iadd$t1,$t1,$s5# $t1=&A[0]+4ilw $t1,0($t1) # $t1=A[i]add$s1,$s1,$t1# g=g+A[i]add$s3,$s3,$s4# i=i+jbne$s3,$s2,Loop # if i!=h goto Loop 

原始C代码: Loop:g = g + A[i];	i = i + j;		 if (i != h) goto Loop;



循环结构

最后编译的MIPS代码:

Loop: sll$t1,$s3,2# $t1= 4*iadd$t1,$t1,$s5# $t1=&A[0]+4ilw $t1,0($t1) # $t1=A[i]add$s1,$s1,$t1# g=g+A[i]add$s3,$s3,$s4# i=i+jbne$s3,$s2,Loop # if i!=h goto Loop# 

原始C代码: Loop:g = g + A[i];	i = i + j;		 if (i != h) goto Loop;



MIPS 函数调用

C语言函数调用

int function(int a,int b) 

{return (a+b); }

MIPS实现函数调用的机制

返回地址寄存器$ra

参数寄存器	 $a0, $a1, $a2, $a3

返回值寄存器$v0 $v1

局部变量 $s0~$s7

堆栈指针 $sp



过程调用实现机制

sum(a,b);/* a,b:$s0,$s1 */}int sum(int x, int y)

 {return x+y;}



1000 add$a0,$s0,$zero# x = a1004 add$a1,$s1,$zero# y = b 1008 addi $ra,$zero,1016 # $ra=10161012 jsum 		# 调用函数sum1016 …2000 sum: add $v0,$a0,$a1 # 过程入口2004 jr $ra	 # new # 返回主程序instruction



过程调用实现机制

sum(a,b);/* a,b:$s0,$s1 */}int sum(int x, int y)

 {return x+y;}



1000 add$a0,$s0,$zero# x = a1004 add$a1,$s1,$zero# y = b 1008 addi $ra,$zero,1016 # $ra=10161012 jsum 		# 调用函数sum1016 …2000 sum: add $v0,$a0,$a1 # 过程入口2004 jr $ra	 # new # 返回主程序instruction



J1016

1008 jal sum

1012

过程调用机制

jal label #link and jump 

$ra=PC+4; #save next instruction address 

j Label

过程返回指令

jr $ra#return to main program



在32位MIPS体系结构下，最多可寻址4GB地址空间

0xFFFFFFFF

0xA0000000

0xC0000000

0xBFFFFFFF

0x80000000

0x9FFFFFFF

0x7FFFFFFF

0x00000000

MIPS 内存地址空间

数据通路流水线化



MARS

开源MIPS仿真器，汇编器

MIPSX86差异

4.5.3精简指令系统RISC

选取使用频率最高的一些功能实现，指令条数少

便于硬件实现，用软件实现复杂指令功能

指令长度固定，指令格式简单，寻址方式简单

只有存数/取数指令可以访问存储器(RS型)，其余指令的操作都在寄存器之间进行(RR型)

设置大量寄存器（32~192）

一个机器周期完成一条机器指令

RISCCPU采用硬布线控制，CISC采用微程序

CSIC与RISC互相融合

38

2010研究生统考例题

例. 某计算机字长为16位，主存地址空间大小为128KB，按字编址。采用单字长指令格式，指令各字段定义如图，转移地址采用相对寻址方式，相对偏移量用补码表示。寻址方式如图。



注(x)表示存储器地址x或寄存器x的内容

（1）该指令系统最多可有多少条指令？该计算机最多有多少个通用寄存器？存储器地址寄存器MAR和存储器数据寄存器MDR至少需要多少位？

2010研究生统考例题

注(x)表示存储器地址x或寄存器x的内容

（2）转移指令的目标地址范围是多少？

例. 某计算机字长为16位，主存地址空间大小为128KB，按字编址。采用单字长指令格式，指令各字段定义如图，转移地址采用相对寻址方式，相对偏移量用补码表示。寻址方式如表。



2010研究生统考例题

注(x)表示存储器地址x或寄存器x的内容

（3）若操作码0010B表示加法操作，助记符为add，寄存器R4，R5的编号分别为100B和101B，R4的内容为1234H，R5的内容为5678H，地址1234H中的内容为5678H，地址5678H中的内容为1234H，则汇编语句add(R4),(R5)+逗号前为源操作数，逗号后为目的操作数，对应的机器码是多少？用十六进制表示。该指令执行以后，哪些寄存器和存储单元的内容会发生改变？改变后的内容是什么？

例. 某计算机字长为16位，主存地址空间大小为128KB，按字编址。采用单字长指令格式，指令各字段定义如图，转移地址采用相对寻址方式，相对偏移量用补码表示。寻址方式如图。




MIPS仿真工具MARS 

MIPS汇编程序

汇编源程序由数据声明段和代码段组成。汇编程序文件以.s或.asm为后缀

数据声明 

以 .data开始，声明在代码中使用的变量、常量

在主存中创建了对应的空间    

代码段

以 .text开始，由指令构成的程序代码

代码以main: 开始。 

程序的注释 

使用#符号进行注释。  

MIPS汇编程序模板

# Title:	Filename:

# Author:	Date:

# Description:

# Input:

# Output:

###############数据段/Data segment #################

.data

 . . . #自定义的数据

###############代码段/Code segment ##################

.text

.globl main

main:	# main program entry

 . . . #自己写的代码

li $v0, 10	# Exit program

syscall

数据声明

格式： 

val_name: storage_type  value(s) 

创建一个以val_name为变量名，value(s)为初值，存储类型是storage_type的变量。  

变量名后要跟一个英文冒号

数据存储类型storage_type

.word， .half， .byte –字、半字、字节

.asciiz -字符串，以null结尾



var1: 	.word 3 			# var1为一个字变量，初值为	3，整数 

array1: .byte ‘a’,‘b’ 		# array1为两个元素的字节数	组，初值					# 分别为a和b的ASCII码 

array2: .space 40 		# 分配一块连续的内存区域，容量为40字节 

string1: .asciiz “Print this.\n” # 定义一个字符串 

汇编指令语句

代码部分的语句格式：

	[label:] mnemonic [operands][#comment]

Label: (标记)

标记一条指令在内存中的位置，以英文冒号结尾

Moemonic(助记符)

MIPS机器指令、汇编伪指令（比如add, sub,等)

Operands(操作数)

根据指令格式定义的操作数，可以是寄存器、内存变量、常量

	L1:	addiu $t0, $t0, 1	# $t0加1

系统调用(syscall)



1.取数、存数

################# code segment #####################

.data

value: .word 10, 20, 0

.text

.globl main

main:# main 入口

	la$t0, value # 将变量value的地址装入 $t0

		# la是伪指令

	lw$t1, 0($t0)# 将地址($t0+0)的字数据装入$t1

	lw$t2, 4($t0)# 将地址($t0+4)的字数据装入$t2

	add $t3, $t1, $t2# $t1 + $t2 = $t3

	sw$t3, 8($t0)# 将$t3中的数据存入地址($t0+8)



	li$v0, 10# 退出

	syscall

机器指令与汇编语言

伪指令

汇编器定义的，用于增强汇编程序可读性和提高编程效率

编译时，汇编器将伪指令翻译为一条或多条机器指令

汇编器建立符号表，以记录每个变量和标记的内存地址

例	符号表

	.DATA

	var1:.byte 1, 2,'Z'

	str1:.asciiz "My String\n"

	var2:.word 0x12345678

	.ALIGN3

	var3:.half 1000

符号表-symbol table 

Label

var1

str1

var2

var3

Address

0x10010000

0x10010003

0x10010010

0x10010018

2.读取并显示一个整数

################# code segment #####################

.text

.globl main

main:		# main program entry

	li	$v0, 5	# 5号功能调用，读取整数

	syscall	# $v0 = 读取的值



	move	$a0, $v0	# $a0 = 要显示的整数值

	li	$v0, 1	# 1号功能调用，显示整数

	syscall



	li	$v0, 10	# 退出程序

	syscall

MARS仿真步骤

点击工具栏 编译程序（快捷键F3）

运行（快捷键F5），“Run I/O”窗口显示并输出



程序运行结束，系统复位(F12)，重新开始

3.输入并显示字符串

################# Data segment #####################

.data

	str: .space10	# array of 10 bytes

################# Code segment #####################

.text

.globl main

main:		# main program entry

	la	$a0, str	# $a0 = address of str

	li	$a1, 10	# $a1 = max string length

	li	$v0, 8	# read string

	syscall

	li	$v0, 4	# Print string str 

	syscall

	li	$v0, 10	# Exit program

	syscall

4.三个整数相加（1/2）

# Input: 分别输入三个整数

#Output: 输出和

################### Data segment ###################

.data

prompt:	.asciiz "Please enter three numbers: \n"

sum_msg:	.asciiz "The sum is: "

################### Code segment ###################

.text

.globl main

main:

la$a0,prompt	# 显示提示字符串prompt

li$v0,4

syscall

li$v0,5	# 读第一个数到$t0

syscall

move$t0,$v0

4.三个整数相加（2/2）

li$v0,5	# 读第二个数到$t1

syscall

move$t1,$v0

li$v0,5	# 读第三个数到$t2

syscall

move$t2,$v0

addu$t0,$t0,$t1	# 累加	

addu$t0,$t0,$t2

la$a0,sum_msg	# write sum message

li$v0,4

syscall

move$a0,$t0	# 输出结果

li$v0,1

syscall

li$v0,10	# exit

syscall

运行结果

5.小写字母到大写转换(1/2)

# Objective: 小写字母转换到大写

# Input: 输入一个字符串.

#Output: 以大写形式输出.

################### Data segment #####################

.data

name_prompt:	.asciiz "Please type a string: "

out_msg:	.asciiz "Your name in capitals is: "

in_name:	.space 31	# space for input string

################### Code segment #####################

.text

.globl main

main:

la$a0,name_prompt	# print prompt string

li$v0,4

syscall

la$a0,in_name	# read the input string

li$a1,31	# at most 30 chars + 1 null char

li$v0,8

syscall



5.小写字母到大写转换(2/2)

la$a0,out_msg# write output message

li$v0,4

syscall

la$t0,in_name#t0为输入字符串的首地址

loop:

lb$t1,($t0)# load一个字节

beqz$t1,exit_loop# if t1 = 0, 退出循环

blt $t1,‘a’,no_change# t1 < ‘a’ ,表示大写，处理下一个字符

bgt $t1,‘z’,no_change# t1 > ‘z’ ,表示非字母字符，处理下一个字符

addiu $t1,$t1,-32# ‘a’<t1<‘z’ 小写转大写: 'A'-'a'=-32

sb$t1,($t0)	#保存于字符原位置

no_change:

addiu $t0,$t0,1# t0指向下一个字符

j loop

exit_loop:

la$a0,in_name# 输出转换完成的大写字符串

li$v0,4

syscall

li$v0,10 # exit

syscall




第五章 中央处理器

本章讨论CPU的功能组成，控制器的工作原理和实现方法，微程序控制原理，基本控制单元的设计以及先进的CPU系统设计技术

1

返回

第五章 中央处理器

5.1 CPU功能和组成

5.2 指令周期

5.3 时序产生器和控制方式

5.4 微程序控制器

5.5 硬布线控制器



5.6 流水CPU

5.7 RISC CPU



2



3

5.1CPU的功能和组成

5.1.1 CPU的功能

冯.诺依曼的“存储程序、程序控制”

用计算机解决某个问题时，首先编写程序

程序是一个指令序列，这个序列明确告诉计算机

应该逐步执行什么操作（操作码）

在什么地方找到用来操作的数据，结果存到何处（地址码）

4

5.1.1 CPU的功能

计算机进行信息处理的过程可分为两步：

①将程序和数据装入存储器；

②从程序入口开始取指令，执行指令，得到所需结果，然后结束运行

中央处理器是控制计算机自动完成取出指令和执行指令任务的部件

计算机的核心部件，简称为CPU（Central Processing Unit）

5.1.1 CPU的功能

指令控制：

保证控制器按顺序执行程序

操作控制

管理并产生一系列操作信号，将它们送往相应的部件

时间控制：

对各种操作实施时间上的定时

数据加工：

对数据进行算术和逻辑运算

5

6

5.1.2 CPU的基本组成

早期的CPU由运算器和控制器两大部分组成

现在将外围的一些逻辑功能部件纷纷移入CPU，使CPU的组成越来越复杂

7

8



9

运算器

数据加工处理部件

组成

ALU、通用寄存器、DR和PSW

主要功能

执行算术运算

执行逻辑运算



10

控制器 

协调和指挥整个计算机系统的操作

组成

PC、IR、指令译码器、时序发生器和操作控制器



功能

(1) 从指令Cache中取出一条指令，生成下一条指令在指令Cache的位置；

(2) 对指令进行译码，产生相应的操作控制信号

(3) 控制CPU、内存和输入/输出设备间的数据流动

11

5.1.3 CPU中的主要寄存器

在CPU中主要有以下六类寄存器

1. 数据寄存器（DR-Data Register）

2. 指令寄存器（IR-Instruction Register）

3. 程序计数器（PC-Program Counter）

4. 数据地址寄存器（AR-Address Register） 

5. 通用寄存器（R0~R3 –General Register）

6. 状态字寄存器（PSW-Program Status Word）

1. 数据寄存器（DR）

暂时保存要写入寄存器的数据

12



　　

2. 指令寄存器（IR）

Instruction Register

保存当前正在执行的指令内容



OP字段的输出作为指令译码器的输入

　　

3. 程序计数器（PC）

Program Counter

保存下一条指令的地址

在程序开始执行前必须将起始地址(入口地址)送入PC

修改PC的内容

顺序寻址：PC = PC+常量；

常量与指令长度有关

相对寻址：PC = PC+偏移量

跳跃寻址：PC = 偏移量

X86：EIP MIPS：PC



4.数据地址寄存器（AR） 

保存访问数据Cache的地址

本例中为保持访问数据Cache单元的地址



5. 通用寄存器

模型中有4个通用寄存器（R0~R3）

作为ALU的数据源和目的寄存器

用作地址指示器、变址寄存器、堆栈指示器等



6. 状态字寄存器（PSW）

一个由各种状态标志拼凑而成的寄存器

模型机中的PSW由ALU的运算结果设置

还保存中断和系统工作状态等

X86： FLAGS MIPS：无



18

5.1.4 操作控制器和时序发生器

数据通路 ：

部件之间传送信息的通路

操作控制器在各部件之间建立数据通路

操作控制器

根据指令OP码和时序信号，生成各种操作控制信号，以便正确地建立数据通路，从而完成取指令和执行指令的控制



19

5.1.4 操作控制器和时序产生器

操作控制器分为

硬布线控制器，采用时序逻辑技术实现

微程序控制器，采用存储逻辑实现



时序产生器

产生并发出计算机所需要的时序信号

对各种控制信号实施时间上的控制

20

5.2 指令周期

指令周期的基本概念

MOV、的指令周期

LAD指令的指令周期

ADD指令的指令周期

STO指令的指令周期

JMP指令的指令周期

用方框图语言表示指令周期

指令格式设计-编码

操作码位数

地址码位数：双地址码、单地址码

偏移量、寄存器位数

数据寻址方式

直接寻址、寄存器寻址、寄存器间接寻址

指令寻址方式

顺序寻址、跳跃寻址

不设定寻址特征位，由操作码默认指定寻址方式

21

5.2.1指令周期的基本概念

运行程序

第一步：从内存中取一条指令

第二步：执行该指令

周而复始



23

5.2.1指令周期的基本概念

上述步骤所需时间

从内存取出一条指令的时间：取指周期

分析并执行这条指令的时间：执行周期

指令周期=取指周期+执行周期

从内存取出一条指令、分析并执行这条指令的时间总和

指令功能不同，其指令周期不同

24

5.2.1指令周期的基本概念

一个指令周期划分为若干CPU周期

CPU周期又称机器周期

通常指从内存读一个字的最短时间

取指周期包含若干CPU周期

执行周期包含若干CPU周期

功能不同的指令，可能包含不同数目的CPU周期

25

5.2.1指令周期的基本概念

一个CPU周期包含若干时钟周期

时钟周期：T周期、节拍脉冲

处理操作的最基本时间单位

ALU完成一次正确的运算

寄存器间的一次数据传送等

相互关系： 

            1个指令周期 = 取指周期+执行周期

 =若干个CPU周期 

            1个CPU周期 = 若干时钟周期 

26

5.2.1指令周期的基本概念

指令周期=取指周期+执行周期

取指周期=1个CPU周期

执行周期=1个CPU周期

1CPU周期=4个 T周期

单周期CPU和多周期CPU

单周期CPU

在一个CPU周期内完成从取指、译码到执行的所有工作

效率低

多周期CPU

把指令执行周期分成多个阶段，每个阶段在一个CPU周期完成

容易流水线执行，效率高

27

简单定义一个指令集

6条指令，单字长，字长为1B，4个寄存器

MOV		寄存器数据传输 	RR型

LAD/STO 	取数/存数		RS型

ADD/AND 	加法/与	 	RR型

JMP 		转移 			RS型



28

简单定义一个指令集

指令寻址方式

顺序寻址：PC+1

跳跃寻址：PC=偏移量

数据寻址方式

直接寻址：EA=偏移量

寄存器寻址： EA=R

寄存器间接寻址：EA=(R)



29

指令格式设计

操作码（OP）定义

6条指令：MOV/LAD/STO/ADD/AND/JMP 

30

MOV

寄存器寻址 双地址码，功能：Rs -> Rd

LAD



直接寻址，功能：(A)->Rs

STO



寄存器间接寻址， Rs ->(Rd)

指令格式设计(类MIPS)

31

JMP

跳跃寻址	A->PC



ADD

寄存器寻址Rs + Rd -> Rd



AND

寄存器寻址Rs & Rd -> Rd

指令格式设计

32

一个小程序

33

一个小程序

34

六条典型指令组成的简单程序示例

35

程序运行到105地址时，各寄存器的值是多少？

36

如何设计指令周期

前提：

掌握每个指令要执行的操作

识别出各个部件的控制命令

两个阶段

取指阶段、执行阶段

两个步骤

找出数据通路：数据从哪里来，经过哪些部件，最终达到哪里

确定操作信号：形成上述数据通路所需的操作控制信号

37

图5.1的结构

控制信号

总线三态门：C1、C2、C3

存储器：数据Cache 读/写(RD(D))、指令Cache读(RD(I))

寄存器：每个寄存器都有输入和输出控制信号

输入控制信号：PCin、 Riin，DRin等

输出控制信号：PCout、 Riout等

PC：PC+1

ALU：加、与、传送

38

39



DCache读/写

ICache读

+\&\M

DRin

PCout

PCin

ARin

Riout

Riin

IRin

如何设计指令周期

时间设计：各个操作在哪个时钟周期发生

取指周期=？CPU周期

执行周期=？CPU周期

1个CPU周期定义

从内存读/写一个数据

或使用共享总线传输一个数据，总线只能有一个源

一个CPU周期内数据不能产生冲突

图5.1中

IBUS是独占的、DBUS是共享的

1个CPU周期包括4个T周期：T1~T4

40


指令周期

从内存取出一条指令、分析并执行这条指令的时间总和

指令周期=取指周期+执行周期= 若干个CPU周期 

            1个CPU周期 = 若干时钟周期 



1

如何设计指令周期

前提：

掌握每个指令完成的功能，要执行的操作

识别出各个部件的控制命令

分两个阶段

取指阶段、执行阶段

三个步骤

1. 找出数据通路：数据从哪里来，经过哪些部件/总线，最终达到哪里

2. 确定操作信号：形成上述数据通路所需的操作控制信号

3. 分配CPU周期

2

如何设计指令周期

分配CPU周期：各个操作信号在哪个CPU周期发出

取指周期=？CPU周期

执行周期=？CPU周期

1个CPU周期定义

从内存读/写一个数据

或使用共享总线传输一个数据，总线只能有一个源

一个CPU周期内数据不能产生冲突

3



4

4



DCache读/写

ICache读

+\&\M

DRin

PCout

PCin

ARin

Riout

Riin

IRin

IBUS是独占的、DBUS是共享的

1个CPU周期包括4个T周期：T1~T4

5.2.2 MOV指令的指令周期

MOV R0,R1

单字长，RR型

取指阶段：

数据通路：从指令Cache中取出指令经过IBUS写入IR

PCABUS(I)ICacheIBUSIR

操作控制：形成上述数据通路的控制信号

PC内容输出到指令Cache

指令Cache读操作，通过IBUS写入IR

PC+1，为取下一条指令做好准备

对IR中的OP译码，以确定进行什么操作

5

PCout

IRin

ICache读



6

5.2.2 MOV指令的指令周期

1. 取指周期：完成三件事

从指令Cache取出指令到IR

PC+1，为取下一条指令做好准备

对IR中的OP译码，以确定进行什么操作

2. 执行周期

将数据从R1传送到R0

由于操作简单，只需要一个CPU周期



7

PC中装入第一条指令地址101；

101

8

101

① PC的内容被放到ABUS（I）上，指令Cache进行译码，发出读命令；

101



R



②从101号地址读出的MOV指令通过IBUS装入IR；

③PC+1，变成102，为取下一条指令做好准备；



102

④ 对IR中的OP译码，识别出是MOV指令，取指阶段即告结束



MOV指令的取指阶段

9

5.2.2 MOV指令的取指周期

操作

PC内容输出到指令Cache

读指令Cache取出，指令写入IR

PC+1；

对IR中的OP译码

时间

访问内存取一条指令，需要1个CPU周期

10

MOV指令的执行周期

将数据从R1传送到R0

(1) OC送出控制信号到通用寄存器，选择R1做源寄存器，选择R0作目标寄存器；

(2) OC送出控制信号到ALU，指定ALU做传送动作；

(3) OC送出控制信号，打开ALU输出三态门C1，将ALU输出送到DBUS上；

(4) OC送出控制信号，将DBUS上的数据打入到DR

(5) OC送出控制信号，将DR中的数据打入R0，R0的内容由00变为10至此，MOV指令执行结束

11

MOV指令的执行阶段



M

DRin

Riout

Riin

5.2.2 MOV指令的指令周期

MOV R0,R1

单字长，RR型

执行阶段：

数据通路：寄存器R1的数据传输到R0

R1ALUDBUSDRR0

操作控制：形成上述数据通路的控制信号

选择R1做源寄存器，指定ALU做传送动作

打开ALU输出三态门C1，将ALU输出送到DBUS上

将DBUS上的数据写入到DR

将DR中的数据写入R0，R0的内容由00变为10



12

13

① OC送出控制信号到通用寄存器，选择R1做源寄存器，指定ALU做传送操作

M

10

② OC送出控制信号，打开C1，将ALU输出送到DBUS上



③ 将DBUS上的数据10打入到DR；

④将DR中的数据打入到R0，R0的内容由00变为10

MOV指令的执行周期

DRin

R1out

R0in

MOV指令的执行周期

操作

(1) 选择R1做源寄存器，指定ALU做传送动作；

(2) 打开ALU输出三态门C1，将ALU输出送到DBUS上；

(3) 将DBUS上的数据写入DR

(4) 将DR中的数据写入R0

时间：使用一次共享总线DBUS，需要1个CPU周期

14

15

5.2.2 MOV指令的指令周期

1. 取指 



2. 执行



16

5.2.2 MOV指令的指令周期（简化）

1.取指 



2. 执行



只考虑一个CPU周期内的操作

17

5.2.2 MOV指令的指令周期（再简化）



5.2.2 MOV指令的指令周期

MOV R0,R1

取指周期

1个CPU周期

执行周期

1个CPU周期

18

5.2.3 LAD指令

LAD R1,6

单字长，RS型

取指阶段

同MOV指令相同

执行阶段

数据通路：访问内存地址6的单元，取出数据写入R1

IRARABUS(D)DBUSDRR1

19

20

控制信号：

打开C3，将地址码6放到DBUS上；

将地址码6装入AR，数存进行地址译码；

读数存6号单元，数100读出到DBUS上；

将DBUS上的数据100写入DR；

将DR中的数据100写入R1



ARin

DCache读

DRin

R1in

21

LAD指令的执行周期

控制信号：

打开C3，将地址码6放到DBUS上；

将地址码6装入AR，DCache进行地址译码；

读数存6号单元，数100读出到DBUS上；

将DBUS上的数据100写入DR；

将DR中的数据100写入R1

22

LAD指令的执行周期

时间设计：

序号1和2，访问一次内存并使用DBUS，需要1个CPU周期

序号3、4和5，使用一次DBUS，需要1个CPU周期

23

LAD指令的执行周期（简化）



5.2.3 LAD指令的指令周期

24



5.2.3 LAD指令的指令周期

LAD R1,6

单字长

RS型

25

取指令

PC+1

译码指令



取出

操作数

取下条

指令PC+1



取指周期



开始



执行周期



装入通用

寄存器



5.2.3 LAD指令的指令周期

LAD R1,6

单字长

RS型

26

取指令

PC+1

译码指令



取出

操作数

取下条

指令PC+1



取指周期



开始



执行周期



装入通用

寄存器



5.2.5 ADD指令的指令周期

ADD R1,R2

单字长，RR型

执行阶段



27

28

OC送出控制信号到通用寄存器，选择R1和R2做源寄存器

100

20

OC送出控制信号到ALU，指定ALU做加法

120

打开C1，将运算结果120输出送到DBUS上



OC送出控制命令，将DBUS上的数据打入到DR

120

OC送出控制命令，将120装入R2，R2的内容由20变为120

ADD指令的执行

R1out

R2out

+

DRin

R2in

29

ADD指令的执行

数据通路

R1→ALU、R2→ALU，ALU→DBUS→DR→R2

操作控制

(1) 选择R1和选择R2，R1和R2加法操作

(3) 打开三态门C1，将运算结果120输出送到DBUS；

(4) 将DBUS上的数据打入DR；

(5) 将DR中的数据120写入R2，R2的内容由20变为120

30

ADD指令的执行周期

(1) 选择R1和R2输出到ALU，指定让ALU做加法操作；

(2) 打开C1，运算结果120输出送到DBUS；

(3) DBUS上的数据写入DR；

(4) DR中的数据写入R2

时间：占用一次DBUS总线，1个CPU周期

31

5.2.2 ADD指令的指令周期



5.2.5 ADD指令的指令周期

ADD R1,R2

单字长

RR型

取指周期：1个CPU周期

执行周期：1个CPU周期

32



5.2.5 STO指令的指令周期

STO R2,(R3)

单字长、RS型

执行阶段

数据通路：R3通过DBUS到AR，数据Cache地址译码，R2的内容通过Dbus写入数据Cache

33

21:16

34

（1）OC送出操作命令到通用寄存器，选择R3；



STO指令的执行

R3out

35

（2）OC送出命令, 打开C2，将地址30放到DBUS上；

30



STO指令的执行

36

（3）OC发出操作命令，将30装入AR，数存开始地址译码



30

30

STO指令的执行

ARin

37

（4）OC发出命令到通用寄存器，选择R2



30

STO指令的执行

R2out

38

（5）OC发出操作命令，打开三态门C2，将数据120放到DBUS上；



120

120



30

STO指令的执行

39

 （6）OC发出命令，将数据120写入30号单元，它原先的数据40被覆盖



30

120

STO指令的执行

DCache写

40

STO指令的执行

(1) 选择R3，打开三态门C2，将地址30放到DBUS上；

(2) 地址30装入AR；

(3) 选择R2 ，打开三态门C2，将数据120放到DBUS上；

(4) 将数据120写入数存30号单元

时间：使用两次DBUS，需要两个CPU周期

21:05

5.2.5 STO指令的指令周期

41

5.2.5 STO指令的指令周期

21:05

42

STO R2,(R3)

单字长

RS型

3个CPU周期

5.2.6 JMP指令的指令周期

JMP 101

无条件转移指令，改变程序的执行顺序

单字长、单地址

执行阶段

数据通路：IP中的101通过DBUS到达PC

操作控制

43

21:05

44

（1）打开三态门C3，将IR中的地址码101发送到DBUS上



JMP指令的执行

45

（2）将DBUS上的地址码101打入到PC中，PC中原先的内容106被覆盖

JMP指令的执行

PCin

46

5.2.6 JMP指令的执行周期

(1) 打开C3，地址码101发送到DBUS

(2) DBUS上的地址码101写入到PC

时间：占用一次总线，需要1个CPU周期

21:05

47

5.2.6 JMP指令的指令周期

5.2.6 JMP指令的指令周期

JMP 101

2个CPU周期

21:05

48

5.2.7 指令周期

49

5.2.7 指令周期

50

5.2.7 用方框图语言表示指令周期

采用方框图（指令流程图）来表示指令周期

一个矩形框代表一个CPU周期

矩形框中的内容表示数据通路

矩形框右边写出控制信号

菱形框表示判断或测试

时间上依附于前一个方框的CPU周期，不独占一个CPU周期

公操作符号“～”

一条指令执行完毕后CPU进行的一些共性操作，中断请求、DMA请求等

51

21:05

5.2.2 指令周期

52

译码

PCout,,IRin,PC+1

PCIR

5.2.7方框图表示指令周期

由上图可见，对于图5.1的模型机

所有指令的取指周期是完全相同的，而且是一个CPU周期。

在执行周期，由于各条指令的功能不同，所用的CPU周期也是各不相同

MOV、ADD、JMP指令是一个CPU周期

LAD、STO指令是两个CPU周期，需要访问内存

53

21:05

R1i

R1o

R2o

R2i

例1的数据通路图

R1i

R1o

R2o

R2i

画出下面指令的指令周期流程图，假设该指令的地址已放入PC中。列出相应的微操作控制信号序列

“ADD R2，R0”指令完成(R2)+(R0)→R0的功能

(2) “SUB R1，R3”指令完成(R3)-(R1)→R3的操作

基本步骤

取指周期

写出取指周期数据通路

PC xxxx IR

写出的控制信号形成上述数据通路

要记得PC+1

设定操作控制信号的时间

使用一次总线或访问一次内存为一个CPU周期

根据经验

执行周期

根据执行周期要完成的操作写出数据通路

具体指令具体分析，依据具体功能

写出形成上述数据通路的控制信号

设定操作控制信号的时间

RS型指令需要更多的CPU周期

56

取指周期(ADD R2，R0)

数据通路：PCBGA AR M DR B G A IR

57

取指周期(ADD R2，R0)

数据通路：PCBGA AR M DR B G A IR

控制信号： PCo、 G、ARi RDRo，G、 IRi

58

取指周期(ADD R2，R0)时间分配

数据通路：控制信号

PCBGAAR	：PCo、G、ARi 	（1个CPU周期）

M DR		：R			 （1个CPU周期）

DRB G AIR	：DRo，G、 IRi	 （1个CPU周期）

59

取指周期(ADD R2，R0)

60

PCAR	

PCo、G、ARi

M  DR

R

DRIR	

DRo，G、 IRi ，PC+1



ADD指令

执行周期(ADD R2，R0)

ADD R2，R0”指令完成(R2)+(R0)→R0的功能

数据通路：

R2BGA X； R0BGA Y； ALUBGAR0

61

执行周期(ADD R2，R0)

ADD R2，R0”指令完成(R2)+(R0)→R0的功能

数据通路：控制信号

R2BGA X: R2o，G、 Xi

R0BGA Y: R0o，G、 Yi

ALUBGAR0: +，ALUo，G、 R0i

62

执行周期(ADD R2，R0)时间分配

ADD R2，R0”指令完成(R2)+(R0)→R0的功能

数据通路：控制信号

R2BGA X: R2o，G、 Xi	 （1个CPU周期）

R0BGA Y: R0o，G、 Yi	（1个CPU周期）

ALUBGAR0: +，ALUo，G、 R0i （1个CPU周期）

63

执行周期(ADD R2，R0)

64

R2 X

R2o，G、 Xi

R0 Y

R0o，G、 Yi

ALUR0

+，ALUo，G、 R0i



65

 (1)“ADD R2，R0”指令是一条RR型加法指令

图的右边部分标注了每一个机器周期中用到的微操作控制信号序列。

ALU0

R0

66

(2)“SUB R1，R3” 在执行阶段，微操作控制信号序列与ADD指令有所不同。

ALU0


5.3时序产生器和控制方式

5.3.1 时序产生器作用和体制

5.3.2 时序信号产生器

5.3.3 控制方式

1

11:23

2

5.3.1 时序产生器作用和体制

计算机的协调动作需要时间标志，而时间标志则是用时序信号来体现

用时序信号辨认从内存中取出的是指令还是数据，是取指周期还是执行周期

一个CPU周期中时钟脉冲对CPU的动作有严格的约束

操作控制器发出的各种信号是时间（时序信号）和空间（部件操作信号）的函数

11:23

数据：电位

控制信号：脉冲

5.3.1、时序产生器作用和体制

时序信号的基本体制是电位—脉冲制（以触发器为例）

电位：用电平的高低进行控制

脉冲：用信号的边沿进行控制

11:23

3

在微程序控制器中，采用节拍电位-节拍脉冲二级体制

时序信号产生电路简单

一个CPU周期称为一个节拍电位

4

5.3.1、时序产生器作用和体制



Φ

T1

T2

T3

T4



节拍电位

节拍脉冲

11:23



C1

C2

在微程序控制器中，采用节拍电位-节拍脉冲二级体制

时序信号产生电路简单

一个CPU周期称为一个节拍电位

5

5.3.1、时序产生器作用和体制



Φ

T1

T2

T3

T4



CPU周期



CPU周期

节拍电位

节拍脉冲

11:23

硬布线控制器中，时序信号往往采用状态周期-节拍电位-节拍脉冲三级体制

时序信号产生电路复杂

状态周期是电位信号，指明当前指令处于哪个状态

比如，一个指令的状态周期包括取值周期和执行周期两个状态，取指周期包括1个CPU周期，执行周期包括2个CPU周期

6

5.3.1、时序产生器作用和体制

11:23



Φ

T1

T2

T3

T4



CPU周期



CPU周期

节拍电位

节拍脉冲

状态周期

状态周期-节拍电位-节拍脉冲三级体制

11:23

7



取指周期

执行周期



C1

C2

C3

8

5.3.2、时序信号产生器

时钟源:

石英晶体振荡器

环形脉冲发生器

节拍脉冲

启停控制逻辑

本书模型机启动时，一定要从T1前沿开始；

停机时一定要在T4结束后关闭时序产生器



11:23

9

1. 时钟源

时钟源用来为环形脉冲发生器提供频率稳定且电平匹配的方波脉冲信号

它通常由石英晶体振荡器和与非门组成的正反馈振荡电路组成，其输出为一个理想的方波

11:23

2、环形脉冲发生器



C4

C1

C2

C3

Φ

作用：产生一组有序间隔相等或不等的脉冲序列

11:23

10

3、节拍脉冲

11

11:23

3、节拍脉冲

12

11:23

3、时序信号举例

MOVR0 R1

该指令的取指周期的需要一个节拍电位，即一个CPU周期，

操作信号的节拍脉冲划分为：

PC->ABus(I)：T1

IBus->IR：T2

IR中OP->指令译码器：T3

11:23

13

3、时序信号举例

MOVR0，R1

该指令的执行周期需要一个节拍电位

操作信号的节拍脉冲划分为：

设置ALU完成传送操作：T1

R1->ALU：T2

DBus->DR：T3

DR->R0：T4

在一个节拍电位中完成四个有时序关系的操作

11:23

14

11:23

15



T1

T2

T3

T4



CPU周期

节拍脉冲

DBus->DR：T3

 信号来自译码器，持续一个节拍电位时间



4、节拍脉冲和读/写时序

16



11:23

17

节拍脉冲

节拍电位

11:23

4.启停控制逻辑

启动、停机具有随机性

当计算机启动时，一定要从节拍点位T1前沿开始工作

停机时一定要在节拍点位T4结束后关闭时序产生器

18

11:23

5.3.3控制方式

指令周期由若干个CPU周期组成

每条指令所需的时间各不相同

每个操作控制信号所需的时间及出现的次序各不相同

形成控制操作序列的方法，称作控制器的控制方式

有同步控制、异步控制、联合控制三种方式

19

11:23

1. 同步控制方式

CPU周期数固定、时钟周期数固定

节拍电位数固定，节拍脉冲数固定

与指令功能、操作复杂度、操作数类型无关

设计时固定，与指令的执行无关

具体方案：

(1) 采用统一的CPU周期

(2) 采用不定长CPU周期

(3) 中央控制与局部控制结合

大部分采用统一CPU周期，个别指令采用不定长CPU周期

20

11:23

21

2. 异步控制方式

CPU周期数可变、时钟周期数可变

可变：在指令执行时变化

每条指令的指令周期所需的CPU周期数不等

需要多少时间就占用多少时间

反馈机制：执行部件完成操作后发“回答”信号

11:23

22

3. 联合控制方式 

同步控制和异步控制相结合的方式

两种实现方法

1. 大部分指令同步控制，少数操作采用异步方式

2. CPU周期数可变、时钟周期数固定

11:23

5.4微程序控制器

英国剑桥大学的M·V·Wilkes教授于1951年首先提出

1964年，IBM公司在IBM 360系列机上成功地采用了微程序设计技术

20世纪70年代以来，由于VLSI技术的发展，推动了微程序设计技术的发展和应用

目前，x86系列几乎都采用微程序设计技术，ARM采用微程序和硬连线相结合

23

11:23

24

5.4微程序控制器

微程序控制（microprogramming control）基本思想

把操作控制信号编制成微指令，存放到只读存储器（控制存储器）里；

运行时，从控存中取出这些微指令，从而产生所需的各种操作控制信号

微程序设计技术是用软件方法来设计硬件

11:23

5.4.1微程序控制原理 

1微命令和微操作

部件分为两种：控制部件和执行部件



微命令：控制部件通过控制线向执行部件发出的控制命令

微操作：执行部件接受微命令后所进行的操作

微操作在执行部件中是最小、最基本的操作

25

11:23

1.微命令和微操作

微命令和微操作一一对应

控制门电位信号的变化、寄存器输入端的控制、ALU的基本执行过程…

微操作可分为相容和互斥两种：

互斥：是指不能同时或不能在同一个CPU周期内并行执行的微操作

相容：是指能够同时或在同一个CPU周期并行执行的微操作

26

11:23

27

（+，-，M）在同一个CPU周期中只能选择一个，因而是互斥的微命令

类似地，4，6，8也是互斥的

微命令1，2，3是可以同时进行的，所以是相容的微命令

X输入控制4，6，8和Y输入的5，7，9中任意两个微命令也是相容的

11:23

28

2微指令和微程序

微指令(Micro-instruction) ：在一个CPU周期中，一组实现一定操作功能的微命令的组合

在同一CPU周期内并行或并发执行的微命令的组合

微指令存储在控制器中的控制存储器中



11:23

2微指令和微程序

微程序

一系列微指令的有序集合就是微程序

一段微程序对应一条机器指令

微地址：存放微指令的控制存储器的单元地址

机器指令-》微程序-》微指令-》微命令-》微操作

以简单运算器通路图的微指令格式为例：



29

11:23



30

11:23

PC+1

LDIR

LDAR

LDDR

RD



31

2. 微指令和微程序

微指令格式举例



微指令字长为23位，由操作控制和顺序控制两大部分组成



11:23

2. 微指令和微程序

操作控制字段，发出控制信号

每一位表示一个微命令

某一位为1表示发出相应的微命令，为0不发出

32



11:23

33

5.4.2微指令和微程序

顺序控制字段，产生下一条微指令的地址（微地址）

后四位：直接微地址

P1P2：判断测试标志

P1P2=00：使用后四位直接微地址

P1P2=01：P2测试

条件满足，新微地址=直接微地址

条件不满足，新微地址=对直接微地址修改

P1P2=10：P1测试



11:23

3.微程序控制器原理框图

它主要由控制存储器、微指令寄存器和地址转移逻辑三大部分组成



34



AR 

11:23

(1)控制存储器(CM：Control Memory)

CM是微程序控制器的核心部件

存放微程序

只读存储器

CM的字长是微指令字的长度

字数=微指令数量

存储容量=微指令字的长度 X 微指令数量

35



11:23

控制存储器

用于存放微程序

控制存储器与主存对比



11:23

36

（2）微指令寄存器(μIR)

微地址寄存器和微命令寄存器组成

微地址寄存器μAR ：下一条微指令的微地址

微命令寄存器：微指令的操作控制字段和判别测试字段

37



11:23

（3）地址转移逻辑

修改微地址

根据IP中的OP字段译码产生微地址（入口微地址）

顺序控制字段中的直接微地址给出下一条微指令的地址

通过判别测试字段P和执行部件的反馈信息，形成新的微地址

38



11:23

4微程序举例

假设在某编程环境下，需要完成BCD码加法运算，代码：b = b + a

假定该代码的汇编语言是

 

 

b-》R2，a-》R1

对于该指令，共耗费3~4个CPU周期(异步控制)

指令:ADDBR2R1

11:23

39

40

十进制加法指令周期流程图

取指令

a+b运算

a+b+6运算

减6运算

P1测试，表示译码操作，用OP字段作为形成微指令的地址

加法运算

P2测试，用Cy的状态来修改微地址寄存器的最后一位



本条微指令

的微地址

默认后继微地址

11:23

4.微程序举例

一条微指令对应一个方框

微指令周期等于一个CPU周期

一个方框对应与一个CPU周期

指令流程图中有多少方框意味着该指令对应的微程序包含多少条微指令

41

11:23

第一条是取指微指令，要发出的微命令是

LDIR、PC+1，LDAR

P1译码测试



4.微程序举例

42

00000000000000

10

0000



111

11:23

4.微程序举例

第二条微指令的二进制编码是



 第二条微指令发出的微命令是

R1X，R2  Y，+，LDR2`



11:23

43

4.微程序举例

第三条微指令的二进制编码是



 第三条微指令发出的微命令是

R2  X，R3  Y，+，LDR2`

P2判断测试



11:23

44

4.微程序举例

第四条微指令的二进制编码是



 第四条微指令发出的微命令是

R2  X，R3  Y，-，LDR2`



11:23

45

0000



1001

0000



00000000000011110 

01000100100100000 00

微程序存放示意图

顺序控制

地址

…

…



1101



1100



1011

1010

1001

…

…



0010

0001

0000

0000

操作控制字段

…



01010010010000000

01000100110000000 

…



控制存储器CM

取指微指令

R2-R3->R2 微指令



R2+R3->R2 微指令

R1+R2->R2 微指令



…

指令:ADDBR2R1



01

00

00

10

11:23

46



执行微程序

一条机器指令的微程序由取指微程序和执行微程序组成

微程序存放

图5.1的主存

控存CM

11:23

47

微程序控制器的工作过程

(1)取指微程序执行取指周期的操作

PCIR，PC+1

译码：OP字段输出到地址转移逻辑，产生对应的执行微程序的入口地址，送入μAR



11:23

48



微程序控制器的工作过程

(2)根据μAR从CM中取出微指令，并产生下一条微指令的地址送入μAR 



11:23

49



微程序控制器的工作过程

(3) 执行微程序的最后一条微指令执行完毕后，将μAR设为取指微程序的入口地址，从而返回第(1)步

周而复始，直到所有机器指令执行完毕



11:23

50

51

5. CPU周期和微指令周期的关系

一个微指令周期与CPU周期时间相等



T1, T2, T3时间执行微指令(如运算等)

T4上升沿打入结果至寄存器

T4时间读取微指令



11:23

6. 机器指令与微指令的关系

一条机器指令对应一段微程序

一段微程序由若干条微指令组成

一个微指令包含多个微命令

机器指令、程序和地址与内存有关

微指令、微程序和微地址与控制存储器有关

52



11:23

53

　　　写控制

　　　　读控制



选择

WA1

WA0

　W

选择

RA1

RA0

　R



不写入

　*

　*

　0

不读出

　*

　*

　0

　R3

　1

　1

　1

　R3

　1

　1

　1

　R2

　0

　1

　1

　R2

　0

　1

　1

　R1

　1

　0

　1　

　R1

　1

　0

　1

　R0

　0

　0

　1

　R0

　0

　0

　1



 例 设某计算机运算器框图如图所示，其中ALU为16位的补码加法器，SA,SB为16位暂存器，4个通用寄存器的读、写控制功能见下表 

11:23

机器采用微程序控制方式，微指令操作控制字段格式如下(未考虑顺序控制字段)：

11:23

54

要求：写出如下指令执行周期微程序的编码： 

 (1)“ADD R0，R1”指令，即(R0)+(R1)→R1

 (2)“SUB R2，R3”指令，即(R3)-(R2)→R3

 (3)“MOV R2，R3”指令，即(R2)→(R3)

11:23

55

 2.写出微程序：

00**10100000

01**10010000

**0101001001



1. 画出ADD R0，R1指令的流程图

RA0RA1=00

R

LDSA

LDSB

RA0RA1=01

R

SB-ALU

WA0WA1=01

W

~

11:23

56

57

 2.写出微程序：11**10100000

10**10010000

**1101000101

1. 画出SUB指令的流程图

RA0RA1=11

R

LDSA

LDSB

RA0RA1=10

R

WA0WA1=11

W

~

11:23

58

 2.写出微程序： 10**10100000

**1101001011

1. 画出MOV指令的流程图

RA0RA1=10

R

LDSA

SB-ALU

WA0WA1=11

W

~

Reset

11:23

59

5.4.2微程序设计技术

设计微指令应当追求的目标

缩短微指令的长度

减小控制存储器的容量

提高微程序的执行速度

便于对微指令的修改

提高微程序设计的灵活性

操作控制字段和顺序控制字段的设计

如何用二进制表示各种操作控制信号

如何形成下一个微地址



目标可能是矛盾的！

11:23

1、微命令编码

操作控制字段采用的表示方法

直接表示法

编码表示法

混合表示法

60

11:23

（1）直接表示法

每一位表示一个微命令

“0”表示不发出该微命令

“1”表示发出该微命令

优点：

结构简单，并行性强，操作速度快

缺点：

每条微指令要包含所有的微命令，微指令太长，导致CM容量较大

61

11:23

（2）编码表示法

把相斥的微命令编成一个小组，然后通过译码器对小组信号进行译码，输出作为微命令



微指令字缩短，译码电路使微指令的执行速度减慢

比如：4个微命令如何编码？

要考虑不发出任何微命令的状态

62

11:23

（3）混合表示法

直接表示法与编码法结合

综合考虑指令字长、灵活性、执行微程序速度等方面的要求

63

11:23

2、微地址的形成方法

确定下一条微指令的微地址

下一条微指令的微地址成为后继微地址 

1. 计数器方式

2. 多路转移方式（断定方式）



64

11:23

（1）计数器方式

顺序执行时

后继微地址=当前微地址+增量；

类似指令的顺序寻址

非顺序执行（分支）时

后继微地址=微地址字段

类似跳跃寻址

特点

顺序控制字段较短，微地址产生机构简单

多路并行转移功能较弱，速度较慢，灵活性较差 

65

11:23

2）多路转移方式（断定方式）

一条微指令具有多个转移分支的能力称为多路转移

顺序执行时

后继微地址=微地址字段

非顺序执行（分支）时

按“判别测试”标志和“状态条件”信息产生一个微地址

66

11:23

2）多路转移方式

特点：

能以较短的顺序控制字段配合，实现多路并行转移，灵活性好，速度较快，

需要设计地址转移逻辑

67

11:23

68

某计算机采用微程序控制器，共有 32 条机器指令，公共的取指令微程序包含 2 条微指令，各指令对应的执行微程序平均由 4 条微指令组成，采用多路转移法确定下条微指令地址，则微指令中下址字段(微地址字段)的位数至少是( ) 

A. 5

B. 6

C. 7

D.8

11:23

69

微指令分类

微指令格式分成两类：水平型微指令和垂直型微指令

（1）水平型微指令

一次能定义并执行多个并行操作微命令的微指令，叫做水平型微指令



11:23

70

微指令中设置微操作码字段，由微操作码规定微指令的功能，称为垂直型微指令

其结构类似于机器指令的结构

每条微指令的功能简单

采用较长的微程序结构去换取较短的微指令结构



（2）垂直型微指令

11:23

71

垂直型微指令

寄存器-寄存器传送型



运算控制型



访问主存



条件转移



11:23

水平型微指令与垂直型微指令

水平型微指令

并行操作能力强，效率高，执行时间短、灵活性强

微指令字较长，微程序短，控存容量大，性能佳

垂直型微指令

字长短，微程序长，控存容量小，性能差

垂直型与指令相似，易于掌握

72

11:23

微指令设计与微指令格式

73

11:23

74

微程序设计

静态微程序设计

微程序设计好之后，存放在ROM中，无法修改

动态微程序设计

采用EPROM/Flash作为控制存储器，微程序可以根据改变

指令仿真

在一台机器上实现不同类型的指令系统

11:23



75



11:23


5.5硬连线控制器

硬连线控制器(Hard-wired controller)

也称为硬布线控制器

把控制器看作产生控制信号的逻辑电路

由门电路和触发器构成



1

2

返回

1.基本思想

输出信号

微操作控制信号(微命令)

CPU结构

3

LDIR(T4)

LDDR(T3)

PC+1

LDPC(T4)

RD(I)

RD(D)

WE(D) (T3)

LDR(T4)

LDAR(T4)

CPU结构

4

LDIR(T4)

LDDR(T3)

PC+1

LDPC(T4)

RD(I)

RD(D)

WE(D) (T3)

LDR(T4)

LDAR(T4)

每个操作控制信号的含义是：

RD(I)—读指存

RD(D)—读数存

WE(D)—写数存

LDPC—写入PC

LDIR—写入IR

LDAR—写入AR

LDDR—写入DR

PC+1

LDR2—写入R2寄存器

指令周期流程图

5

如何区分不同的CPU周期？

指令周期流程图

6

如何区分不同的CPU周期？

硬连线控制器时序

设定M1、M2、M3三个电位信号，各自等于一个CPU周期

每个CPU周期包括4个节拍脉冲（T1~T4）

三级时序 同步控制

M1

M2

固定3个机器周期，12个节拍

M3

节拍电位

硬连线控制器的指令周期流程图

采用同步控制方式，将所有指令的指令周期都设为3个CPU周期

图中M1、M2、M3为节拍电位信号，各自等于一个CPU周期

MOV、ADD和JMP指令在M3不执行任何操作

10

3. 微操作控制信号产生

在微程序控制器中

微命令由微指令产生。

在硬连线控制器中

微命令由布尔代数表达式描述的输出函数产生。

11

硬连线控制器设计方法

画出指令周期流程图，明确各节拍控制信号

找出产生同一个微操作信号的所有条件，建立操作时间表



与时序信号组合，写出逻辑表达式

化简、用门电路或可编程器件物理实现。

12

[例3]根据图5.29，写出以下操作控制信号RD(I)、RD(D)、WE(D)、LDPC、LDIR、LDAR、LDDR、PC+1、LDR2的逻辑表达式。其中每个操作控制信号的含义是：

RD(I)—指存读命令

RD(D)—数存读命令

WE(D)——数存写命令

LDPC—打入程序计数器

LDIR—打入指令寄存器

LDAR—打入数存地址寄存器

LDDR—打入数据缓冲寄存器

PC+1—程序计数器加1

LDR2—打入R2寄存器

13

LDIR(T4)

LDDR(T3)

PC+1

LDPC(T4)

RD(I)

RD(D)

WE(D) (T3)

LDR(T4)

LDAR(T4)

每个操作控制信号的含义是：

RD(I)—读指存

RD(D)—读数存

WE(D)—写数存

LDPC—写入PC

LDIR—写入IR

LDAR—写入AR

LDDR—写入DR

PC+1

LDR2—写入R2寄存器

[例3]根据图5.1，写出以下操作控制信号RD(I)、RD(D)、WE(D)、LDPC、LDIR、LDAR、LDDR、PC+1、LDR2的逻辑表达式。

解：（1）画出指令周期流程图 

15

（2）列出微操作时间表（根据数据通路和操作流程图）

16

（2）列出微操作时间表（根据数据通路和操作流程图）

列出在每个微命令在哪个电位、哪个节拍、哪个指令发产生？

17

（2）列出微操作时间表（根据数据通路和操作流程图）

设M1、M2、M3是节拍电位信号；T1、T2、T3、T4为一个CPU周期中的节拍脉冲信号；MOV、LAD、ADD、STO、JMP是机器指令OP操作码字段译码输出信号

18

（3）进行微操作信号的组合

得到如下逻辑表达式：      

       LDIR=M1·T4

		LDAR=M2· T4· (LAD+STO)

	LDDR=M2·T3· (MOV+ADD) +M3·T3·LAD 	PC+1 = M1	 	

 LDR2 = M2·T4·ADD



（4）最后给出电路（省略）

硬连线与微程序控制器比较

硬连线控制器执行速度快

硬连线控制器设计复杂，代价昂贵

微程序控制器设计简单，便于维护修改



20

5.6.4 Pentium CPU

1989年初0.8um工艺，310万晶体管

5V电压，功耗20W

非固定长度指令格式，9种寻址方式，191条指令，兼具有RISC和CISC特性

提供了更加灵活的存储器寻址结构，可以支持传统的4k大小的页面，也可以支持4M大小的页面（TLB）

动态转移预测技术（BTB转移目标缓存）



21

Pentium结构图

哈佛结构Cache

2路超标量

32位CPU

80位FPU

外部数据总线宽度为64位，外部地址总线宽度为32位

微程序控制器



22

5.7 RISC CPU

三个要素：

(1) 一个有限的简单的指令集；

(2) 配备大量的通用寄存器；

(3) 对指令流水线的优化

编译技术

5.7 RISC CPU

RISC机器的特征：

(1) 使用等长指令（4B）

(2) 寻址方式少且简单

(3) 只有取数指令、存数指令访问存储器

(4) 指令数目相对较少，指令格式简单

(5) 指令功能简单，控制器多采用硬连线方式

(6) 指令的执行平均时间(CPI)为一个时钟周期。

(7) 配置大量寄存器、优化使用。

(9) 支持指令流水并强调指令流水的优化使用。

(10)RISC技术的复杂性在它的编译程序



23

RISC与CISC的主要特征对比

25

MIPS Aptiv框图

硬布线控制器

指令缓存

数据缓存

总线接口

内存管理单元

算术与逻辑运算器

协处理器

指令译码器

通用寄存器

浮点运算器

26

ARM处理器 框图

平均微程序为1.8条微指令

本章重点内容

CPU的功能（控制器的功能、6类寄存器）

指令周期基本概念

设计指令周期，画指令周期流程图

时序产生器和控制方式基本原理

微程序控制器工作原理

微程序设计基本概念

硬连线控制器基本概念

本章容易混淆的一些概念

周期表示一段时间。

指令周期指机器指令从取指到执行完成所花的时间，包括取指周期和执行周期。

CPU周期=机器周期，一个CPU周期包括多个节拍脉冲。

节拍脉冲=T周期，处理操作的最基本单位

指令周期 ＞CPU/机器周期 ＞ 节拍脉冲

数据通路举例

某机字长16位，指令16位定长；

指令ADD (R1)，R0的功能为(R0)+((R1)) (R1)，即将R0中数据与R1内容所指向的主存单元的数据相加，并将结果送入R1内容所指向的主存单元中；

数据通路图中控制信号为1表示有效，假设MAR输出一直处于使能状态；



数据通路举例---取指令周期



C1

C2

C3

MAR

MDR

PC

IR

下表为取指令和译码阶段每个节拍(时钟周期)的功能和控制信号，请按相同方式给出执行阶段各节拍的功能和有效控制信号。



数据通路举例---执行指令周期



C1

C2

C3



MAR

MDR

A



((R1))  A



数据通路举例---执行指令周期



C4

C5



MAR

MDR

A



AC



(R0)+((R1))(R1)


5.6流水CPU

5.6.1并行处理技术

5.6.2流水CPU的结构

5.6.3流水线中的主要问题

5.6.4 Pentium CPU

1

5.6.1 并行处理技术

并行性的两种含义：

同时性 指两个以上事件在同一时刻发生；

并发性 指两个以上事件在同一时间间隔内发生。

计算机的并行处理技术主要有以下三种形式：

1. 时间并行

2. 空间并行

3. 时间并行+空间并行

2

1. 时间并行

让多个处理过程在时间上相互错开，轮流重叠地使用同一套硬件设备的各个部分，以加快硬件周转而赢得速度。

实现方式是采用流水处理部件。

目前的高性能微型机几乎无一例外地使用了流水技术。

3

5.6.1 并行处理技术

5.6.1 并行处理技术

2. 空间并行

指资源重复（空间因素），以“数量取胜”

VLSI为其提供了技术保证。

3. 时间并行+空间并行

指时间重叠和资源重复的综合应用 

4

流水线原理

1.时间并行

把任务分成若干子任务，使子任务在流水线的各阶段并发地执行

2.空间并行

资源重复 多处理器系统和多计算机系统

3.时间并行+空间并行

时间重叠和资源重复的综合应用。

奔腾CPU采用超标量流水技术，一个机器周期执行两条指令。

指令周期细分

 取指令IF(Instruction Fetch)

 指令译码ID(Instruction Decode)

 执行运算EX (Execution)

 访存阶段 MEM

 结果写回WB(Write Back)

一条指令不一定经历所有阶段



IF

ID

EX

MEM



WB

非流水线时空图

流水线时空图

完成N条指令需要的时间 5+(n-1)



超标量流水线时空图



时间T



IF

ID

EX

WB

空间S

I12

I34

I1

I2

I3

I4

I1

I2

I3

I4

I1

I2

I3

I4

I1

I2

I3

I4



 具有两条以上的指令流水线。满载时，每一时钟周期可以执行2条指令

I56



I78



流水线分类 

 1.指令流水线

取指---译码---取数---执行

 2.算术流水线

加法器, 乘法器, 快速傅里叶变换器

 3.处理机流水线

 由一串级连的处理机组成.

 每台处理机负责某一特定任务.

11

一个计算机系统可以在不同的并行等级上采用流水线

常见流水线有：

处理机流水线：程序步骤的并行

由一串级联的处理机构成流水线的各个过程段，每台处理机负责某一特定的任务。处理机流水线应用在多机系统中。 

指令流水线：指令步骤的并行

将指令流处理过程分为取指令、译码、执行、写回等几个并行处理过程段。

算术流水线：运算操作步骤的并行

如流水加法器、流水乘法器、流水除法器等。



3.流水线分类

流水线的相关冲突（hazzard）

资源相关

取操作数与取指令都需要访问主存

计算PC、分支地址，运算指令复用ALU

增加部件消除

数据相关

指令操作数依赖于前一条指令的执行结果

引起流水线停顿直到数据写回

分支相关

转移指令使得流水线发生中断

提前取出的指令作废，流水线清空



理想指令流水线

将指令过程分成5个阶段 

IF、ID、EX、MEM、WB

不同阶段之间设置缓冲接口部件（绿色部分）

接口部件本质是寄存器

各段通过接口传递与指令相关的数据，控制，反馈信息

对数据的加工处理依赖于前段接口传递过来的信息

MIPS经典5段流水线

14

流水线段间寄存器

5.6.3流水线中的主要问题 

流水线要有良好的性能，必须能够畅通流动，不发生断流

流水过程中通常会出现以下三种相关冲突（Hazard），使流水线断流。

1.资源相关

2.数据相关

3.控制相关

15

数据相关处理

增加相关检测判定逻辑

当前指令读寄存器与后续3条指令写寄存器相同

当前指令可能有0~2个读寄存器

后续3条指令可能有0~1个写寄存器

相关处理逻辑

流水线停顿

数据重定向

 -16- 

数据相关处理机制

软件方法（编译器完成）

插入空指令

调整程序顺序，使相关性在流水线中消失

硬件方法

寄存器堆写入和读出分离（先写后读，下跳沿写）

插入气泡（空操作）

数据重定向bypass（数据旁路）

将后端处理后的数据（还没来得及写回）重定向

数据在哪就从哪送到运算器



1.资源相关

多条指令进入流水线后在同一段时间内争用同一个功能部件所发生的冲突。



在时钟4时，I1与I4两条指令发生争用存储器资源的相关冲突

解决资源冲突的办法：

(1)冲突指令停顿若干周期，直到冲突消失；

(2)增设一个存储器，将指令和数据分别放在两个存储器中。

18

2.数据相关

在流水计算机中，由于多条指令的重叠处理，当后继指令所需的操作数，刚好是前一指令的运算结果时，便发生数据相关冲突。

如下表所示，ADD指令与SUB指令发生了数据相关冲突。

20

2.数据相关

例：两条指令发生数据相关冲突

ADD	R1,	R2,	R3		R2+R3-->R1

SUB		R4,	R1,	R5		R1-R5-->R4

AND	R6,	R1,	R7		R1^R7-->R6



2.数据相关

RAW(Read After Write)

后面指令用到前面指令所写的数据

WAW(Write After Write)

两条指令写同一个单元

WAR(Write After Read)

后面指令覆盖前面指令所读的单元

解决办法：

可以推后后继指令对相关单元的读操作

设置转发通路（Forwarding）

21

【例4】流水线中有三类数据相关冲突：写后读相关；读后写相关；写后写相关。判断以下三组指令各存在哪种类型的数据相关。



I1:ADD R1，R2，R3 ；(R2) + (R3)->R1

 I2:SUB R4，R1，R5 ； (R1) - (R5)->R4 

(2)I3:STO M(x)，R3 ；(R3)->M(x)，M(x)是存储器单元

I4:ADD R3，R4，R5 ； 　(R4)+(R5)->R3 

I5:MUL R3，R1，R2 ；(R1)×(R2)->R3

 I6:ADD R3，R4，R5 ； (R4) + (R5)->R3



写后读RAW相关

读后写WAR相关

写后写WAW相关

23

3.控制相关

由转移指令引起的。

当前指令有跳转，但流水已经开启后续指令处理过程

解决技术：

延迟转移法

由编译程序重排指令序列，让跳转的指令接在最后流水入口

转移预测法

用硬件预测将来的行为，提前让转移指令进流水。

指令调度

为了充分发挥指令流水线的效率，减小断流，降低指令间的相关性，在保证程序正确执行的前提下，需要对指令的执行顺序进行重新编排

静态调度

由编译器在编译过程中对指令进行调度

动态调度

由控制器在指令执行过程中进行调度，对程序员透明

乱序执行（Out Of Order）

记分牌算法， Tomasulo算法

25

5.6.4 Pentium CPU

1989年初0.8um工艺，310万晶体管

5V电压，功耗20W

非固定长度指令格式，9种寻址方式，191条指令，兼具有RISC和CISC特性

提供了更加灵活的存储器寻址结构，可以支持传统的4k大小的页面，也可以支持4M大小的页面（TLB）

动态转移预测技术（BTB转移目标缓存）



26

Pentium结构图

哈佛结构Cache

2路超标量

32位CPU

80位FPU

外部数据总线宽度为64位，外部地址总线宽度为36位

微程序控制器



27

Intel Haswell结构图

28

5.7 RISC CPU

三个要素：

(1) 一个有限的简单的指令集；

(2) 配备大量的通用寄存器；

(3) 对指令流水线的优化

编译技术

5.7 RISC CPU

RISC机器的特征：

(1) 使用等长指令（4B）

(2) 寻址方式少且简单

(3) 只有取数指令、存数指令访问存储器

(4) 指令数目相对较少，指令格式简单

(5) 指令功能简单，控制器多采用硬连线方式

(6) 指令的执行平均时间(CPI)为一个时钟周期。

(7) 配置大量寄存器、优化使用。

(9) 支持指令流水并强调指令流水的优化使用。

(10)RISC技术的复杂性在它的编译程序



29

RISC与CISC的主要特征对比

多周期流水线

31

32

MIPS Aptiv框图

硬布线控制器

指令缓存

数据缓存

总线接口

内存管理单元

算术与逻辑运算器

协处理器

指令译码器

通用寄存器

浮点运算器

33

ARM处理器 框图

平均微程序为1.8条微指令

本章重点内容

CPU的功能（控制器的功能、6类寄存器）

指令周期基本概念

五种基本指令的指令周期及其数据通路流程

时序产生器和控制方式基本原理

微程序控制器工作原理

微程序设计基本概念

硬连线控制器基本概念

本章容易混淆的一些概念

微命令

控制部件通过控制线向执行部件发出的各种控制命令

微操作

执行部件接受微命令以后所进行的操作

公操作

一条指令执行完毕以后，CPU所进行的操作



本章容易混淆的一些概念

微指令

在机器的一个CPU周期中，一组实现一定操作功能的微命令的组合，构成一条微指令

微程序:

一条指令均对应一段微程序，微程序固化在控制存储器中。

机器指令

本章容易混淆的一些概念

周期表示一段时间。

指令周期指机器指令从取指到执行完成所花的时间，包括取指周期和执行周期。

CPU周期=机器周期，一个CPU周期包括多个节拍脉冲。

节拍脉冲=T周期，处理操作的最基本单位

指令周期 ＞CPU/机器周期 ＞ 节拍脉冲


1

第六章总线系统

6.1 总线的概念和结构形态

6.2 总线接口

6.3 总线仲裁

6.4 总线的定时和数据传送模式

6.5 PCI总线和PCIe总线



6.1.1总线的基本概念

总线(BUS)是构成计算机系统的互连机构

是多个系统功能部件之间进行数据传送的公共通路

借助于总线

各系统功能部件之间实现地址、数据和控制信息的交换

在争用资源的基础上进行工作 

2

6.1.1总线的基本概念

一个单处理器系统中的总线大致分为： 

内部总线：CPU内连接各寄存器及运算器部件之间的总线 

系统总线：CPU和其他高速功能部件（如存储器、通道等）相互连接的总线 

I/O总线：中低速I/O设备相互连接的总线

3

物理特性：

总线的物理连接方式，包括根数、插头形状，引脚线的排列方式

功能特性：

描述总线中每一根线的功能：地址、数据、控制三类

电气特性：

定义每一根线上信号的传递方向（单/双向）及有效电平范围

时间特性：

规定了总线上各信号有效的时序关系，每根总线在什么时间有效

4

1. 总线的特性

2. 总线的标准化

对总线的四个特性定义一个广泛认可的标准

实现不同厂家的功能部件互换使用

USB、PCI-E

5

3. 总线带宽

6

常见总线带宽

8

6.1.2 总线的连接方式 

外围设备和总线的连接部件称为适配器(adapter)：

完成CPU和外设之间的数据传送和控制

实现传输速率匹配和同步；

通常称为接口(interface)

9

6.1.2 总线的连接方式 

总线影响计算机系统性能，单处理器计算机中采用的总线结构有两种基本类型：

单总线结构和多总线结构

单总线结构

CPU是主控设备（发起通信的设备）

结构简单、容易扩充

多部件共享总线，分时工作

传输效率低

处理器结构对总线有影响



10

11

2. 多总线结构



主要解决各种设备速率不匹配的问题

位于CPU内部，速度最快

连接主存

高速I/O设备

低速I/O设备

连接不同速率的总线

总线的效率和吞吐量得以提高

高速、中速、低速设备连接到不同的总线上同时进行工作

现代计算机中的多总线结构

12

6.2总线接口

6.2.1 信息的传送方式 

计算机系统中，传输信息有两种方式：

串行传送

并行传送

13

1.串行传送

按顺序传送一个数码（一个字节）的所有二进制位(bit) ，每次一位

一般先传低位，后传高位

使用一条物理传输线：单端传输

两条传输线：差分传输

数据传送前：并—串变换

数据接收后：串—并变换

14

1.串行传送

特点：成本较低、速度慢

位时间：每个比特在传输线上占用的时间长度

波特率(baud)：每秒钟传送的比特数

波特率是位时间的倒数

串行传送的数据格式编码



起始位(1b)+数据位(1B)+校验位(1b)+停止位(1b)

15

16

【例2】利用串行方式传送字符，设数据传送速率是120个字符/秒，每一个字符格式规定包含10个比特位（起始位、停止位、8个数据位）问波特率是多少?位时间是多少?

【解】：

波特率为：10位×120/秒=1200波特

位时间是波特率的倒数：

Td=1/1200=0.833×10-3s=0.833ms

2. 并行传送

同时传输多个比特，对每个数据位都需要单独一条传输线

数据传送比串行数据传送快得多（传输频率较低时）

17

发展趋势

并行传输距离受限

频率越高，线间串扰越严重，带宽无法继续提高

串行传输距离长

无串扰现象、提供更高的带宽

随着总线频率的增加，并行逐渐转向串行

SCSI  SAS

PATA  SATA

PCI  PCI-E

18

3. 分时传送

功能复用：某个传输线上既传送地址信息，又传送数据信息

分时复用：共享总线的部件分时使用总线

必须划分时间片



19

6.2.2 总线接口的基本概念 

I/O接口即I/O设备适配器

指CPU和主存、外围设备之间通过总线进行连接的标准化逻辑部件

I/O接口部件在连接的两个部件之间起着“转换器”的作用，实现彼此之间的信息传送

一个接口可连接一个设备，也可连接多个设备

20

6.2.2 总线接口的基本概念 

外部设备有自己的设备控制器

设备控制器通过I/O接口和总线连接，进而与CPU交换信息



外围设备的连接方法

6.2.2 总线接口的基本概念 

一个适配器的两个接口：

连接系统总线的接口

连接外设的接口

接口的典型功能：控制、缓冲、状态、转换、整理、程序中断 



22

6.3总线仲裁

总线上的设备有主方和从方两种形态

主方启动一个总线周期、从方响应主方请求

每次总线操作，只能有一个主方，可以有多个从方 

为了解决多个主方争用总线的问题，设置总线仲裁部件（arbitrator）

采用优先级策略或公平策略

按照总线仲裁电路的位置不同，分为

集中式和分布式

23

1. 集中式仲裁

一个中央仲裁器，连接线：

送往仲裁器的总线请求信号线BR(Bus Request)

仲裁器送出的总线授权信号线BG(Bus Grant)

表征总线是否空闲的信号BS（Bus Busy）

集中式仲裁采用三种方式

(1) 链式查询方式（菊花链查询-Daisy chain）

(2) 计数器定时查询方式

(3) 独立请求方式



24

(1)链式查询方式

接口发出总线请求信号BR（置BR为高）

仲裁器在总线空闲的时候（BS为低）开始仲裁

总线授权信号BG依次从一个I/O接口传送到下一个I/O接口（串行查询）

假如BG到达的接口无总线请求，则继续往下传递；

假如BG到达的接口有总线请求，该接口获得总线控制权（将BS置为1）， BG信号便不再往下传递

25

BS--总线忙

BR--总线请求 

BG--总线授权

查询过程

(1)链式查询方式

特点：

优先级固定：离仲裁器最近的设备具有最高优先级，离仲裁器越远，优先级越低

用线少，易扩充; 

对查询链的电路故障很敏感，单点故障



26

(2) 计数器定时查询方式

每个设备分配一个地址，设备内部有地址判别电路

仲裁器内部有个计数器，其输出和设备地址线连接

对设备地址计数

27

(2) 计数器定时查询方式

设备通过BR线发出总线请求

仲裁器在BS为低时让计数器开始计数，计数值通过设备地址线广播

设备内部的地址判别电路，判断地址线上的计数值与自身设备地址是否一致

如果一致且该设备的BR为高，获得了总线使用权，则置BS线为1

如果没有设备获得总线使用权，计数值加一，再次广播

仲裁器判断BS为高，中止计数查询

28

29

(2) 计数器定时查询方式

每次计数可以从“0”开始，也可以从中止点开发始

固定优先级：每次从“0”开始计数，优先级的顺序是固定的

公平优先级：从中止点开始计数，每个设备都有可能成为最高优先级

可变优先级：软件修改计数器初值

缺点：控制线较多、扩展性较差（与计数器的位数有关）



计数器

(3) 独立请求方式

每个设备均有独立的总线请求线BRi和总线授权线BGi

中央仲裁器中的排队电路决定首先响应哪个设备的请求，给设备以授权信号Bgi

特点：

响应速度快

控制灵活，

优先级可通过程序改变；



控制线数多、总线裁决机构较复杂



30

31

2. 分布式仲裁

每个功能设备都有自己的仲裁号以及仲裁器

仲裁过程通过协商完成

6.4.1 总线的定时

总线信息传送过程，可分为：

请求总线，总线仲裁，寻址，信息传送，状态返回

定时：事件出现在总线上的时序关系

同步定时：事件出现在总线上的时刻由总线时钟信号确定

总线信号中包含公共时钟线

异步定时：建立在应答式或互锁机制基础上

后一事件出现在总线上的时刻取决于前一事件的完成

不需要统一的公共时钟信号



32

6.5 PCI总线和PCIe总线

PCI-（Peripheral Component Interconnect）

是美国SIG 推出的32～64位总线（并行总线）

频率为33～66MHz，数据传输率为132～528MB/s 

基于PCI总线计算机结构

处理器

处理器

主存

控制器

主存

PCI设备



PCI设备



HOST桥

主设备目标设备

PCI/LAGACY总线桥

PCI/PCI桥

LAGACY

设备

LAGACY

设备

PCI设备

PCI设备



HOST总线

PCI总线

PCI总线

LAGACY总线（遗留）

现代计算机中的多总线结构

35

PCI总线特点

允许智能设备在适当的时候取得总线控制权以加速数据传输和对高度专门化任务的支持

支持猝发传输模式

与 ISA／EISA／MCA兼容

设有特别的缓存，实现外设与CPU隔离，外设或CPU的单独升级都不会带来问题

同步时序、集中式仲裁

PCI Express总线

PCI Express是一种基于串行技术、高带宽连接点、点到点连接的新型总线技术

PCI Express采用4根信号线

差分传输，全双工、可靠性高、速度快

多种连接方式，扩展性好

如×1、×4、×8、×16以及×32通道的连接器

支持热插拔和热交换

软件层与PCI兼容

37

PCI Express总线

PCI Express总线插槽

38



PCI Express总线

39

共享式

hub

独占式

switch

USB （Universal Serial Bus ）

由Compaq、Intel、Microsoft、NEC等公司于96年共同研制发布

传输速度高、使用简单、编程复杂

适合计算机中所有高、中、低速传输

外部总线

USB1.1/2.0 

4线传输、半双工



USB （Universal Serial Bus ）

USB 3.0

全双工



Type-C

物理接口

不区分正反面

USB标准演进

42

USB标准演进

43


1

第七章 外围设备

7.1 外围设备概述

7.2 磁盘存储设备

7.3 磁带存储设备

7.4 光盘和磁光盘存储设备

7.5 显示设备

7.6 输入设备和打印设备

7.1.1 外围设备的一般功能

外围设备又称外部设备：

功能:在计算机和其他设备之间，以及计算机与用户之间提供联系

每一种外围设备，都是在它自己的设备控制器控制下进行工作，而设备控制器则通过I/O接口和主机相连，并受主机控制

7.2 磁盘存储设备

磁表面存储：

将磁性材料涂在载磁体（铝或塑料）存储信息

磁盘存储器、磁带存储器

优点：

存储容量大，位价格低；可以重复使用；信息可以长期保存；

缺点：

存取速度较慢，机械结构复杂

3

1. 磁性材料物理特性

B---磁感应强度

H---外加磁场强度

I----电流

2. 磁表面存储器的读写原理

利用磁头来形成和判别磁性材料的不同磁化状态



磁性材料排列方式

磁性材料均匀排列在圆形载磁体上

水平排列

密度低、容量小



垂直排列

密度高、容量大



7.2.2 磁盘的组成和分类

目前硬磁盘主要是温彻斯特磁盘，简称温盘，是一种可移动磁头固定盘片的磁盘机

密封组合、悬浮磁头

防尘性能好，可靠性高，对使用环境要求不高

7

优点：没有摩擦、寿命长

硬盘磁头与盘片的接触方式：悬浮式

优点：没有摩擦、寿命长

温盘原理

10

1.44MB 软盘

软盘：固定磁头，可移动盘片

硬磁盘驱动器主要3个部件组成

定位驱动系统：控制磁头臂径向运动

主轴系统：控制磁盘旋转

数据转换系统：磁电互换



11

7.2.3 硬盘驱动器和控制器

7.2.4 磁盘上信息的分布

盘片的上下两面都能记录信息，称为记录面（surface）

一个记录面对应一个磁头（Head），用磁头表示记录面

记录面上一系列同心圆称为磁道（Track）

由外向内依次编号，最外侧为0磁道

每个磁道等弧度分为若干个扇区（Sector）

信息按扇区存放，每个扇区的存储信息量是相同的，为512B

12

7.2.4 磁盘上信息的分布

扇区之间有间隙(gap)，用于隔离扇区



spindle

surface



tracks



track k

sectors



gaps



磁头和盘片的运动



盘片旋转

磁头悬浮，沿半径方向运动.



 -14- 

7.2.4 磁盘上信息的分布

所有记录面上相同编号的磁道形成一个圆柱面(Cylinder)，简称柱面

柱面数等于磁道数

柱面是逻辑、虚拟概念

所有磁盘统一转动，所有磁头一起移动

磁盘访问过程：

1.OS计算出要访问的位置(C、H、S)

2.控制磁头移动到对应的柱面

3.磁盘旋转到起始扇区

4.磁盘继续旋转，磁头开始读写信息

15

硬盘上的一个扇区要用三个参数来定位（CHS模式）：柱面号、磁头号、扇区号

标准记录格式

 硬盘容量=柱面数×磁头数×扇区数×512字节 

7.2.4 磁盘上信息的分布

7.2.4 磁盘上信息的分布

如果某文件长度超过一个磁道的容量，应将它记录在同一个记录面上，还是记录在同一个柱面上?

17

磁头的移动都需要时间，而且在磁盘访问总时间中占比较大

如果某文件长度超过一个磁道的容量，应将它记录在同一个柱面上，因为不需要移动磁头，读/写速度快

7.2.4 磁盘上信息的分布

柱面号10位，磁头号8位，扇区为6位，得到CHS模式容量限制8.4G

现代磁盘采用LBA（逻辑区块地址(Logical Block Address）

18

7.2.5 磁盘存储器的技术指标

存储密度：

道密度：沿磁盘半径方向单位长度上的磁道数

位密度：磁道单位长度上能记录的二进制位数

面密度：位密度和道密度的乘积

一个磁盘存储器所能存储的字节总数，称为磁盘存储器的存储容量

格式化容量和非格式化容量

19

7.2.5 磁盘存储器的技术指标

20

21

7.2.5 磁盘存储器的技术指标

磁盘存取时间

23

【例1】磁盘有6片磁盘，每片有两个记录面，最上最下两个面不用存储区域内径22cm，外径33cm，道密度为40道/cm，内层位密度400位/cm，转速6000转/分问：

(1)共有多少柱面?

(2)总存储容量是多少?

(3)数据传输率多少?

24

解：(1) 共有多少柱面?

有效存储区域=16.5-11=5.5(cm)

因为道密度=40道/cm，共有40×5.5=220道，即220个圆柱面

(2)总存储容量是多少?

内层磁道周长为2πR=2×3.14×11=69.08(cm)

每道信息量=400位/cm×69.08cm=27632位=3454B

每面信息量=3454B×220=759880B

总容量=759880B×10=7598800B

(3)数据传输率多少?

磁盘数据传输率Dr=rN

N为每条磁道容量，N=3454B

r为磁盘转速，r=6000转/60秒=100转/秒

Dr=rN=100×3454B=345400B/s

 -25- 

硬盘发展趋势

充氦气：缩短碟片距离，增加碟片数量

4K扇区：与OS文件管理匹配，减少扇区浪费

叠瓦SMR、二维TDMR、微波辅助磁记录 (MAMR) 、热辅助磁记录 (HAMR) 

增大单碟容量

容量将到达100TB



26

 固态硬盘

固态硬盘SSD （solid state Disk）

由控制单元和ROM存储单元（FLASH芯片）组成

速度快、抗震、零噪音、重量轻等优点



28

29

7.3 磁带存储设备

磁带的记录原理与磁盘基本相同，只是它的载磁体是一种带状塑料，叫做磁带

磁带采用顺序访问方式，速度比磁盘速度慢

通常用作为数据备份的海量存储设备

30

7.4光盘和磁光盘存储设备

光盘上的信息以坑点形式分布

凹坑表示“1”，凸点表示为“0”

读出时，当激光束照射在凹坑上时反射率低；而照射在凸点上时反射率高

根据反射光的光强变化并进行光电转换，即可读出记录信息



只读型CD光盘

CD-DA

数字唱盘，记录数字化信息，74分钟数字立体声信息

CD-ROM 

容量640MB

可写CD

写一次型CD-R

利用激光改变有机染料记录面对光的反射率

可多次的重复写入

磁光盘 CD-MO(Magneto-Optical)

利用激光产生高温来改变磁场

CD-RW(Rewritable)

利用激光改变相变材料的晶态和非晶态两种状态

DVD

DVD使用较短波长的激光束，使盘片数据的密度达4.7GB，是CD产品容量的7倍，

如果采取双面双层的记录方式，容量更可高达17GB

DVD-ROM DVD-VideoDVD-Audio DVD-R DVD-RAM



 -33- 

不同盘片比较

Track Pitch:1.6μm

Minimum Pit Length：0.8 μm

Storage Density:0.41Gb/inch2

Track Pitch:0.74 μm

Minimum Pit Length：0.4 μm

Storage Density:2.77Gb/inch2

Track Pitch:0.32 μm

Minimum Pit Length：0.15 μm

Storage Density:14.73 Gb/inch2

CD 0.7GB

DVD 4.7GB

Blu_ray Disc25GB

 -34- 

光驱的速度

1倍速

CD在1小时内读完一张CD盘的速度定义为1倍速，150KB/S

DVD的1倍速则在1350KB/s左右

X倍速：指是最初光驱读取速率的多少倍的读取速率的光驱


1

第八章 输入输出系统

8.1 CPU和外设之间的信息交换方式

8.2 程序查询方式

8.3 程序中断方式

8.4 DMA方式

8.5 通道方式

8.6 通用I/O标准接口



返回

8.1 CPU与外设之间的信息交换方式

I/O设备同CPU交换数据的过程：

输入过程：

(1)CPU把一个地址放在地址总线，选择某一输入设备；

(2)CPU等候输入设备的数据有效；

(3)CPU从数据总线读入数据，并放在一个相应的寄存器中

输出过程：

(1)CPU把一个地址放在地址总线，选择输出设备；

(2)CPU把数据放在数据总线上；

(3)输出设备认为数据有效，从而把数据取走

问题的关键在于：

如何找到对应的外部设备? 编址方式

什么时候数据才有效?定时方式



2



外围设备编址方式

编址对象

I/O设备中的控制寄存器、数据寄存器、状态寄存器

3

外围设备编址方式:独立编址（Isolated I/O）

内存单元和I/O寄存器各自独立编址：两个地址空间

I/O寄存器地址称为端口号

访问I/O寄存器有专门的I/O指令

X86： out 80H, AX

4

外围设备编址方式:统一编址

也称为内存映射I/O：Memory Mapped I/O，MMIO

I/O寄存器和内存单元一起编址：一个地址空间

同一地址空间中的不同部分来区分I/O寄存器和内存单元

访存指令访问I/O设备和内存，Load/Store

ARM、RISC-V、MIPS

5

MIPS处理器内存映射I/O

6



【例1】假设有一个运行时间为100秒的基准程序，其中90秒是CPU时间，剩下的是I/O占用的时间如果在以后的5年里，CPU的速度每年提高50%但I/O时间保持不变，那么5年后运行程序要耗费多少时间？ I/O时间所占的比例是多少?

解：	耗费的时间=CPU时间+ I/O时间

目前， I/O时间=100-90=10秒

今后五年内CPU时间、I/O时间及其所占比例如下表：

外设定时

如何判断数据有效是外设定时的关键

根据外围设备的速度分为3种定时：

速度极慢或简单的外围设备(机械开关，显示二极管)

直接输入输出

慢速或中速的外围设备

异步定时

高速的外围设备

同步定时

8.1.4 CPU与I/O接口之间的数据传送

CPU管理外围设备的方式：

无条件传送方式（简单I/O方式）

程序查询方式

程序中断方式

直接内存访问(DMA)

通道方式

单片机多采用程序查询、程序中断

PC采用程序中断和DMA

通道方式用在大型计算机中

9

8.2 程序查询方式

又叫程序控制I/O方式

当需要输入/输出时，CPU暂停执行主程序，转去执行设备输入/输出的服务程序，进行数据传输

异步定时：查询设备状态，判断是否有效

10

3、程序查询方式的接口

11

设备选择电路用于判断地址总线上呼叫的设备是否为本设备

数据缓存寄存器

缓存从外设读出的数据或者CPU输出到外设的数据

设备状态标志

用于标志设备的工作状态，



4、程序查询输入/输出方式



信息交换完全由CPU执行程序实现

启动设备;

反复查询设备直至设备准备好;

传输单个数据

重复2-3步直至数据传输完毕

CPU和外设串行工作，反复查询设备状态占用较多CPU时间，系统效率低

CPU占用率取决于查询频率

用于单片机

4、程序查询输入/输出方式

有多个设备时，CPU周期性地(轮询)调用各I/O设备的子程序



13

8.2 程序查询方式

处理器速度为10MIPS，I/O设备为键盘，其操作速度为10字符/s，采用程序查询方式进行控制，那么对于每个输入操作，CPU等待的时间可以执行__ 万条指令

14

8.2 程序查询方式

特点：

数据传输完全依赖于程序控制

硬件结构简单

频繁的查询动作浪费了大量的CPU时间

实时性差，随机事件响应慢

目前只用在单片机中

16

8.3程序中断方式

8.3.1 中断的基本概念 

8.3.2 中断服务程序入口地址的获取

8.3.3 程序中断方式的基本I/O接口

8.3.4 单级中断

8.3.5 多级中断

8.3.6 Pentium中断机制

8.3.1中断的基本概念  

中断（Interrupt）是指CPU暂时中止现行程序，转去处理随机发生的事件，处理完后自动返回原程序的功能和技术

也称为异常(exception)

中断系统是计算机实现中断功能的软硬件总称

一般在CPU中设置中断机构

在外设接口中设置中断控制寄存器

在软件上设置相应的中断服务程序

17

8.3.1中断的基本概念  

中断源:产生中断的事件

与I/O设备信息交换：网络通信

故障处理：

硬件故障：掉电、校验错

软件故障：溢出、除数0

实时事件处理：键盘、鼠标

程序调度，时间片划分

软中断

18

8.3.1中断的基本概念  

中断处理过程：

某一外设的数据准备就绪后，“主动”向CPU发出中断请求信号；

当CPU响应此中断，暂停运行主程序，自动转去该设备的中断服务程序；

当中断服务程序执行完毕后，CPU又回到原来的主程序继续执行

中断适合于处理随机出现的事件

19

8.3.1中断的基本概念  

响应中断的时机

什么时候对外设的中断请求进行响应？

断点保护问题 

如何在处理完中断后正确返回主程序？

多重中断处理

中断处理过程中又有外设发出中断请求怎么办？

中断功能实现的软硬件分工

哪些功能用软件实现，哪些功能需要硬件支持？

20

8.3.1中断的基本概念  

21

单级中断处理过程流程图



(1)响应中断的时机

外设的中断请求存放在接口中的中断源锁存器里，并通过中断请求线连至CPU

外设的中断请求是随机的，CPU只有在当前指令执行完毕，转入公操作时才受理中断请求



(2)断点保护问题:正确返主程序 

断点：主程序被中断的地方（PC）

现场：当前指令执行结束后CPU的状态(包括寄存器值和一些状态标志位)

保存现场：现场保存到堆栈中

恢复现场

从堆栈中恢复PC和CPU状态，以便从断点处继续执行主程序



(3)多重中断处理

中断处理过程中又有新外设发出中断请求怎么办？

在CPU中有一个中断屏蔽寄存器

置“1”(设置屏蔽)，关中断，不受理中断请求

置“0”(取掉屏蔽)，开中断，受理中断请求

可以通过程序控制

实现中断嵌套



(4)中断功能实现的软硬件分工

中断周期的操作由硬件实现

也称为“中断处理的隐操作”，程序员看不到

响应中断、关中断、保存断点、找出中断源

顺序很重要

中断服务程序由软件实现

保存现场、对发起中断的设备服务、恢复现场、开中断、返回主程序



8.3.2中断服务程序入口地址的获取 

转移到中断服务程序：找到中断服务程序的入口地址

向量中断：

当CPU响应中断时，由硬件直接产生一个地址(即向量地址)

向量地址:设备的中断服务程序入口地址

查询中断：

硬件为所有中断安排一个公共的中断服务程序

该公共程序查询并跳转至相应中断服务程序入口

26

8.3.3 程序中断方式的基本I/O接口:向量中断

27



准备就绪的标志(RD-Ready)

允许中断寄存器(EI-Enable Interrupt)

中断请求寄存器(IR-Interrupt Request)

中断屏蔽寄存器(IM-Interrupt Mask)

8.3.3 程序中断方式数据输入的执行过程

28

①由程序启动外设，将该外设接口的BS标志置“1”，RD标志清“0”；

②接口向外设发出启动信号；

④当设备动作结束或数据缓冲寄存器填满时，设备送出控制信号，将RD置“1”；

⑧设备的中断向量逻辑讲中断向量发到数据总线，CPU将中断向量赋值给PC，跳转到中断服务程序



③外设传送数据到接口的数据缓冲寄存器；



⑤当EI为“1”时，接口向CPU发出中断请求；

⑥在一条指令执行公操作时， CPU检查IR寄存器如果标志IM为“0”，进入中断周期 ；

⑨中断服务程序把接口中数据缓冲寄存器的数据读至CPU中的寄存器；

（10）CPU发出控制信号C将接口中的BS和RD标志复位

⑦CPU受理中断请求，向外设发出中断响应信号INTA并关闭中断；

8.3.4 单级中断

所有中断源通过INTA链式查询方式连接，属于同一级

离CPU近的中断源优先权高

不允许任何中断源打断中断服务程序，即使优先权比它高也不能

CPU中有1个IM，1个IR

29



INTA： Interrupt Authorization 中断授权信号

单级中断源的识别

串行排队链法

IR1，IR2，IR3为中断请求信号

IS1，IS2，IS3为中断选中信号

30

8.3.5 多级中断

中断源分成多个级别

两级优先权

每级有一个级别优先权

每级内又有级内优先权

中断级别高的中断源可以打断级别低的中断源，称为中断嵌套

31

32

8.3.5 多级中断

一维多级中断：每级中断只有一个中断源

二维多级中断：每级中断有多个中断源

一个系统有n级中断，则CPU中有n个IR，n个IM



33

8.3.5 多级中断

某级中断被响应后，则关闭本级和低于本级的IM，开放更高级的IM

不同级别的中断可以嵌套，但同一级的中断不允许嵌套

中断服务程序中使用多级堆栈保存现场（包括IM）



中断请求的处理方法:单级中断

优先权顺序：A>B>C



中断请求到达顺序

中断请求的处理方法:多级中断

优先权顺序：A>B>C



中断请求到达顺序

多级中断源的识别

采用了独立请求方式和链式查询方式相结合的方式

级间采用独立请求方式

优先排队电路

中断向量产生电路

级内采用链式查询方式

36

开放和屏蔽中断

屏蔽中断

指CPU中的中断屏蔽寄存器IM置1

处于“关中断”

所有可屏蔽中断源的中断请求得不到响应

开放中断

指CPU中的IM置0

处于“开中断”

可以响应中断源的中断请求

37

允许和禁止中断

禁止中断

指某个中断源接口中的中断允许寄存器EI被置0

对应的中断源不能发出中断请求

处于“中断封锁”

允许中断

中断接口中的EI置1

中断源处于“中断开放”

允许中断源发出中断请求

38

【例1】参见图所示的二维中断系统请问：

(1)在中断情况下，CPU和设备的优先级如何考虑?请按降序排列各设备的中断优先级

【解】

(1)在中断情况下，CPU的优先级最低各设备的优先次序降序排列是：A→B→C→D→E→F→G→H→I→CPU



39

(2)若CPU现执行设备B的中断服务程序，IM2，IM1，IM0的状态是什么?如果CPU执行设备D的中断服务程序，IM2，IM1，IM0的状态又是什么?

【解】执行设备B的中断服务程序时IM2IM1IM0=111；

执行设备D的中断服务程序时，IM2IM1IM0=011

多级中断中，某级中断被响应后，则关闭本级和低于本级的IM，开放更高级的IM

40

(3)每一级的IM能否对某个优先级内的个别设备单独进行屏蔽?

 如果不能，采取什么办法可达到目的?

【解】

(3)每一级的IM标志不能对某个优先级内的个别设备进行单独屏蔽。

可将接口中的EI(中断允许)标志清“0”，它禁止设备发出中断请求

41

(4)假如设备C一提出中断请求，CPU立即进行响应，如何调整才能满足此要求?

【解】

(4)要让设备C的中断请求及时得到响应，可将设备C从第2级取出来，单独放在第3级上，使第3级的优先级最高即可

42

【例2】参见图8.9所示的系统，只考虑A，B，C三个设备组成的单级中断结构，它要求CPU在执行完当前指令时对中断请求进行服务假设：

(1)CPU“中断批准”机构在响应一个新的中断之前，先要让被中断的程序的一条指令一定要执行完毕；

(2)TDC为查询链中每个设备的延迟时间；

(3)TA，TB，TC分别为设备A，B，C的服务程序所需的执行时间；

(4)TS,TR为保存现场和恢复现场所需的时间；

(5)主存工作周期为TM

 试问：就这个中断请求环境来说，系统在什么情况下达到中断饱和?



43

例

假定多级中断，其中断优先级由低到高为L0→L1→L2，试设置中断屏蔽字，将中断优先级由低到高改为L1→L2→L0



原先的屏蔽字

例

假定多级中断，其中断优先级由低到高为L0→L1→L2，试设置中断屏蔽字，将中断优先级由低到高改为L1→L2→L0

 新的屏蔽字



A、B、C是与主机连接的3台设备，采用多级中断实现中断优先级处理，其各自的中断服务程序中对中断屏蔽码的设置如下表所示: 

解：从中断屏蔽字看出，其处理优先级为：

 A > C > B > CPU

 故CPU执行程序轨迹如下：



A服务

B服务

C服务



CPU

A

B



C



 2040 6080

8.3.6 Pentium中断机制

1. 中断类型

Pentium有两类中断：中断和异常

中断通常称为外部中断，由外部硬件信号引发有两种情况 ：

(1) 可屏蔽中断：可通过CPU中标志寄存器屏蔽

(2) 非屏蔽中断：这类中断不能被屏蔽

异常由指令执行引发

(1) 执行异常： 执行一条指令过程中出现错误、故障等

(2) 执行软件中断指令： 如执行INT 0，INT 3，INT n等指令

Pentium共有256种中断和异常，每一个有中断向量号(0～255)

中断优先级分为5级

48

2. 中断服务程序

中断服务程序的入口地址信息存于

实模式为中断向量表IVT

保护模式为中断描述符表IDT

Pentium取得中断向量号的途径有三种：

(1) 指令给出：INT 20H

(2) 外部提供：8259中断控制器

(3) CPU识别错误、故障现象



49

50


